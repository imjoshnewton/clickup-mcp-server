This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  ISSUE_TEMPLATE/
    issue.md
  workflows/
    publish.yml
  FUNDING.yml
  PULL_REQUEST_TEMPLATE.md
docs/
  api-reference.md
  file-attachment-examples.md
  file-attachment-usage.md
  workspace-tasks.md
src/
  services/
    clickup/
      task/
        index.ts
        task-attachments.ts
        task-comments.ts
        task-core.ts
        task-custom-fields.ts
        task-search.ts
        task-service.ts
        task-tags.ts
      base.ts
      bulk.ts
      document.ts
      folder.ts
      index.ts
      list.ts
      tag.ts
      time.ts
      types.ts
      workspace.ts
    shared.ts
  tools/
    task/
      attachments.ts
      attachments.types.ts
      bulk-operations.ts
      handlers.ts
      index.ts
      main.ts
      single-operations.ts
      time-tracking.ts
      utilities.ts
      workspace-operations.ts
    documents.ts
    folder.ts
    index.ts
    list.ts
    tag.ts
    utils.ts
    workspace.ts
  utils/
    color-processor.ts
    concurrency-utils.ts
    date-utils.ts
    resolver-utils.ts
    sponsor-service.ts
    token-utils.ts
  config.ts
  index.ts
  logger.ts
  server.ts
.gitignore
.npmignore
changelog.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Dockerfile
LICENSE
mcp_test_plan_outline.md
mcp_test_plan.md
package.json
README.md
release-notes.md
SECURITY.md
smithery.yaml
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/ISSUE_TEMPLATE/issue.md">
---
name: Issue
about: Report a bug or suggest a feature
title: ''
labels: ''
assignees: ''
---

## Type
- [ ] Bug Report
- [ ] Feature Request
- [ ] Question/Other

## Description
<!-- For bugs: What happened? What did you expect to happen? -->
<!-- For features: What would you like to add? Why is it needed? -->

## Additional Information
<!-- For bugs: Steps to reproduce, error messages, environment details -->
<!-- For features: Example usage, alternative solutions -->
</file>

<file path=".github/FUNDING.yml">
github: taazkareem
buy_me_a_coffee: taazkareem
</file>

<file path=".github/PULL_REQUEST_TEMPLATE.md">
# Pull Request

## Description
<!-- Provide a detailed description of the changes introduced by this PR -->

## Related Issue
<!-- Link to the issue this PR addresses (if applicable) -->
Fixes #

## Type of Change
<!-- Mark the appropriate option with an "x" -->
- [ ] Tool functionality (new tool, tool modification)
- [ ] MCP integration improvement
- [ ] Bug fix
- [ ] Performance optimization
- [ ] Documentation update
- [ ] API enhancements
- [ ] Security improvement

## MCP Server Impact
<!-- Describe how this change affects the MCP server behavior -->

## API Changes
<!-- Describe any changes to APIs (both ClickUp API interactions and Service layer) -->

## Checklist
<!-- Mark the items you've completed with an "x" -->
- [ ] My code follows the code style of this project
- [ ] I have tested the changes
- [ ] I've verified compatibility with MCP standards
- [ ] All tool schemas are properly documented
- [ ] Service layer changes are backward compatible (or documented if breaking)
- [ ] Rate limiting and error handling tested (if applicable)
- [ ] Security considerations addressed

## Testing
<!-- Describe how you tested your changes -->

## Documentation Updates
<!-- List any documentation updates needed -->

## Screenshots (if applicable)
<!-- Add screenshots to help explain your changes -->

## Additional Notes
<!-- Any additional information that might be helpful for reviewers -->
</file>

<file path="docs/file-attachment-examples.md">
# ClickUp Task Attachment Examples

This document provides examples of how to use the `attach_task_file` tool with different file sources.

## Important Note About Parameters

The `file_url` parameter is a dual-purpose parameter that can accept either:
1. An absolute local file path (starting with `/` on Unix/Mac or `C:\` on Windows)
2. A web URL (starting with `http://` or `https://`)

This design allows for a unified interface, but it's important to provide the correct format.

## 1. Using Local File Path (Recommended)

The simplest way to attach a file is by providing an absolute path to a local file using the `file_url` parameter:

```javascript
const response = await mcp.invoke("attach_task_file", {
  taskId: "86b4bnnny",
  file_url: "/absolute/path/to/your/document.pdf"  // Note: Uses file_url for local path
});

console.log(response);
// {
//   success: true,
//   message: "File \"document.pdf\" successfully attached to task 86b4bnnny",
//   attachment: { ... }
// }
```

⚠️ **Note:** Only absolute file paths are supported (starting with `/` on Unix/Mac or `C:\` on Windows).

You can also specify a custom file name:

```javascript
const response = await mcp.invoke("attach_task_file", {
  taskId: "86b4bnnny",
  file_url: "/absolute/path/to/your/document.pdf",  // Uses file_url for local path
  file_name: "Important-Document.pdf"
});
```

## 2. Using URL-Based Method

For files that are already available online, use the same `file_url` parameter with a web URL:

```javascript
const response = await mcp.invoke("attach_task_file", {
  taskId: "86b4bnnny",
  file_url: "https://example.com/path/to/document.pdf"  // Uses file_url for web URL
});
```

With authorization if needed:

```javascript
const response = await mcp.invoke("attach_task_file", {
  taskId: "86b4bnnny",
  file_url: "https://example.com/path/to/document.pdf",  // Uses file_url for web URL
  auth_header: "Bearer your-access-token"
});
```

## 3. Using Base64-Encoded Method

For programmatically generated files or when working with file data:

```javascript
const fs = require('fs');
const filePath = '/path/to/your/document.pdf';
const fileData = fs.readFileSync(filePath);
const base64Data = fileData.toString('base64');

const response = await mcp.invoke("attach_task_file", {
  taskId: "86b4bnnny",
  file_data: base64Data,
  file_name: "document.pdf"
});
```

## 4. Using Task Name Instead of ID

You can also reference tasks by name and list:

```javascript
const response = await mcp.invoke("attach_task_file", {
  taskName: "My Important Task",
  listName: "Development Tasks",
  file_url: "/absolute/path/to/your/document.pdf"
});
```

## Notes

- For large files (>10MB), the tool automatically switches to chunked uploading
- Local file paths must be absolute (starting with `/` on Unix/Mac or drive letter like `C:\` on Windows)
- The tool will extract the filename from the path if not explicitly provided
</file>

<file path="docs/file-attachment-usage.md">
# ClickUp Task File Attachments

This document provides examples and explanations for using the file attachment feature of the ClickUp MCP server.

## Overview

The server provides a single unified tool for attaching files to ClickUp tasks, with intelligent method selection based on the file source and size.

## Available Methods

The attachment tool supports three different methods internally:

1. **Base64 Method**: For small files encoded as base64 strings (automatically used when providing `file_data`)
2. **URL Method**: For files available online (automatically used when providing `file_url`)
3. **Chunked Upload**: For large files (automatically used when base64 file size exceeds limits)

## Basic Usage

### Method 1: Upload from Base64 Data

Use this method for small files by providing the file content as a base64-encoded string.

```javascript
// Node.js example
const fs = require('fs');
const path = require('path');

// Read a file and convert to base64
const filePath = path.join(__dirname, 'example.pdf');
const fileData = fs.readFileSync(filePath);
const fileBase64 = fileData.toString('base64');

// Call the MCP tool
const result = await mcpClient.callTool('attach_task_file', {
  taskId: 'abc123xyz', // ClickUp task ID
  file_name: 'example.pdf',
  file_data: fileBase64
});

console.log(result);
```

### Method 2: Upload from URL

Use this method when the file is already available at a URL (e.g., cloud storage, CDN).

```javascript
// Call the MCP tool
const result = await mcpClient.callTool('attach_task_file', {
  taskId: 'abc123xyz', // ClickUp task ID
  file_url: 'https://example.com/path/to/file.pdf',
  file_name: 'renamed-file.pdf', // Optional, will use URL filename if omitted
  auth_header: 'Bearer token123' // Optional, for accessing protected resources
});

console.log(result);
```

### Method 3: Large File Upload (Automatic Chunking)

For files larger than 10MB, the system automatically handles chunking for you. You just provide the file data as with small files.

```javascript
// Node.js example with large file
const fs = require('fs');
const path = require('path');

// Read a large file and convert to base64
const filePath = path.join(__dirname, 'large-file.zip');
const fileData = fs.readFileSync(filePath);
const fileBase64 = fileData.toString('base64');

// Call the MCP tool - chunking happens automatically
const result = await mcpClient.callTool('attach_task_file', {
  taskId: 'abc123xyz', // ClickUp task ID
  file_name: 'large-file.zip',
  file_data: fileBase64
});

// System will start chunked upload process if file is large
if (result.chunk_session) {
  console.log(`Large file detected, chunked upload started: ${result.progress}%`);
  // The operation will complete automatically
}

console.log(result);
```

## Parameters

### Common Parameters
- `taskId`: ID of the task to attach the file to
- `taskName` + `listName`: Alternative to taskId if you only know the task name
- `file_name`: Name of the file (with extension) - required when using file_data

### Method-Specific Parameters
- `file_data`: Base64-encoded file content for direct uploads
- `file_url`: URL to download the file from
- `auth_header`: Optional authorization header to use with file_url

### Advanced Parameters (rarely needed)
The tool also supports advanced parameters for manual chunk handling in special cases:
- `chunk_session`: Session identifier for chunked uploads
- `chunk_index`: Index of the current chunk
- `chunk_is_last`: Whether this is the final chunk

## Best Practices

1. **Choose the right method**:
   - For files you have locally: Use base64 encoding (file_data parameter)
   - For files already online: Use URL method (file_url parameter)

2. **Error handling**:
   - Implement proper error handling and retries
   - For large files, be prepared to handle chunked upload responses

3. **File size considerations**:
   - Base64 encoding increases size by ~33%
   - Very large files may cause memory issues in client applications
   - Consider streaming approaches for extremely large files

4. **Security considerations**:
   - Validate file types before uploading
   - Don't transmit sensitive files over insecure connections

## Troubleshooting

### Common Issues

1. **"File size exceeds limit"**
   - Check your ClickUp plan's file size limits
   - Very large files may exceed server limits

2. **"Invalid task ID"**
   - Verify the task exists and you have permission to access it

3. **"Unable to download from URL"**
   - Ensure the URL is publicly accessible
   - Check if auth_header is required

For additional assistance, please contact support or file an issue in the repository.
</file>

<file path="docs/workspace-tasks.md">
# get_workspace_tasks

The `get_workspace_tasks` tool provides a powerful way to retrieve tasks across the entire workspace with flexible filtering options, including tag-based filtering. This tool is especially useful for cross-list task organization and reporting.

## Key Features

- **Workspace-Wide Access**: Unlike `get_tasks` which only searches in one list, this tool searches across all spaces, folders, and lists.
- **Tag-Based Filtering**: Find tasks with specific tags anywhere in the workspace.
- **Multiple Filtering Dimensions**: Filter by lists, folders, spaces, statuses, assignees, and more.
- **Date Filtering**: Search by creation date, update date, or due date ranges.
- **Pagination Support**: Handle large result sets efficiently.

## Usage Examples

### Basic Usage

Retrieve all tasks from the workspace:

```
get_workspace_tasks
```

### Tag Filtering

Find all tasks with the "bug" tag:

```
get_workspace_tasks tags=["bug"]
```

Find tasks that have both "bug" and "high-priority" tags:

```
get_workspace_tasks tags=["bug", "high-priority"]
```

### Combining Multiple Filters

Find high-priority bugs assigned to a specific user that are due this month:

```
get_workspace_tasks 
  tags=["bug", "high-priority"] 
  assignees=["12345"] 
  due_date_gt=1680300000000 
  due_date_lt=1682978400000
```

### Filtering by Space and List

Find all tasks in a specific space:

```
get_workspace_tasks space_ids=["space123"]
```

Find tasks in multiple lists:

```
get_workspace_tasks list_ids=["list123", "list456"]
```

### Status and Archive Filtering

Find only open tasks:

```
get_workspace_tasks include_closed=false
```

Include archived tasks:

```
get_workspace_tasks archived=true
```

### Pagination

Get the first page of tasks, sorted by creation date:

```
get_workspace_tasks page=0 order_by="created" reverse=true
```

Get the second page:

```
get_workspace_tasks page=1 order_by="created" reverse=true
```

## Performance Considerations

For large workspaces, it's recommended to:

1. Use specific filters to narrow down results
2. Use pagination to handle large result sets
3. Consider filtering by space or list when possible
4. Be mindful of rate limiting implications

## Related Tools

- `get_tasks`: Retrieves tasks from a specific list
- `get_task`: Gets a single task's details
- `get_space_tags`: Retrieves available tags in a space that can be used for filtering
</file>

<file path="src/services/clickup/folder.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Folder Service
 * 
 * Handles all operations related to folders in ClickUp, including:
 * - Creating folders
 * - Retrieving folders
 * - Updating folders
 * - Deleting folders
 * - Finding folders by name
 */

import { AxiosError } from 'axios';
import { BaseClickUpService, ErrorCode, ClickUpServiceError, ServiceResponse } from './base.js';
import { 
  ClickUpFolder,
  CreateFolderData
} from './types.js';
import { WorkspaceService } from './workspace.js';

export class FolderService extends BaseClickUpService {
  private workspaceService: WorkspaceService | null = null;
  
  /**
   * Creates an instance of FolderService
   * @param apiKey - ClickUp API key
   * @param teamId - ClickUp team ID
   * @param baseUrl - Optional custom API URL
   * @param workspaceService - Optional workspace service for lookups
   */
  constructor(
    apiKey: string,
    teamId: string,
    baseUrl?: string,
    workspaceService?: WorkspaceService
  ) {
    super(apiKey, teamId, baseUrl);
    this.workspaceService = workspaceService || null;
  }

  /**
   * Helper method to handle errors consistently
   * @param error The error that occurred
   * @param message Optional custom error message
   * @returns A ClickUpServiceError
   */
  private handleError(error: any, message?: string): ClickUpServiceError {
    if (error instanceof ClickUpServiceError) {
      return error;
    }
    
    return new ClickUpServiceError(
      message || `Folder service error: ${error.message}`,
      ErrorCode.UNKNOWN,
      error
    );
  }

  /**
   * Create a new folder in a space
   * @param spaceId The ID of the space to create the folder in
   * @param folderData The data for the new folder
   * @returns The created folder
   */
  async createFolder(spaceId: string, folderData: CreateFolderData): Promise<ClickUpFolder> {
    try {
      this.logOperation('createFolder', { spaceId, ...folderData });
      
      const response = await this.client.post<ClickUpFolder>(
        `/space/${spaceId}/folder`,
        folderData
      );
      
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to create folder in space ${spaceId}`);
    }
  }

  /**
   * Get a folder by its ID
   * @param folderId The ID of the folder to retrieve
   * @returns The folder details
   */
  async getFolder(folderId: string): Promise<ClickUpFolder> {
    try {
      this.logOperation('getFolder', { folderId });
      
      const response = await this.client.get<ClickUpFolder>(
        `/folder/${folderId}`
      );
      
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to get folder ${folderId}`);
    }
  }

  /**
   * Update an existing folder
   * @param folderId The ID of the folder to update
   * @param updateData The data to update on the folder
   * @returns The updated folder
   */
  async updateFolder(folderId: string, updateData: Partial<CreateFolderData>): Promise<ClickUpFolder> {
    try {
      this.logOperation('updateFolder', { folderId, ...updateData });
      
      const response = await this.client.put<ClickUpFolder>(
        `/folder/${folderId}`,
        updateData
      );
      
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to update folder ${folderId}`);
    }
  }

  /**
   * Delete a folder
   * @param folderId The ID of the folder to delete
   * @returns Success indicator
   */
  async deleteFolder(folderId: string): Promise<ServiceResponse<void>> {
    try {
      this.logOperation('deleteFolder', { folderId });
      
      await this.client.delete(`/folder/${folderId}`);
      
      return {
        success: true
      };
    } catch (error) {
      throw this.handleError(error, `Failed to delete folder ${folderId}`);
    }
  }

  /**
   * Get all folders in a space
   * @param spaceId The ID of the space to get folders from
   * @returns Array of folders in the space
   */
  async getFoldersInSpace(spaceId: string): Promise<ClickUpFolder[]> {
    this.logOperation('getFoldersInSpace', { spaceId });
    
    try {
      const response = await this.client.get<{ folders: ClickUpFolder[] }>(
        `/space/${spaceId}/folder`
      );
      return response.data.folders;
    } catch (error) {
      throw this.handleError(error, `Failed to get folders in space ${spaceId}`);
    }
  }

  /**
   * Find a folder by its name in a space
   * @param spaceId The ID of the space to search in
   * @param folderName The name of the folder to find
   * @returns The folder if found, otherwise null
   */
  async findFolderByName(spaceId: string, folderName: string): Promise<ClickUpFolder | null> {
    this.logOperation('findFolderByName', { spaceId, folderName });
    
    try {
      const folders = await this.getFoldersInSpace(spaceId);
      const matchingFolder = folders.find(folder => 
        folder.name.toLowerCase() === folderName.toLowerCase()
      );
      
      return matchingFolder || null;
    } catch (error) {
      throw this.handleError(error, `Failed to find folder by name in space ${spaceId}`);
    }
  }
}
</file>

<file path="src/services/clickup/list.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp List Service
 * 
 * Handles all operations related to lists in ClickUp, including:
 * - Creating lists
 * - Retrieving lists
 * - Updating lists
 * - Deleting lists
 * - Finding lists by name
 */

import { AxiosError } from 'axios';
import { BaseClickUpService, ErrorCode, ClickUpServiceError, ServiceResponse } from './base.js';
import { 
  ClickUpList,
  ClickUpTask,
  CreateListData
} from './types.js';
import { WorkspaceService } from './workspace.js';

export class ListService extends BaseClickUpService {
  private workspaceService: WorkspaceService | null = null;
  
  constructor(apiKey: string, teamId: string, baseUrl?: string, workspaceService?: WorkspaceService) {
    super(apiKey, teamId, baseUrl);
    this.workspaceService = workspaceService || null;
  }

  /**
   * Helper method to handle errors consistently
   * @param error The error that occurred
   * @param message Optional custom error message
   * @returns A ClickUpServiceError
   */
  private handleError(error: any, message?: string): ClickUpServiceError {
    if (error instanceof ClickUpServiceError) {
      return error;
    }
    
    return new ClickUpServiceError(
      message || `List service error: ${error.message}`,
      ErrorCode.UNKNOWN,
      error
    );
  }

  /**
   * Create a new list in a space
   * @param spaceId The ID of the space to create the list in
   * @param listData The data for the new list
   * @returns The created list
   */
  async createList(spaceId: string, listData: CreateListData): Promise<ClickUpList> {
    this.logOperation('createList', { spaceId, ...listData });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.post<ClickUpList>(
          `/space/${spaceId}/list`,
          listData
        );
        return response.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to create list in space ${spaceId}`);
    }
  }

  /**
   * Create a new list in a folder
   * @param folderId The ID of the folder to create the list in
   * @param listData The data for the new list
   * @returns The created list
   */
  async createListInFolder(folderId: string, listData: CreateListData): Promise<ClickUpList> {
    this.logOperation('createListInFolder', { folderId, ...listData });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.post<ClickUpList>(
          `/folder/${folderId}/list`,
          listData
        );
        return response.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to create list in folder ${folderId}`);
    }
  }

  /**
   * Get a list by ID
   * @param listId The ID of the list to retrieve
   * @returns The requested list
   */
  async getList(listId: string): Promise<ClickUpList> {
    this.logOperation('getList', { listId });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.get<ClickUpList>(`/list/${listId}`);
        return response.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get list ${listId}`);
    }
  }

  /**
   * Update an existing list
   * @param listId The ID of the list to update
   * @param updateData The data to update on the list
   * @returns The updated list
   */
  async updateList(listId: string, updateData: Partial<CreateListData>): Promise<ClickUpList> {
    this.logOperation('updateList', { listId, ...updateData });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.put<ClickUpList>(
          `/list/${listId}`,
          updateData
        );
        return response.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to update list ${listId}`);
    }
  }

  /**
   * Delete a list
   * @param listId The ID of the list to delete
   * @returns Success indicator
   */
  async deleteList(listId: string): Promise<ServiceResponse<void>> {
    this.logOperation('deleteList', { listId });
    
    try {
      await this.makeRequest(async () => {
        await this.client.delete(`/list/${listId}`);
      });
      
      return {
        success: true
      };
    } catch (error) {
      throw this.handleError(error, `Failed to delete list ${listId}`);
    }
  }

  /**
   * Get all lists in a space
   * @param spaceId The ID of the space to get lists from
   * @returns Array of lists in the space
   */
  async getListsInSpace(spaceId: string): Promise<ClickUpList[]> {
    this.logOperation('getListsInSpace', { spaceId });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.get<{ lists: ClickUpList[] }>(
          `/space/${spaceId}/list`
        );
        return response.data.lists;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get lists in space ${spaceId}`);
    }
  }

  /**
   * Get all lists in a folder
   * @param folderId The ID of the folder to get lists from
   * @returns Array of lists in the folder
   */
  async getListsInFolder(folderId: string): Promise<ClickUpList[]> {
    this.logOperation('getListsInFolder', { folderId });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.get<{ lists: ClickUpList[] }>(
          `/folder/${folderId}/list`
        );
        return response.data.lists;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get lists in folder ${folderId}`);
    }
  }

  /**
   * Find a list by its name in a space
   * @param spaceId The ID of the space to search in
   * @param listName The name of the list to find
   * @returns The list if found, otherwise null
   */
  async findListByNameInSpace(spaceId: string, listName: string): Promise<ClickUpList | null> {
    this.logOperation('findListByNameInSpace', { spaceId, listName });
    
    try {
      const lists = await this.getListsInSpace(spaceId);
      const matchingList = lists.find(list => 
        list.name.toLowerCase() === listName.toLowerCase()
      );
      
      return matchingList || null;
    } catch (error) {
      throw this.handleError(error, `Failed to find list by name in space ${spaceId}`);
    }
  }

  /**
   * Find a list by its name in a folder
   * @param folderId The ID of the folder to search in
   * @param listName The name of the list to find
   * @returns The list if found, otherwise null
   */
  async findListByNameInFolder(folderId: string, listName: string): Promise<ClickUpList | null> {
    this.logOperation('findListByNameInFolder', { folderId, listName });
    
    try {
      const lists = await this.getListsInFolder(folderId);
      const matchingList = lists.find(list => 
        list.name.toLowerCase() === listName.toLowerCase()
      );
      
      return matchingList || null;
    } catch (error) {
      throw this.handleError(error, `Failed to find list by name in folder ${folderId}`);
    }
  }
}
</file>

<file path="src/tools/index.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Tools Index
 * 
 * This file exports all tool definitions and handlers for the ClickUp MCP server.
 * Each tool category (workspace, task, list, folder) is organized into its own module 
 * for better maintainability.
 */

export * from './workspace.js';
export * from './task/index.js';
export * from './list.js';
export * from './folder.js';
export * from './tag.js';
</file>

<file path="src/utils/color-processor.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Color Processor Utility
 * 
 * Processes natural language color commands and converts them to HEX color values.
 * Also generates appropriate foreground (text) colors for optimal contrast.
 */

// Basic color mapping with common color names to their HEX values
const COLOR_MAP: Record<string, string> = {
  // Primary colors
  red: '#FF0000',
  green: '#00FF00',
  blue: '#0000FF',
  
  // Secondary colors
  yellow: '#FFFF00',
  purple: '#800080',
  orange: '#FFA500',
  pink: '#FFC0CB',
  brown: '#A52A2A',
  
  // Neutrals
  black: '#000000',
  white: '#FFFFFF',
  gray: '#808080',
  grey: '#808080',
  
  // Extended colors
  navy: '#000080',
  teal: '#008080',
  olive: '#808000',
  maroon: '#800000',
  aqua: '#00FFFF',
  cyan: '#00FFFF',
  magenta: '#FF00FF',
  fuchsia: '#FF00FF',
  lime: '#00FF00',
  indigo: '#4B0082',
  violet: '#EE82EE',
  gold: '#FFD700',
  silver: '#C0C0C0',
  beige: '#F5F5DC',
  tan: '#D2B48C',
  coral: '#FF7F50',
  crimson: '#DC143C',
  khaki: '#F0E68C',
  lavender: '#E6E6FA',
  plum: '#DDA0DD',
  salmon: '#FA8072',
  turquoise: '#40E0D0',
};

// Extended color variations
const COLOR_VARIATIONS: Record<string, Record<string, string>> = {
  red: {
    light: '#FF6666',
    dark: '#8B0000',
    bright: '#FF0000',
    deep: '#8B0000',
  },
  blue: {
    light: '#ADD8E6',
    dark: '#00008B',
    sky: '#87CEEB',
    navy: '#000080',
    royal: '#4169E1',
    deep: '#00008B',
  },
  green: {
    light: '#90EE90',
    dark: '#006400',
    forest: '#228B22',
    lime: '#32CD32',
    mint: '#98FB98',
    olive: '#808000',
  },
  yellow: {
    light: '#FFFFE0',
    dark: '#BDB76B',
    pale: '#FFF9C4',
    gold: '#FFD700',
    lemon: '#FFFACD',
  },
  // Add more variations for other colors as needed
};

/**
 * Extracts a color name from natural language text
 * @param text - Natural language text that contains a color reference
 * @returns The extracted color name or null if no color is found
 */
export function extractColorFromText(text: string): string | null {
  if (!text) return null;
  
  // Convert to lowercase for case-insensitive matching
  const lowercaseText = text.toLowerCase();
  
  // First check for color variations (e.g., "dark blue", "light green")
  for (const [baseColor, variations] of Object.entries(COLOR_VARIATIONS)) {
    for (const [variation, _] of Object.entries(variations)) {
      const colorPhrase = `${variation} ${baseColor}`;
      if (lowercaseText.includes(colorPhrase)) {
        return colorPhrase;
      }
    }
  }
  
  // Then check for base colors
  for (const color of Object.keys(COLOR_MAP)) {
    // Use word boundary to make sure we're matching whole words
    const regex = new RegExp(`\\b${color}\\b`, 'i');
    if (regex.test(lowercaseText)) {
      return color;
    }
  }
  
  return null;
}

/**
 * Converts a color name to its HEX value
 * @param colorName - Name of the color to convert (e.g., "blue", "dark red")
 * @returns HEX color code or null if color name is not recognized
 */
export function colorNameToHex(colorName: string): string | null {
  if (!colorName) return null;
  
  const lowercaseColor = colorName.toLowerCase();
  
  // Check if it's a color variation (e.g., "dark blue")
  const parts = lowercaseColor.split(' ');
  if (parts.length === 2) {
    const variation = parts[0];
    const baseColor = parts[1];
    
    if (COLOR_VARIATIONS[baseColor] && COLOR_VARIATIONS[baseColor][variation]) {
      return COLOR_VARIATIONS[baseColor][variation];
    }
  }
  
  // Check if it's a base color
  return COLOR_MAP[lowercaseColor] || null;
}

/**
 * Calculates the relative luminance of a color for WCAG contrast calculations
 * @param hex - HEX color code
 * @returns Relative luminance value
 */
function calculateLuminance(hex: string): number {
  // Remove # if present
  const color = hex.startsWith('#') ? hex.slice(1) : hex;
  
  // Convert HEX to RGB
  const r = parseInt(color.substr(0, 2), 16) / 255;
  const g = parseInt(color.substr(2, 2), 16) / 255;
  const b = parseInt(color.substr(4, 2), 16) / 255;
  
  // Calculate luminance using the formula from WCAG 2.0
  const R = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
  const G = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
  const B = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
  
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}

/**
 * Generates a contrasting foreground color for optimal readability
 * @param backgroundColor - HEX code of the background color
 * @returns HEX code of the foreground color (either black or white)
 */
export function generateContrastingForeground(backgroundColor: string): string {
  const luminance = calculateLuminance(backgroundColor);
  
  // Use white text on dark backgrounds and black text on light backgrounds
  // The threshold 0.5 is based on WCAG guidelines for contrast
  return luminance > 0.5 ? '#000000' : '#FFFFFF';
}

/**
 * Processes a natural language command to extract a color and convert it to HEX values
 * @param command - Natural language command (e.g., "Create a blue tag")
 * @returns Object containing background and foreground HEX colors, or null if color not recognized
 */
export function processColorCommand(command: string): { background: string; foreground: string } | null {
  // Extract color name from command
  const colorName = extractColorFromText(command);
  if (!colorName) return null;
  
  // Convert color name to HEX background color
  const backgroundColor = colorNameToHex(colorName);
  if (!backgroundColor) return null;
  
  // Generate appropriate foreground color
  const foregroundColor = generateContrastingForeground(backgroundColor);
  
  return {
    background: backgroundColor,
    foreground: foregroundColor
  };
}
</file>

<file path="src/utils/concurrency-utils.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Concurrency Utilities
 * 
 * This module provides utilities for handling concurrent operations,
 * batch processing, rate limiting, and retry logic.
 */

import { Logger } from '../logger.js';

// Create logger instance for this module
const logger = new Logger('ConcurrencyUtils');

/**
 * Options for batch processing
 */
export interface BatchProcessingOptions {
  /** Maximum items to process in a single batch (default: 10) */
  batchSize?: number;
  /** Maximum concurrent operations (default: 3) */
  concurrency?: number;
  /** Whether to continue processing if some operations fail (default: true) */
  continueOnError?: boolean;
  /** Number of retry attempts for failed operations (default: 3) */
  retryCount?: number;
  /** Base delay between retries in milliseconds (default: 1000) */
  retryDelay?: number;
  /** Whether to use exponential backoff for retries (default: true) */
  exponentialBackoff?: boolean;
  /** Callback for tracking progress */
  progressCallback?: (completed: number, total: number, successes: number, failures: number) => void;
}

/**
 * Results of batch processing
 */
export interface BatchResult<T> {
  /** Array of successful operation results */
  successful: T[];
  /** Array of failed operations with context */
  failed: Array<{ item: any, error: Error, index: number }>;
  /** Summary totals */
  totals: {
    /** Total number of successful operations */
    success: number;
    /** Total number of failed operations */
    failure: number;
    /** Total operations attempted */
    total: number;
  };
}

/**
 * Process a collection of items in batches with configurable concurrency
 * 
 * This utility handles:
 * - Breaking items into manageable batches
 * - Processing multiple items concurrently
 * - Retrying failed operations with backoff
 * - Tracking progress and aggregating results
 * - Graceful error handling
 * 
 * @param items Array of items to process
 * @param processor Function that processes a single item
 * @param options Configuration options for batch processing
 * @returns Results of the processing with success and failure information
 */
export async function processBatch<T, R>(
  items: T[],
  processor: (item: T, index: number) => Promise<R>,
  options?: BatchProcessingOptions
): Promise<BatchResult<R>> {
  // Apply default options
  const opts: Required<BatchProcessingOptions> = {
    batchSize: options?.batchSize ?? 10,
    concurrency: options?.concurrency ?? 3,
    continueOnError: options?.continueOnError ?? true,
    retryCount: options?.retryCount ?? 3,
    retryDelay: options?.retryDelay ?? 1000,
    exponentialBackoff: options?.exponentialBackoff ?? true,
    progressCallback: options?.progressCallback ?? (() => {})
  };

  // Initialize results
  const result: BatchResult<R> = {
    successful: [],
    failed: [],
    totals: {
      success: 0,
      failure: 0,
      total: items.length
    }
  };

  // Handle empty input array
  if (items.length === 0) {
    logger.info('processBatch called with empty items array');
    return result;
  }

  try {
    const totalBatches = Math.ceil(items.length / opts.batchSize);
    let processedItems = 0;

    logger.info(`Starting batch processing of ${items.length} items`, {
      totalBatches,
      batchSize: opts.batchSize,
      concurrency: opts.concurrency
    });

    // Process items in batches
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const startIdx = batchIndex * opts.batchSize;
      const endIdx = Math.min(startIdx + opts.batchSize, items.length);
      const batch = items.slice(startIdx, endIdx);
      
      logger.debug(`Processing batch ${batchIndex + 1}/${totalBatches}`, {
        batchSize: batch.length,
        startIdx,
        endIdx
      });

      // Process the current batch
      const batchResults = await processSingleBatch(
        batch, 
        processor,
        startIdx, 
        opts
      );

      // Aggregate results
      result.successful.push(...batchResults.successful);
      result.failed.push(...batchResults.failed);
      result.totals.success += batchResults.totals.success;
      result.totals.failure += batchResults.totals.failure;

      // Stop processing if an error occurred and continueOnError is false
      if (batchResults.totals.failure > 0 && !opts.continueOnError) {
        logger.warn(`Stopping batch processing due to failure and continueOnError=false`, {
          failedItems: batchResults.totals.failure
        });
        break;
      }

      // Update progress
      processedItems += batch.length;
      opts.progressCallback(
        processedItems, 
        items.length, 
        result.totals.success, 
        result.totals.failure
      );
    }

    logger.info(`Batch processing completed`, {
      totalItems: items.length,
      successful: result.totals.success,
      failed: result.totals.failure
    });

    return result;
  } catch (error: any) {
    logger.error(`Unexpected error in batch processing`, {
      error: error.message || String(error)
    });

    // Add any unprocessed items as failures
    const processedCount = result.totals.success + result.totals.failure;
    if (processedCount < items.length) {
      const remainingItems = items.slice(processedCount);
      for (let i = 0; i < remainingItems.length; i++) {
        const index = processedCount + i;
        result.failed.push({
          item: remainingItems[i],
          error: new Error('Batch processing failed: ' + (error.message || 'Unknown error')),
          index
        });
        result.totals.failure++;
      }
    }

    return result;
  }
}

/**
 * Process a single batch of items with concurrency
 * 
 * @param batch The batch of items to process
 * @param processor The function to process each item
 * @param startIndex The starting index of the batch in the original array
 * @param opts Processing options
 * @returns Results for this batch
 */
async function processSingleBatch<T, R>(
  batch: T[],
  processor: (item: T, index: number) => Promise<R>,
  startIndex: number,
  opts: Required<BatchProcessingOptions>
): Promise<BatchResult<R>> {
  const result: BatchResult<R> = {
    successful: [],
    failed: [],
    totals: {
      success: 0,
      failure: 0,
      total: batch.length
    }
  };

  try {
    // Process items in concurrent chunks
    for (let i = 0; i < batch.length; i += opts.concurrency) {
      const concurrentBatch = batch.slice(i, Math.min(i + opts.concurrency, batch.length));
      
      // Create a promise for each item in the concurrent batch
      const promises = concurrentBatch.map((item, idx) => {
        const index = startIndex + i + idx;
        return processWithRetry(
          () => processor(item, index),
          item,
          index,
          opts
        );
      });

      // Wait for all promises to settle (either resolve or reject)
      const results = await Promise.allSettled(promises);
      
      // Process the results
      results.forEach((promiseResult, idx) => {
        const index = startIndex + i + idx;
        
        if (promiseResult.status === 'fulfilled') {
          // Operation succeeded
          result.successful.push(promiseResult.value);
          result.totals.success++;
        } else {
          // Operation failed
          const error = promiseResult.reason as Error;
          result.failed.push({ 
            item: batch[i + idx], 
            error, 
            index 
          });
          result.totals.failure++;
          
          // If continueOnError is false, stop processing
          if (!opts.continueOnError) {
            throw new Error(`Operation failed at index ${index}: ${error.message || String(error)}`);
          }
        }
      });
    }
    
    return result;
  } catch (error) {
    logger.error(`Error in batch processing`, {
      batchSize: batch.length,
      startIndex,
      error: error instanceof Error ? error.message : String(error)
    });
    
    // If we've hit an error that stopped the whole batch (continueOnError=false),
    // we need to record any unprocessed items as failures
    const processedCount = result.totals.success + result.totals.failure;
    
    if (processedCount < batch.length) {
      const remainingItems = batch.slice(processedCount);
      for (let i = 0; i < remainingItems.length; i++) {
        const index = startIndex + processedCount + i;
        result.failed.push({
          item: remainingItems[i],
          error: new Error('Batch processing aborted: ' + 
            (error instanceof Error ? error.message : String(error))),
          index
        });
        result.totals.failure++;
      }
    }
    
    return result;
  }
}

/**
 * Process a single item with retry logic
 * 
 * @param operation The operation to perform
 * @param item The item being processed (for context)
 * @param index The index of the item (for logging)
 * @param options Processing options
 * @returns The result of the operation if successful
 * @throws Error if all retry attempts fail
 */
async function processWithRetry<R>(
  operation: () => Promise<R>,
  item: any,
  index: number,
  options: Required<BatchProcessingOptions>
): Promise<R> {
  let attempts = 0;
  let lastError: Error | null = null;

  while (attempts <= options.retryCount) {
    try {
      // Attempt the operation
      attempts++;
      return await operation();
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      lastError = err;
      
      logger.warn(`Operation failed for item at index ${index}`, {
        attempt: attempts,
        maxAttempts: options.retryCount + 1,
        error: err.message
      });
      
      // If this was our last attempt, don't delay, just throw
      if (attempts > options.retryCount) {
        break;
      }
      
      // Calculate delay for next retry
      let delay = options.retryDelay;
      if (options.exponentialBackoff) {
        // Use exponential backoff with jitter
        delay = options.retryDelay * Math.pow(2, attempts - 1) + Math.random() * 1000;
      }
      
      logger.debug(`Retrying operation after delay`, {
        index,
        attempt: attempts,
        delayMs: delay
      });
      
      // Wait before next attempt
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  // If we get here, all retry attempts failed
  throw new Error(
    `Operation failed after ${attempts} attempts for item at index ${index}: ` +
    (lastError?.message || 'Unknown error')
  );
}
</file>

<file path="src/utils/token-utils.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Token Utilities
 * 
 * Functions for estimating token counts for LLM processing
 */

/**
 * Simple heuristic to estimate token count from text
 * Based on the approximate ratio of 4 characters per token for English text
 * 
 * @param text Text to estimate tokens for
 * @returns Estimated token count
 */
export function estimateTokensFromText(text: string): number {
  if (!text) return 0;
  
  // Characters per token varies by language, but ~4 chars per token
  // is a reasonable approximation for English text
  const CHARS_PER_TOKEN = 4;
  
  // Add some overhead for non-text elements and special tokens
  const OVERHEAD_FACTOR = 1.1;
  
  return Math.ceil((text.length / CHARS_PER_TOKEN) * OVERHEAD_FACTOR);
}

/**
 * Estimate tokens for a JSON object
 * 
 * @param obj Object to estimate tokens for
 * @returns Estimated token count
 */
export function estimateTokensFromObject(obj: any): number {
  // Convert to JSON string
  const jsonString = JSON.stringify(obj);
  
  // Use text estimation on the JSON string
  // JSON has more special chars than plain text, so we adjust overhead
  return Math.ceil(estimateTokensFromText(jsonString) * 1.2);
}

/**
 * Check if an object would exceed the token limit when serialized to JSON
 * 
 * @param obj Object to check
 * @param tokenLimit Token limit to check against
 * @returns Whether the object would exceed the token limit
 */
export function wouldExceedTokenLimit(obj: any, tokenLimit: number): boolean {
  const estimatedTokens = estimateTokensFromObject(obj);
  return estimatedTokens > tokenLimit;
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
yarn.lock

# Build output
build/
dist/
out/

# Environment variables
.env
.env.*
.env.local
.env.development
.env.production

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDE and editor files
.idea/
.vscode/
*.swp
*.swo
.DS_Store
Thumbs.db

# Cursor specific
.cursor
.cursorrules
.cursorignore
.specstory
checklist.md

# Temporary files
.tmp/
.temp/
</file>

<file path=".npmignore">
# Source
src/
.env
.env.example

# Development configs
.git/
.github/
.gitignore
.npmrc
tsconfig.json
.vscode/
.idea/

# Logs
*.log
npm-debug.log*

# Dependencies
node_modules/

# Misc
.DS_Store
*.swp
*.swo

# Cursor specific
.cursor
.cursorrules
.cursorignore
.specstory
checklist.md

# Temporary files
.tmp/
.temp/
</file>

<file path="CODE_OF_CONDUCT.md">
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement by Talib Kareem at
taazkareem@icloud.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.
</file>

<file path="CONTRIBUTING.md">
# Contributing to ClickUp MCP Server

Thank you for your interest in contributing to the ClickUp MCP Server project! This guide will help you get started with contributing.

## Code of Conduct

By participating in this project, you agree to abide by our Code of Conduct. Please be respectful and constructive in all interactions.

## Getting Started

1. Fork the repository
2. Clone your fork locally
3. Install dependencies with `npm install`
4. Create a new branch for your feature/fix
5. Make your changes
6. Build the project with `npm run build`
7. Test your changes thoroughly
8. Commit your changes with clear, descriptive messages
9. Push to your fork
10. Submit a Pull Request

## Pull Request Process

1. Update the README.md with details of changes if applicable
2. Update the version number following [Semantic Versioning](https://semver.org/)
3. Ensure all tests pass and code meets quality standards
4. Your PR will be reviewed by maintainers
5. Once approved, your PR will be merged

## Coding Standards

- Use TypeScript for all new code
- Follow existing code style and formatting
- Write clear, descriptive commit messages
- Include comments for complex logic
- Add appropriate error handling
- Keep functions focused and modular
- Write tests for new features

## Adding New Features

1. First open an issue describing the feature
2. Discuss implementation approach with maintainers
3. Follow the PR process above
4. Update documentation as needed

## Reporting Bugs

- Use the GitHub issue tracker
- Include detailed steps to reproduce
- Provide system/environment details
- Include relevant logs/screenshots
- Label the issue appropriately

## Questions or Need Help?

- Open a GitHub Discussion
- Email the maintainer: taazkareem@icloud.com

## License

By contributing, you agree that your contributions will be licensed under the MIT License.
</file>

<file path="Dockerfile">
# Generated by https://smithery.ai. See: https://smithery.ai/docs/config#dockerfile
# Use a Node.js base image
FROM node:18-alpine AS builder

# Set the working directory
WORKDIR /app

# Copy package files
COPY package.json package-lock.json ./

# Copy the source files and tsconfig BEFORE npm install
COPY src ./src
COPY tsconfig.json ./

# Install dependencies
RUN npm install

# Compile TypeScript to JavaScript
RUN npm run build

# Use a smaller image for the runtime
FROM node:18-alpine AS runtime

# Set the working directory
WORKDIR /app

# Copy the build output and node_modules from the builder stage
COPY --from=builder /app/build ./build
COPY --from=builder /app/node_modules ./node_modules

# Copy the entrypoint script if necessary
COPY --from=builder /app/package.json ./

# Expose the desired port (if the server binds to a port)
EXPOSE 8080

# Define the command to run the application
CMD ["node", "build/index.js"]
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Talib Kareem

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="SECURITY.md">
# Security Policy

## Supported Versions

We currently provide security updates for the following versions of ClickUp MCP Server:

| Version | Supported          |
| ------- | ------------------ |
| 0.5.x   | :white_check_mark: |
| < 0.5.0 | :x:                |

## Reporting a Vulnerability

We take the security of the ClickUp MCP Server seriously, especially since it handles API keys and sensitive task data. If you discover a security vulnerability, please follow these steps:

1. **Do NOT disclose the vulnerability publicly** until it has been addressed by the maintainers.
2. Send details of the vulnerability to the project maintainer directly at [create a private security report](https://github.com/TaazKareem/clickup-mcp-server/security/advisories/new).
3. Include as much information as possible, such as:
   - A clear description of the vulnerability
   - Steps to reproduce the issue
   - Potential impact of the vulnerability
   - Suggested fix if you have one

## Response Time

- You will receive an initial response to your report within 48 hours.
- We will keep you updated on our progress in addressing the vulnerability.
- Once the vulnerability is fixed, we may ask you to verify the solution.

## Security Best Practices

When using ClickUp MCP Server, please follow these security best practices:

1. **Never commit your ClickUp API keys to version control**. Always use environment variables or secure configuration management.
2. Keep your npm dependencies up to date.
3. Run the server in an isolated environment when possible.
4. Regularly check for updates to the ClickUp MCP Server to ensure you have the latest security patches.

## Policy Updates

This security policy may be updated from time to time. Please check back regularly for any changes.

## Acknowledgments

We appreciate the responsible disclosure of security vulnerabilities and will acknowledge your contribution once the issue is resolved, unless you prefer to remain anonymous.
</file>

<file path="smithery.yaml">
# Smithery configuration file: https://smithery.ai/docs/config#smitheryyaml

dockerfile: Dockerfile

startCommand:
  type: stdio
  configSchema:
    # JSON Schema defining the configuration options for the MCP.
    type: object
    required:
      - clickupApiKey
      - clickupTeamId
    properties:
      clickupApiKey:
        type: string
        description: Your ClickUp API key.
      clickupTeamId:
        type: string
        description: Your ClickUp Team ID.
  commandFunction:
    # A function that produces the CLI command to start the MCP on stdio.
    |-
    (config) => ({ command: 'node', args: ['build/index.js'], env: { CLICKUP_API_KEY: config.clickupApiKey, CLICKUP_TEAM_ID: config.clickupTeamId } })
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "build",
    "rootDir": "./src",
    "strict": false,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noImplicitAny": false
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/services/clickup/task/task-custom-fields.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Custom Fields Module
 * 
 * Handles custom fields operations for ClickUp tasks, including:
 * - Setting custom field values
 * - Retrieving custom field values
 */

import { TaskServiceTags } from './task-tags.js';
import { ErrorCode } from '../base.js';

/**
 * Interface for custom field value
 */
export interface CustomFieldValue {
  id: string;
  value: any;
}

/**
 * Custom fields functionality for the TaskService
 */
export class TaskServiceCustomFields extends TaskServiceTags {
  /**
   * Set a single custom field value on a task
   * 
   * @param taskId ID of the task
   * @param fieldId ID of the custom field
   * @param value Value to set for the custom field
   * @returns Success response
   */
  async setCustomFieldValue(taskId: string, fieldId: string, value: any): Promise<boolean> {
    this.logOperation('setCustomFieldValue', { taskId, fieldId, value });
    
    try {
      const payload = {
        value
      };
      
      await this.client.post(
        `/task/${taskId}/field/${fieldId}`,
        payload
      );
      
      return true;
    } catch (error) {
      throw this.handleError(error, `Failed to set custom field "${fieldId}" value`);
    }
  }

  /**
   * Set multiple custom field values on a task
   * 
   * @param taskId ID of the task
   * @param customFields Array of custom field ID and value pairs
   * @returns Success response
   */
  async setCustomFieldValues(taskId: string, customFields: CustomFieldValue[]): Promise<boolean> {
    this.logOperation('setCustomFieldValues', { taskId, customFields });
    
    try {
      // Execute each update sequentially
      for (const field of customFields) {
        await this.setCustomFieldValue(taskId, field.id, field.value);
      }
      
      return true;
    } catch (error) {
      throw this.handleError(error, 'Failed to set custom field values');
    }
  }

  /**
   * Get all custom field values for a task
   * 
   * @param taskId ID of the task
   * @returns Record mapping field IDs to their values
   */
  async getCustomFieldValues(taskId: string): Promise<Record<string, any>> {
    this.logOperation('getCustomFieldValues', { taskId });
    
    try {
      // We need to fetch the full task to get its custom fields
      const task = await this.getTask(taskId);
      return task.custom_fields || {};
    } catch (error) {
      throw this.handleError(error, 'Failed to get custom field values');
    }
  }

  /**
   * Get a specific custom field value for a task
   * 
   * @param taskId ID of the task
   * @param fieldId ID of the custom field
   * @returns The value of the custom field
   * @throws ClickUpServiceError if the field doesn't exist
   */
  async getCustomFieldValue(taskId: string, fieldId: string): Promise<any> {
    this.logOperation('getCustomFieldValue', { taskId, fieldId });
    
    try {
      const customFields = await this.getCustomFieldValues(taskId);
      
      if (fieldId in customFields) {
        return customFields[fieldId];
      } else {
        throw this.handleError(
          new Error(`Custom field "${fieldId}" not found on task`), 
          `Custom field "${fieldId}" not found on task`
        );
      }
    } catch (error) {
      throw this.handleError(error, `Failed to get custom field "${fieldId}" value`);
    }
  }
}
</file>

<file path="src/services/clickup/task/task-service.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service
 * 
 * Main entry point for the ClickUp Task Service.
 * Combines all task-related functionality through inheritance:
 * - Core operations (CRUD)
 * - Search capabilities
 * - File attachments
 * - Comments
 * - Tags
 * - Custom fields
 */

import { TaskServiceCustomFields } from './task-custom-fields.js';
import { WorkspaceService } from '../workspace.js';

/**
 * Complete TaskService combining all task-related functionality
 */
export class TaskService extends TaskServiceCustomFields {
  constructor(
    apiKey: string,
    teamId: string,
    baseUrl?: string,
    workspaceService?: WorkspaceService
  ) {
    super(apiKey, teamId, baseUrl, workspaceService);
    this.logOperation('constructor', { initialized: true });
  }
}
</file>

<file path="src/services/clickup/task/task-tags.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Tags Module
 * 
 * Handles tag operations for ClickUp tasks, including:
 * - Adding tags to a task
 * - Removing tags from a task
 */

import { TaskServiceComments } from './task-comments.js';
import { ClickUpTag } from '../types.js';

/**
 * Tags functionality for the TaskService
 */
export class TaskServiceTags extends TaskServiceComments {
  /**
   * Add a tag to a task
   * 
   * @param taskId ID of the task
   * @param tagName Name of the tag to add
   * @returns Success response
   */
  async addTagToTask(taskId: string, tagName: string): Promise<boolean> {
    this.logOperation('addTagToTask', { taskId, tagName });
    
    try {
      const payload = {
        tag_name: tagName,
      };
      
      await this.client.post(
        `/task/${taskId}/tag/${encodeURIComponent(tagName)}`,
        payload
      );
      
      return true;
    } catch (error) {
      throw this.handleError(error, `Failed to add tag "${tagName}" to task`);
    }
  }

  /**
   * Remove a tag from a task
   * 
   * @param taskId ID of the task
   * @param tagName Name of the tag to remove
   * @returns Success response
   */
  async removeTagFromTask(taskId: string, tagName: string): Promise<boolean> {
    this.logOperation('removeTagFromTask', { taskId, tagName });
    
    try {
      await this.client.delete(
        `/task/${taskId}/tag/${encodeURIComponent(tagName)}`
      );
      
      return true;
    } catch (error) {
      throw this.handleError(error, `Failed to remove tag "${tagName}" from task`);
    }
  }

  /**
   * Get all tags for a task
   * 
   * @param taskId ID of the task
   * @returns Array of task tags
   */
  async getTaskTags(taskId: string): Promise<ClickUpTag[]> {
    this.logOperation('getTaskTags', { taskId });
    
    try {
      // We need to fetch the full task to get its tags
      const task = await this.getTask(taskId);
      return task.tags || [];
    } catch (error) {
      throw this.handleError(error, 'Failed to get task tags');
    }
  }

  /**
   * Update all tags for a task (replaces existing tags)
   * 
   * @param taskId ID of the task
   * @param tagNames Array of tag names to set
   * @returns Success response
   */
  async updateTaskTags(taskId: string, tagNames: string[]): Promise<boolean> {
    this.logOperation('updateTaskTags', { taskId, tagNames });
    
    try {
      // First get existing tags
      const existingTags = await this.getTaskTags(taskId);
      const existingTagNames = existingTags.map(tag => tag.name);
      
      // Remove tags that shouldn't be there
      for (const tagName of existingTagNames) {
        if (!tagNames.includes(tagName)) {
          await this.removeTagFromTask(taskId, tagName);
        }
      }
      
      // Add new tags
      for (const tagName of tagNames) {
        if (!existingTagNames.includes(tagName)) {
          await this.addTagToTask(taskId, tagName);
        }
      }
      
      return true;
    } catch (error) {
      throw this.handleError(error, 'Failed to update task tags');
    }
  }
}
</file>

<file path="src/services/clickup/document.ts">
/**
 * SPDX-FileCopyrightText: © 2025 João Santana <joaosantana@gmail.com>
 * SPDX-License-Identifier: MIT
 *
 * Document service for ClickUp
 * 
 * This service provides methods to manage ClickUp documents:
 * - Create documents
 * - Get document details
 * - List documents in a container
 * - List document pages
 * - Get document pages content
 * - Update document pages
 */

import { BaseClickUpService, ClickUpServiceError, ErrorCode } from './base.js';
import { 
  ClickUpDocument, 
  CreateDocumentData,
  ListDocumentsOptions,
  ClickUpDocumentResponse,
  DocumentPageListingOptions,
  DocumentPagesOptions,
  DocumentPagesResponse,
  CreateDocumentPageData,
  UpdateDocumentPageData,
  ClickUpDocumentPage
} from './types.js';

export class DocumentService extends BaseClickUpService {
  constructor(
    apiKey: string,
    teamId: string,
    baseUrl?: string
  ) {
    // Override baseUrl to use v3 API, since Docs are only available in v3
    super(apiKey, teamId, baseUrl || 'https://api.clickup.com/api/v3');
  }

  /**
   * Helper method to handle errors consistently
   * @param error The error that occurred
   * @param message Optional custom error message
   * @returns A ClickUpServiceError
   */
  private handleError(error: any, message?: string): ClickUpServiceError {
    if (error instanceof ClickUpServiceError) {
      return error;
    }
    return new ClickUpServiceError(
      message || `Document service error: ${error.message}`,
      ErrorCode.UNKNOWN,
      error
    );
  }

  /**
   * Creates a new document in a space, folder, or list
   * @param data - Document data with parent object structured as {id: string, type: number}
   * @returns Created document
   */
  async createDocument(data: CreateDocumentData): Promise<ClickUpDocument> {
    try {
      // Log the request data for debugging
      this.logOperation('Creating document with data:', { data });
      const response = await this.client.post(`/workspaces/${this.teamId}/docs`, {
        name: data.name,
        parent: data.parent,
        visibility: data.visibility || 'PRIVATE',
        create_page: data.create_page !== undefined ? data.create_page : true
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error, 'Failed to create document');
    }
  }

  /**
   * Creates a new page in a document
   * @param documentId - ID of the document to create the page in
   * @param data - Page data
   * @returns Created page
   */
  async createPage(documentId: string, data: CreateDocumentPageData): Promise<ClickUpDocumentPage> {
    try {
      this.logOperation('Creating page in document with data:', { documentId, data });
      const response = await this.client.post(
        `/workspaces/${this.teamId}/docs/${documentId}/pages`,
        data
      );
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to create page in document ${documentId}`);
    }
  }

  /**
   * Gets a document by ID
   * @param documentId - ID of the document to retrieve
   * @returns Document details
   */
  async getDocument(documentId: string): Promise<ClickUpDocument> {
    try {
      this.logOperation('Getting document with ID:', { documentId });
      const response = await this.client.get(`/workspaces/${this.teamId}/docs/${documentId}`);
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to get document ${documentId}`);
    }
  }

  /**
   * Lists documents in the workspace with optional filters
   * @param options - Search and filter options
   * @returns List of documents
   */
  async listDocuments(options: ListDocumentsOptions = {}): Promise<ClickUpDocumentResponse> {
    try {
      this.logOperation('Listing documents with options:', { options });
      const response = await this.client.get(`/workspaces/${this.teamId}/docs`, {
        params: options
      });
      return response.data;
    } catch (error) {
      throw this.handleError(error, 'Failed to list documents');
    }
  }

  /**
   * Lists all pages in a document with optional depth control
   * @param documentId - ID of the document
   * @param options - Options for page listing
   * @returns List of document pages
   */
  async listDocumentPages(documentId: string, options: DocumentPageListingOptions = {}): Promise<DocumentPagesResponse> {
    try {
      this.logOperation('Listing pages for document with ID:', { documentId, options });
      const response = await this.client.get(
        `/workspaces/${this.teamId}/docs/${documentId}/pageListing`,
        { params: options }
      );
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to list pages for document ${documentId}`);
    }
  }

  /**
   * Gets the content of specific pages in a document
   * @param documentId - ID of the document
   * @param pageIds - Array of page IDs to retrieve
   * @param options - Options for retrieving pages content
   * @returns Document pages with content
   */
  async getDocumentPages(documentId: string, pageIds: string[], options: Partial<DocumentPagesOptions> = {}): Promise<DocumentPagesResponse> {
    try {
      // Get pages in parallel
      this.logOperation('Getting pages for document with ID:', { documentId, pageIds, options });
      const pagePromises = pageIds.map(pageId => 
        this.client.get(
          `/workspaces/${this.teamId}/docs/${documentId}/pages/${pageId}`,
          { params: { ...options, pageIds } }
        )
      );
      const responses = await Promise.all(pagePromises);
      const pages = responses.map(response => response.data);
      return { pages };
    } catch (error) {
      throw this.handleError(error, `Failed to get pages for document ${documentId}`);
    }
  }

  /**
   * Updates an existing page in a document
   * @param documentId - ID of the document containing the page
   * @param pageId - ID of the page to update
   * @param data - Updated page data
   * @returns Updated page
   */
  async updatePage(documentId: string, pageId: string, data: UpdateDocumentPageData): Promise<ClickUpDocumentPage> {
    try {
      this.logOperation('Updating page in document with ID:', { documentId, pageId, data });
      const response = await this.client.put(
        `/workspaces/${this.teamId}/docs/${documentId}/pages/${pageId}`,
        {
          ...data,
          content_format: data.content_format || 'text/md',
          content_edit_mode: data.content_edit_mode || 'append'
        }
      );
      return response.data;
    } catch (error) {
      throw this.handleError(error, `Failed to update page ${pageId} in document ${documentId}`);
    }
  }
}
</file>

<file path="src/services/clickup/tag.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Tag Service
 * 
 * Provides access to ClickUp API endpoints for tag management:
 * - Space tags (get, create, update, delete)
 * - Task tags (add, remove)
 */

import { BaseClickUpService, ServiceResponse } from './base.js';
import { ClickUpTag, CreateSpaceTagData, SpaceTagsResponse, UpdateSpaceTagData } from './types.js';

/**
 * ClickUp Tag Service class for managing tags
 */
export class ClickUpTagService extends BaseClickUpService {
  /**
   * Get all tags in a space
   * @param spaceId - ID of the space to get tags from
   * @returns Promise with tags array
   */
  async getSpaceTags(spaceId: string): Promise<ServiceResponse<ClickUpTag[]>> {
    try {
      this.logger.debug(`Getting tags for space: ${spaceId}`);
      
      const response = await this.client.get<SpaceTagsResponse>(`/space/${spaceId}/tag`);
      
      return {
        success: true,
        data: response.data.tags
      };
    } catch (error) {
      this.logger.error(`Failed to get tags for space: ${spaceId}`, error);
      return {
        success: false,
        error: {
          message: error.message || 'Failed to get space tags',
          code: error.code,
          details: error.data
        }
      };
    }
  }

  /**
   * Create a new tag in a space
   * @param spaceId - ID of the space
   * @param tagData - Tag data (name, background color, foreground color)
   * @returns Promise with created tag
   */
  async createSpaceTag(
    spaceId: string, 
    tagData: CreateSpaceTagData
  ): Promise<ServiceResponse<ClickUpTag>> {
    try {
      this.logger.debug(`Creating tag "${tagData.tag_name}" in space: ${spaceId}`);
      
      // Send tag data wrapped in a 'tag' object
      const response = await this.client.post<{ tag: ClickUpTag }>(
        `/space/${spaceId}/tag`,
        {
          tag: {
            name: tagData.tag_name,
            tag_bg: tagData.tag_bg,
            tag_fg: tagData.tag_fg
          }
        }
      );
      
      return {
        success: true,
        data: response.data.tag
      };
    } catch (error) {
      this.logger.error(`Failed to create tag in space: ${spaceId}`, error);
      return {
        success: false,
        error: {
          message: error.message || 'Failed to create space tag',
          code: error.code,
          details: error.data
        }
      };
    }
  }

  /**
   * Update an existing tag in a space
   * @param spaceId - ID of the space
   * @param tagName - Current name of the tag to update
   * @param updateData - Tag data to update (name, colors)
   * @returns Promise with updated tag
   */
  async updateSpaceTag(
    spaceId: string,
    tagName: string,
    updateData: UpdateSpaceTagData
  ): Promise<ServiceResponse<ClickUpTag>> {
    try {
      this.logger.debug(`Updating tag "${tagName}" in space: ${spaceId}`);
      
      // Encode the tag name in the URL
      const encodedTagName = encodeURIComponent(tagName);
      
      const response = await this.client.put<{ tag: ClickUpTag }>(
        `/space/${spaceId}/tag/${encodedTagName}`,
        updateData
      );
      
      return {
        success: true,
        data: response.data.tag
      };
    } catch (error) {
      this.logger.error(`Failed to update tag "${tagName}" in space: ${spaceId}`, error);
      return {
        success: false,
        error: {
          message: error.message || 'Failed to update space tag',
          code: error.code,
          details: error.data
        }
      };
    }
  }

  /**
   * Delete a tag from a space
   * @param spaceId - ID of the space
   * @param tagName - Name of the tag to delete
   * @returns Promise with success status
   */
  async deleteSpaceTag(
    spaceId: string,
    tagName: string
  ): Promise<ServiceResponse<void>> {
    try {
      this.logger.debug(`Deleting tag "${tagName}" from space: ${spaceId}`);
      
      // Encode the tag name in the URL
      const encodedTagName = encodeURIComponent(tagName);
      
      await this.client.delete(`/space/${spaceId}/tag/${encodedTagName}`);
      
      return {
        success: true
      };
    } catch (error) {
      this.logger.error(`Failed to delete tag "${tagName}" from space: ${spaceId}`, error);
      return {
        success: false,
        error: {
          message: error.message || 'Failed to delete space tag',
          code: error.code,
          details: error.data
        }
      };
    }
  }

  /**
   * Add a tag to a task
   * @param taskId - ID of the task
   * @param tagName - Name of the tag to add
   * @returns Promise with success status and tag data
   */
  async addTagToTask(
    taskId: string,
    tagName: string
  ): Promise<ServiceResponse<{ tagAdded: boolean }>> {
    try {
      this.logger.debug(`Adding tag "${tagName}" to task: ${taskId}`);
      
      // First get the task to get its space ID
      const taskResponse = await this.client.get<any>(`/task/${taskId}`);
      if (!taskResponse.data?.space?.id) {
        return {
          success: false,
          error: {
            message: 'Could not determine space ID from task',
            code: 'SPACE_NOT_FOUND'
          }
        };
      }

      // Get space tags to verify tag exists
      const spaceId = taskResponse.data.space.id;
      const spaceTags = await this.getSpaceTags(spaceId);
      
      if (!spaceTags.success || !spaceTags.data) {
        return {
          success: false,
          error: {
            message: 'Failed to verify tag existence in space',
            code: 'TAG_VERIFICATION_FAILED',
            details: spaceTags.error
          }
        };
      }

      // Check if tag exists
      const tagExists = spaceTags.data.some(tag => tag.name === tagName);
      if (!tagExists) {
        return {
          success: false,
          error: {
            message: `Tag "${tagName}" does not exist in the space`,
            code: 'TAG_NOT_FOUND'
          }
        };
      }

      // Encode the tag name in the URL
      const encodedTagName = encodeURIComponent(tagName);
      
      // Add the tag
      await this.client.post(`/task/${taskId}/tag/${encodedTagName}`, {});
      
      // Verify the tag was added by getting the task again
      const verifyResponse = await this.client.get<any>(`/task/${taskId}`);
      const tagAdded = verifyResponse.data?.tags?.some(tag => tag.name === tagName) ?? false;

      if (!tagAdded) {
        return {
          success: false,
          error: {
            message: 'Tag addition failed verification',
            code: 'TAG_VERIFICATION_FAILED'
          }
        };
      }
      
      return {
        success: true,
        data: { tagAdded: true }
      };
    } catch (error) {
      this.logger.error(`Failed to add tag "${tagName}" to task: ${taskId}`, error);
      return {
        success: false,
        error: {
          message: error.message || 'Failed to add tag to task',
          code: error.code,
          details: error.data
        }
      };
    }
  }

  /**
   * Remove a tag from a task
   * @param taskId - ID of the task
   * @param tagName - Name of the tag to remove
   * @returns Promise with success status
   */
  async removeTagFromTask(
    taskId: string,
    tagName: string
  ): Promise<ServiceResponse<void>> {
    try {
      this.logger.debug(`Removing tag "${tagName}" from task: ${taskId}`);
      
      // Encode the tag name in the URL
      const encodedTagName = encodeURIComponent(tagName);
      
      await this.client.delete(`/task/${taskId}/tag/${encodedTagName}`);
      
      return {
        success: true
      };
    } catch (error) {
      this.logger.error(`Failed to remove tag "${tagName}" from task: ${taskId}`, error);
      return {
        success: false,
        error: {
          message: error.message || 'Failed to remove tag from task',
          code: error.code,
          details: error.data
        }
      };
    }
  }
}
</file>

<file path="src/services/clickup/time.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Time tracking service for ClickUp tasks
 * 
 * This service provides methods to manage time tracking for ClickUp tasks:
 * - Get time entries for a task
 * - Start time tracking on a task
 * - Stop time tracking on a task
 * - Add a manual time entry
 * - Delete a time entry
 */

import { BaseClickUpService, ServiceResponse, ErrorCode, ClickUpServiceError } from './base.js';

// Local type definition instead of importing from axios
interface AxiosResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: Record<string, string>;
  config: any;
  request?: any;
}

/**
 * Time entry object as returned by the ClickUp API
 */
export interface ClickUpTimeEntry {
  id: string;
  task: {
    id: string;
    name: string;
    status: {
      status: string;
      color: string;
      type: string;
      orderindex: number;
    };
    custom_id?: string;
  };
  wid: string;
  user: {
    id: number;
    username: string;
    email: string;
    color: string;
    profilePicture: string | null;
  };
  billable: boolean;
  start: string; // ISO date string
  end: string | null; // ISO date string, null if timer is running
  duration: number; // Duration in milliseconds
  description: string;
  tags: string[];
  source: string;
  at: string; // ISO date string when the entry was created
  task_location: {
    list_id: string;
    folder_id: string;
    space_id: string;
    list_name: string;
    folder_name: string;
    space_name: string;
  };
}

/**
 * Response for listing time entries
 */
export interface TimeEntriesResponse {
  data: ClickUpTimeEntry[];
}

/**
 * Data for starting time tracking
 */
export interface StartTimeTrackingData {
  tid: string; // Task ID
  description?: string;
  billable?: boolean;
  tags?: string[];
}

/**
 * Data for stopping time tracking
 */
export interface StopTimeTrackingData {
  description?: string;
  tags?: string[];
}

/**
 * Data for adding a manual time entry
 */
export interface AddTimeEntryData {
  tid: string; // Task ID
  start: number; // Unix timestamp in milliseconds
  duration: number; // Duration in milliseconds
  description?: string;
  billable?: boolean;
  tags?: string[];
}

/**
 * Time tracking service for ClickUp
 */
export class TimeTrackingService extends BaseClickUpService {
  /**
   * Get all time entries for a task
   * @param taskId ID of the task
   * @param startDate Optional start date filter (Unix timestamp in milliseconds)
   * @param endDate Optional end date filter (Unix timestamp in milliseconds)
   * @returns List of time entries
   */
  async getTimeEntries(taskId: string, startDate?: number, endDate?: number): Promise<ServiceResponse<ClickUpTimeEntry[]>> {
    try {
      this.logOperation('getTimeEntries', { taskId, startDate, endDate });
      
      // Build query parameters
      let query: Record<string, any> = {};
      if (startDate) query.start_date = startDate;
      if (endDate) query.end_date = endDate;
      
      const path = `/task/${taskId}/time`;
      this.traceRequest('GET', path, query);
      
      const response = await this.makeRequest<AxiosResponse<TimeEntriesResponse>>(() =>
        this.client.get(path, {
          params: query
        })
      );
      
      return {
        success: true,
        data: response.data.data
      };
    } catch (error) {
      if (error instanceof ClickUpServiceError) {
        return {
          success: false,
          error: {
            message: error.message,
            code: error.code,
            details: error.data
          }
        };
      }
      
      return {
        success: false,
        error: {
          message: `Failed to get time entries: ${(error as Error).message}`,
          code: ErrorCode.UNKNOWN
        }
      };
    }
  }
  
  /**
   * Start time tracking on a task
   * @param data Task ID and optional parameters
   * @returns The created time entry
   */
  async startTimeTracking(data: StartTimeTrackingData): Promise<ServiceResponse<ClickUpTimeEntry>> {
    try {
      this.logOperation('startTimeTracking', { taskId: data.tid });
      
      const path = `/team/${this.teamId}/time_entries/start`;
      this.traceRequest('POST', path, data);
      
      const response = await this.makeRequest<AxiosResponse<{ data: ClickUpTimeEntry }>>(() =>
        this.client.post(path, data)
      );
      
      return {
        success: true,
        data: response.data.data
      };
    } catch (error) {
      if (error instanceof ClickUpServiceError) {
        return {
          success: false,
          error: {
            message: error.message,
            code: error.code,
            details: error.data
          }
        };
      }
      
      return {
        success: false,
        error: {
          message: `Failed to start time tracking: ${(error as Error).message}`,
          code: ErrorCode.UNKNOWN
        }
      };
    }
  }
  
  /**
   * Stop the currently running time tracker
   * @param data Optional parameters for the stopped time entry
   * @returns The completed time entry
   */
  async stopTimeTracking(data?: StopTimeTrackingData): Promise<ServiceResponse<ClickUpTimeEntry>> {
    try {
      this.logOperation('stopTimeTracking', {});
      
      const path = `/team/${this.teamId}/time_entries/stop`;
      this.traceRequest('POST', path, data || {});
      
      const response = await this.makeRequest<AxiosResponse<{ data: ClickUpTimeEntry }>>(() =>
        this.client.post(path, data || {})
      );
      
      return {
        success: true,
        data: response.data.data
      };
    } catch (error) {
      if (error instanceof ClickUpServiceError) {
        return {
          success: false,
          error: {
            message: error.message,
            code: error.code,
            details: error.data
          }
        };
      }
      
      return {
        success: false,
        error: {
          message: `Failed to stop time tracking: ${(error as Error).message}`,
          code: ErrorCode.UNKNOWN
        }
      };
    }
  }
  
  /**
   * Add a manual time entry to a task
   * @param data Time entry data including task ID, start time, and duration
   * @returns The created time entry
   */
  async addTimeEntry(data: AddTimeEntryData): Promise<ServiceResponse<ClickUpTimeEntry>> {
    try {
      this.logOperation('addTimeEntry', { taskId: data.tid, duration: data.duration });
      
      const path = `/team/${this.teamId}/time_entries`;
      this.traceRequest('POST', path, data);
      
      const response = await this.makeRequest<AxiosResponse<{ data: ClickUpTimeEntry }>>(() =>
        this.client.post(path, data)
      );
      
      return {
        success: true,
        data: response.data.data
      };
    } catch (error) {
      if (error instanceof ClickUpServiceError) {
        return {
          success: false,
          error: {
            message: error.message,
            code: error.code,
            details: error.data
          }
        };
      }
      
      return {
        success: false,
        error: {
          message: `Failed to add time entry: ${(error as Error).message}`,
          code: ErrorCode.UNKNOWN
        }
      };
    }
  }
  
  /**
   * Delete a time entry
   * @param timeEntryId ID of the time entry to delete
   * @returns Success response
   */
  async deleteTimeEntry(timeEntryId: string): Promise<ServiceResponse<boolean>> {
    try {
      this.logOperation('deleteTimeEntry', { timeEntryId });
      
      const path = `/team/${this.teamId}/time_entries/${timeEntryId}`;
      this.traceRequest('DELETE', path);
      
      await this.makeRequest<AxiosResponse<any>>(() =>
        this.client.delete(path)
      );
      
      return {
        success: true,
        data: true
      };
    } catch (error) {
      if (error instanceof ClickUpServiceError) {
        return {
          success: false,
          error: {
            message: error.message,
            code: error.code,
            details: error.data
          }
        };
      }
      
      return {
        success: false,
        error: {
          message: `Failed to delete time entry: ${(error as Error).message}`,
          code: ErrorCode.UNKNOWN
        }
      };
    }
  }
  
  /**
   * Get currently running time entry for the user
   * @returns The currently running time entry or null if no timer is running
   */
  async getCurrentTimeEntry(): Promise<ServiceResponse<ClickUpTimeEntry | null>> {
    try {
      this.logOperation('getCurrentTimeEntry', {});
      
      const path = `/team/${this.teamId}/time_entries/current`;
      this.traceRequest('GET', path);
      
      const response = await this.makeRequest<AxiosResponse<{ data: ClickUpTimeEntry | null }>>(() =>
        this.client.get(path)
      );
      
      return {
        success: true,
        data: response.data.data
      };
    } catch (error) {
      if (error instanceof ClickUpServiceError) {
        return {
          success: false,
          error: {
            message: error.message,
            code: error.code,
            details: error.data
          }
        };
      }
      
      return {
        success: false,
        error: {
          message: `Failed to get current time entry: ${(error as Error).message}`,
          code: ErrorCode.UNKNOWN
        }
      };
    }
  }
}
</file>

<file path="src/tools/task/attachments.types.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Task Attachment Types
 * 
 * This module defines types for file attachment operations.
 */

import { ClickUpTaskAttachment } from '../../services/clickup/types.js';

/**
 * Session data for chunked file uploads
 */
export interface ChunkSession {
  taskId: string;
  fileName: string;
  fileSize: number;
  chunks: Map<number, Buffer>;
  timestamp: number;
}

/**
 * Response for successful task attachment
 */
export interface TaskAttachmentResponse {
  success: boolean;
  message: string;
  attachment: ClickUpTaskAttachment | null;
}

/**
 * Response for chunked upload initialization
 */
export interface ChunkedUploadInitResponse {
  success: boolean;
  message: string;
  chunk_session: string;
  chunks_total: number;
  chunk_uploaded: number;
  attachment: null;
  details: {
    taskId: string;
    fileName: string;
    fileSize: number;
    chunkCount: number;
    progress: number;
  };
}

/**
 * Response for chunked upload progress
 */
export interface ChunkedUploadProgressResponse {
  success: boolean;
  message: string;
  chunk_session: string;
  chunks_remaining: number;
  details: {
    taskId: string;
    fileName: string;
    chunksReceived: number;
    progress: number;
  };
}
</file>

<file path="src/tools/task/time-tracking.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Task time tracking tools
 * 
 * This module provides tools for time tracking operations on ClickUp tasks:
 * - Get time entries for a task
 * - Start time tracking on a task
 * - Stop time tracking
 * - Add a manual time entry
 * - Delete a time entry
 */

import { timeTrackingService } from "../../services/shared.js";
import { getTaskId } from "./utilities.js";
import { Logger } from "../../logger.js";
import { ErrorCode } from "../../services/clickup/base.js";
import { formatDueDate, parseDueDate } from "../../utils/date-utils.js";

// Logger instance
const logger = new Logger('TimeTrackingTools');

/**
 * Tool definition for getting time entries
 */
export const getTaskTimeEntriesTool = {
  name: "get_task_time_entries",
  description: "Gets all time entries for a task with filtering options. Use taskId (preferred) or taskName + optional listName. Returns all tracked time with user info, descriptions, tags, start/end times, and durations.",
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to get time entries for. Works with both regular task IDs and custom IDs."
      },
      taskName: {
        type: "string",
        description: "Name of the task to get time entries for. When using this parameter, it's recommended to also provide listName."
      },
      listName: {
        type: "string",
        description: "Name of the list containing the task. Helps find the right task when using taskName."
      },
      startDate: {
        type: "string",
        description: "Optional start date filter. Supports Unix timestamps (in milliseconds) and natural language expressions like 'yesterday', 'last week', etc."
      },
      endDate: {
        type: "string",
        description: "Optional end date filter. Supports Unix timestamps (in milliseconds) and natural language expressions."
      }
    }
  }
};

/**
 * Tool definition for starting time tracking
 */
export const startTimeTrackingTool = {
  name: "start_time_tracking",
  description: "Starts time tracking on a task. Use taskId (preferred) or taskName + optional listName. Optional fields: description, billable status, and tags. Only one timer can be running at a time.",
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to start tracking time on. Works with both regular task IDs and custom IDs."
      },
      taskName: {
        type: "string",
        description: "Name of the task to start tracking time on. When using this parameter, it's recommended to also provide listName."
      },
      listName: {
        type: "string",
        description: "Name of the list containing the task. Helps find the right task when using taskName."
      },
      description: {
        type: "string",
        description: "Optional description for the time entry."
      },
      billable: {
        type: "boolean",
        description: "Whether this time is billable. Default is workspace setting."
      },
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Optional array of tag names to assign to the time entry."
      }
    }
  }
};

/**
 * Tool definition for stopping time tracking
 */
export const stopTimeTrackingTool = {
  name: "stop_time_tracking",
  description: "Stops the currently running time tracker. Optional fields: description and tags. Returns the completed time entry details.",
  inputSchema: {
    type: "object",
    properties: {
      description: {
        type: "string",
        description: "Optional description to update or add to the time entry."
      },
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Optional array of tag names to assign to the time entry."
      }
    }
  }
};

/**
 * Tool definition for adding a manual time entry
 */
export const addTimeEntryTool = {
  name: "add_time_entry",
  description: "Adds a manual time entry to a task. Use taskId (preferred) or taskName + optional listName. Required: start time, duration. Optional: description, billable, tags.",
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to add time entry to. Works with both regular task IDs and custom IDs."
      },
      taskName: {
        type: "string",
        description: "Name of the task to add time entry to. When using this parameter, it's recommended to also provide listName."
      },
      listName: {
        type: "string",
        description: "Name of the list containing the task. Helps find the right task when using taskName."
      },
      start: {
        type: "string",
        description: "Start time for the entry. Supports Unix timestamps (in milliseconds) and natural language expressions like '2 hours ago', 'yesterday 9am', etc."
      },
      duration: {
        type: "string",
        description: "Duration of the time entry. Format as 'Xh Ym' (e.g., '1h 30m') or just minutes (e.g., '90m')."
      },
      description: {
        type: "string",
        description: "Optional description for the time entry."
      },
      billable: {
        type: "boolean",
        description: "Whether this time is billable. Default is workspace setting."
      },
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Optional array of tag names to assign to the time entry."
      }
    },
    required: ["start", "duration"]
  }
};

/**
 * Tool definition for deleting a time entry
 */
export const deleteTimeEntryTool = {
  name: "delete_time_entry",
  description: "Deletes a time entry. Required: time entry ID.",
  inputSchema: {
    type: "object",
    properties: {
      timeEntryId: {
        type: "string",
        description: "ID of the time entry to delete."
      }
    },
    required: ["timeEntryId"]
  }
};

/**
 * Tool definition for getting current time entry
 */
export const getCurrentTimeEntryTool = {
  name: "get_current_time_entry",
  description: "Gets the currently running time entry, if any. No parameters needed.",
  inputSchema: {
    type: "object",
    properties: {}
  }
};

/**
 * Handle get task time entries tool
 */
export async function handleGetTaskTimeEntries(params: any) {
  logger.info("Handling request to get task time entries", params);
  
  try {
    // Resolve task ID
    const taskId = await getTaskId(params.taskId, params.taskName, params.listName);
    if (!taskId) {
      return {
        success: false,
        error: {
          message: "Task not found. Please provide a valid taskId or taskName + listName combination."
        }
      };
    }
    
    // Parse date filters
    let startDate: number | undefined;
    let endDate: number | undefined;
    
    if (params.startDate) {
      startDate = parseDueDate(params.startDate);
    }
    
    if (params.endDate) {
      endDate = parseDueDate(params.endDate);
    }
    
    // Get time entries
    const result = await timeTrackingService.getTimeEntries(taskId, startDate, endDate);
    
    if (!result.success) {
      return {
        success: false,
        error: {
          message: result.error?.message || "Failed to get time entries"
        }
      };
    }
    
    const timeEntries = result.data || [];
    
    // Format the response
    return {
      success: true,
      time_entries: timeEntries.map(entry => ({
        id: entry.id,
        description: entry.description,
        start: entry.start,
        end: entry.end,
        duration: formatDuration(entry.duration),
        duration_ms: entry.duration,
        billable: entry.billable,
        tags: entry.tags,
        user: {
          id: entry.user.id,
          username: entry.user.username
        },
        task: {
          id: entry.task.id,
          name: entry.task.name,
          status: entry.task.status.status
        }
      }))
    };
  } catch (error) {
    logger.error("Error getting task time entries", error);
    return {
      success: false,
      error: {
        message: (error as Error).message || "An unknown error occurred"
      }
    };
  }
}

/**
 * Handle start time tracking tool
 */
export async function handleStartTimeTracking(params: any) {
  logger.info("Handling request to start time tracking", params);
  
  try {
    // Resolve task ID
    const taskId = await getTaskId(params.taskId, params.taskName, params.listName);
    if (!taskId) {
      return {
        success: false,
        error: {
          message: "Task not found. Please provide a valid taskId or taskName + listName combination."
        }
      };
    }
    
    // Check for currently running timer
    const currentTimerResult = await timeTrackingService.getCurrentTimeEntry();
    if (currentTimerResult.success && currentTimerResult.data) {
      return {
        success: false,
        error: {
          message: "A timer is already running. Please stop the current timer before starting a new one.",
          timer: {
            id: currentTimerResult.data.id,
            task: {
              id: currentTimerResult.data.task.id,
              name: currentTimerResult.data.task.name
            },
            start: currentTimerResult.data.start,
            description: currentTimerResult.data.description
          }
        }
      };
    }
    
    // Prepare request data
    const requestData = {
      tid: taskId,
      description: params.description,
      billable: params.billable,
      tags: params.tags
    };
    
    // Start time tracking
    const result = await timeTrackingService.startTimeTracking(requestData);
    
    if (!result.success) {
      return {
        success: false,
        error: {
          message: result.error?.message || "Failed to start time tracking"
        }
      };
    }
    
    const timeEntry = result.data;
    if (!timeEntry) {
      return {
        success: false,
        error: {
          message: "No time entry data returned from API"
        }
      };
    }
    
    // Format the response
    return {
      success: true,
      time_entry: {
        id: timeEntry.id,
        description: timeEntry.description,
        start: timeEntry.start,
        end: timeEntry.end,
        task: {
          id: timeEntry.task.id,
          name: timeEntry.task.name
        },
        billable: timeEntry.billable,
        tags: timeEntry.tags
      }
    };
  } catch (error) {
    logger.error("Error starting time tracking", error);
    return {
      success: false,
      error: {
        message: (error as Error).message || "An unknown error occurred"
      }
    };
  }
}

/**
 * Handle stop time tracking tool
 */
export async function handleStopTimeTracking(params: any) {
  logger.info("Handling request to stop time tracking", params);
  
  try {
    // Check for currently running timer
    const currentTimerResult = await timeTrackingService.getCurrentTimeEntry();
    if (currentTimerResult.success && !currentTimerResult.data) {
      return {
        success: false,
        error: {
          message: "No timer is currently running. Start a timer before trying to stop it."
        }
      };
    }
    
    // Prepare request data
    const requestData = {
      description: params.description,
      tags: params.tags
    };
    
    // Stop time tracking
    const result = await timeTrackingService.stopTimeTracking(requestData);
    
    if (!result.success) {
      return {
        success: false,
        error: {
          message: result.error?.message || "Failed to stop time tracking"
        }
      };
    }
    
    const timeEntry = result.data;
    if (!timeEntry) {
      return {
        success: false,
        error: {
          message: "No time entry data returned from API"
        }
      };
    }
    
    // Format the response
    return {
      success: true,
      time_entry: {
        id: timeEntry.id,
        description: timeEntry.description,
        start: timeEntry.start,
        end: timeEntry.end,
        duration: formatDuration(timeEntry.duration),
        duration_ms: timeEntry.duration,
        task: {
          id: timeEntry.task.id,
          name: timeEntry.task.name
        },
        billable: timeEntry.billable,
        tags: timeEntry.tags
      }
    };
  } catch (error) {
    logger.error("Error stopping time tracking", error);
    return {
      success: false,
      error: {
        message: (error as Error).message || "An unknown error occurred"
      }
    };
  }
}

/**
 * Handle add time entry tool
 */
export async function handleAddTimeEntry(params: any) {
  logger.info("Handling request to add time entry", params);
  
  try {
    // Resolve task ID
    const taskId = await getTaskId(params.taskId, params.taskName, params.listName);
    if (!taskId) {
      return {
        success: false,
        error: {
          message: "Task not found. Please provide a valid taskId or taskName + listName combination."
        }
      };
    }
    
    // Parse start time
    const startTime = parseDueDate(params.start);
    if (!startTime) {
      return {
        success: false,
        error: {
          message: "Invalid start time format. Use a Unix timestamp (in milliseconds) or a natural language date string."
        }
      };
    }
    
    // Parse duration
    const durationMs = parseDuration(params.duration);
    if (durationMs === 0) {
      return {
        success: false,
        error: {
          message: "Invalid duration format. Use 'Xh Ym' format (e.g., '1h 30m') or just minutes (e.g., '90m')."
        }
      };
    }
    
    // Prepare request data
    const requestData = {
      tid: taskId,
      start: startTime,
      duration: durationMs,
      description: params.description,
      billable: params.billable,
      tags: params.tags
    };
    
    // Add time entry
    const result = await timeTrackingService.addTimeEntry(requestData);
    
    if (!result.success) {
      return {
        success: false,
        error: {
          message: result.error?.message || "Failed to add time entry"
        }
      };
    }
    
    const timeEntry = result.data;
    if (!timeEntry) {
      return {
        success: false,
        error: {
          message: "No time entry data returned from API"
        }
      };
    }
    
    // Format the response
    return {
      success: true,
      time_entry: {
        id: timeEntry.id,
        description: timeEntry.description,
        start: timeEntry.start,
        end: timeEntry.end,
        duration: formatDuration(timeEntry.duration),
        duration_ms: timeEntry.duration,
        task: {
          id: timeEntry.task.id,
          name: timeEntry.task.name
        },
        billable: timeEntry.billable,
        tags: timeEntry.tags
      }
    };
  } catch (error) {
    logger.error("Error adding time entry", error);
    return {
      success: false,
      error: {
        message: (error as Error).message || "An unknown error occurred"
      }
    };
  }
}

/**
 * Handle delete time entry tool
 */
export async function handleDeleteTimeEntry(params: any) {
  logger.info("Handling request to delete time entry", params);
  
  try {
    const { timeEntryId } = params;
    
    if (!timeEntryId) {
      return {
        success: false,
        error: {
          message: "Time entry ID is required."
        }
      };
    }
    
    // Delete time entry
    const result = await timeTrackingService.deleteTimeEntry(timeEntryId);
    
    if (!result.success) {
      return {
        success: false,
        error: {
          message: result.error?.message || "Failed to delete time entry"
        }
      };
    }
    
    // Format the response
    return {
      success: true,
      message: "Time entry deleted successfully."
    };
  } catch (error) {
    logger.error("Error deleting time entry", error);
    return {
      success: false,
      error: {
        message: (error as Error).message || "An unknown error occurred"
      }
    };
  }
}

/**
 * Handle get current time entry tool
 */
export async function handleGetCurrentTimeEntry(params: any) {
  logger.info("Handling request to get current time entry");
  
  try {
    // Get current time entry
    const result = await timeTrackingService.getCurrentTimeEntry();
    
    if (!result.success) {
      return {
        success: false,
        error: {
          message: result.error?.message || "Failed to get current time entry"
        }
      };
    }
    
    const timeEntry = result.data;
    
    // If no timer is running
    if (!timeEntry) {
      return {
        success: true,
        timer_running: false,
        message: "No timer is currently running."
      };
    }
    
    // Format the response
    const elapsedTime = calculateElapsedTime(timeEntry.start);
    
    return {
      success: true,
      timer_running: true,
      time_entry: {
        id: timeEntry.id,
        description: timeEntry.description,
        start: timeEntry.start,
        elapsed: formatDuration(elapsedTime),
        elapsed_ms: elapsedTime,
        task: {
          id: timeEntry.task.id,
          name: timeEntry.task.name
        },
        billable: timeEntry.billable,
        tags: timeEntry.tags
      }
    };
  } catch (error) {
    logger.error("Error getting current time entry", error);
    return {
      success: false,
      error: {
        message: (error as Error).message || "An unknown error occurred"
      }
    };
  }
}

/**
 * Calculate elapsed time in milliseconds from a start time string to now
 */
function calculateElapsedTime(startTimeString: string): number {
  const startTime = new Date(startTimeString).getTime();
  const now = Date.now();
  return Math.max(0, now - startTime);
}

/**
 * Format duration in milliseconds to a human-readable string
 */
function formatDuration(durationMs: number): string {
  if (!durationMs) return "0m";
  
  const seconds = Math.floor(durationMs / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const remainingMinutes = minutes % 60;
  
  if (hours === 0) {
    return `${remainingMinutes}m`;
  } else if (remainingMinutes === 0) {
    return `${hours}h`;
  } else {
    return `${hours}h ${remainingMinutes}m`;
  }
}

/**
 * Parse duration string to milliseconds
 */
function parseDuration(durationString: string): number {
  if (!durationString) return 0;
  
  // Clean the input and handle potential space issues
  const cleanDuration = durationString.trim().toLowerCase().replace(/\s+/g, ' ');
  
  // Handle simple minute format like "90m"
  if (/^\d+m$/.test(cleanDuration)) {
    const minutes = parseInt(cleanDuration.replace('m', ''), 10);
    return minutes * 60 * 1000;
  }
  
  // Handle simple hour format like "2h"
  if (/^\d+h$/.test(cleanDuration)) {
    const hours = parseInt(cleanDuration.replace('h', ''), 10);
    return hours * 60 * 60 * 1000;
  }
  
  // Handle combined format like "1h 30m"
  const combinedPattern = /^(\d+)h\s*(?:(\d+)m)?$|^(?:(\d+)h\s*)?(\d+)m$/;
  const match = cleanDuration.match(combinedPattern);
  
  if (match) {
    const hours = parseInt(match[1] || match[3] || '0', 10);
    const minutes = parseInt(match[2] || match[4] || '0', 10);
    return (hours * 60 * 60 + minutes * 60) * 1000;
  }
  
  // Try to parse as just a number of minutes
  const justMinutes = parseInt(cleanDuration, 10);
  if (!isNaN(justMinutes)) {
    return justMinutes * 60 * 1000;
  }
  
  return 0;
}

// Export all time tracking tools
export const timeTrackingTools = [
  getTaskTimeEntriesTool,
  startTimeTrackingTool,
  stopTimeTrackingTool,
  addTimeEntryTool,
  deleteTimeEntryTool,
  getCurrentTimeEntryTool
];

// Export all time tracking handlers
export const timeTrackingHandlers = {
  get_task_time_entries: handleGetTaskTimeEntries,
  start_time_tracking: handleStartTimeTracking,
  stop_time_tracking: handleStopTimeTracking,
  add_time_entry: handleAddTimeEntry,
  delete_time_entry: handleDeleteTimeEntry,
  get_current_time_entry: handleGetCurrentTimeEntry
};
</file>

<file path="src/tools/utils.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Utility functions for ClickUp MCP tools
 * 
 * Re-exports specialized utilities from dedicated modules.
 */

import { Logger } from '../logger.js';
import { clickUpServices } from '../services/shared.js';

// Re-export date utilities
export { 
  getRelativeTimestamp,
  parseDueDate,
  formatDueDate,
  formatRelativeTime
} from '../utils/date-utils.js';

// Re-export resolver utilities
export {
  resolveListId
} from '../utils/resolver-utils.js';
</file>

<file path="src/tools/workspace.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Workspace Tools
 * 
 * This module defines workspace-related tools like retrieving workspace hierarchy.
 * It handles the workspace tool definitions and the implementation of their handlers.
 */

import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { WorkspaceTree, WorkspaceNode } from '../services/clickup/types.js';
import { Logger } from '../logger.js';
import { sponsorService } from '../utils/sponsor-service.js';
import { clickUpServices } from '../services/shared.js';

// Create a logger for workspace tools
const logger = new Logger('WorkspaceTool');

// Use the workspace service from the shared services
const { workspace: workspaceService } = clickUpServices;

/**
 * Tool definition for retrieving the complete workspace hierarchy
 */
export const workspaceHierarchyTool: Tool = {
  name: 'get_workspace_hierarchy',
  description: `Gets complete workspace hierarchy (spaces, folders, lists). No parameters needed. Returns tree structure with names and IDs for navigation.`,
  inputSchema: {
    type: 'object',
    properties: {}
  }
};

/**
 * Handler for the get_workspace_hierarchy tool
 */
export async function handleGetWorkspaceHierarchy() {
  try {
    // Get workspace hierarchy from the workspace service
    const hierarchy = await workspaceService.getWorkspaceHierarchy();
    
    // Generate tree representation
    const treeOutput = formatTreeOutput(hierarchy);
    
    // Use sponsor service to create the response with optional sponsor message
    return sponsorService.createResponse({ hierarchy: treeOutput }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Error getting workspace hierarchy: ${error.message}`);
  }
}

/**
 * Format the hierarchy as a tree string
 */
function formatTreeOutput(hierarchy: WorkspaceTree): string {
  // Helper function to format a node and its children as a tree
  const formatNodeAsTree = (node: WorkspaceNode | WorkspaceTree['root'], level: number = 0, isLast: boolean = true, parentPrefix: string = ''): string[] => {
    const lines: string[] = [];
    
    // Calculate the current line's prefix
    const currentPrefix = level === 0 ? '' : parentPrefix + (isLast ? '└── ' : '├── ');
    
    // Format current node with descriptive ID type
    const idType = 'type' in node ? `${node.type.charAt(0).toUpperCase() + node.type.slice(1)} ID` : 'Workspace ID';
    lines.push(`${currentPrefix}${node.name} (${idType}: ${node.id})`);
    
    // Calculate the prefix for children
    const childPrefix = level === 0 ? '' : parentPrefix + (isLast ? '    ' : '│   ');
    
    // Process children
    const children = node.children || [];
    children.forEach((child, index) => {
      const childLines = formatNodeAsTree(
        child,
        level + 1,
        index === children.length - 1,
        childPrefix
      );
      lines.push(...childLines);
    });
    
    return lines;
  };

  // Generate tree representation
  const treeLines = formatNodeAsTree(hierarchy.root);
  
  // Return plain text instead of adding code block markers
  return treeLines.join('\n');
}
</file>

<file path="mcp_test_plan_outline.md">
# ClickUp MCP Server Test Plan Outline

## 🎯 Objective
Create a comprehensive test plan to evaluate all tools in the ClickUp MCP Server. The test plan should simulate real user interactions by using diverse, natural language prompts that reflect practical usage scenarios. Each test case must include a method of verification.

## 🛠️ Identified Tools (31 Total)

The following tools have been identified for testing:

**Workspace:**
1.  `get_workspace_hierarchy`

**Task (Single Operations):**
2.  `create_task`
3.  `update_task`
4.  `move_task`
5.  `duplicate_task`
6.  `get_task`
7.  `get_tasks` (from a specific list)
8.  `get_task_comments`
9.  `create_task_comment`
10. `delete_task`

**Task (Bulk Operations):**
11. `create_bulk_tasks`
12. `update_bulk_tasks`
13. `move_bulk_tasks`
14. `delete_bulk_tasks`

**Task (Workspace Operations):**
15. `get_workspace_tasks` (from entire workspace)

**Task (Attachments):**
16. `attach_task_file`

**List:**
17. `create_list` (in space)
18. `create_list_in_folder`
19. `get_list`
20. `update_list`
21. `delete_list`

**Folder:**
22. `create_folder`
23. `get_folder`
24. `update_folder`
25. `delete_folder`

**Tag:**
26. `get_space_tags`
27. `create_space_tag`
28. `update_space_tag`
29. `delete_space_tag`
30. `add_tag_to_task`
31. `remove_tag_from_task`

## 📝 Test Case Generation Approach

1.  **Iterate Through Tools:** Systematically address each of the 31 identified tools.
2.  **Generate Test Cases:** For each tool, create test cases following the specified Markdown format:
    *   **Tool Name:** `<name of the tool>`
    *   **Objective:** Briefly explain the tool's purpose.
    *   **Prompts:** Develop 3–5 diverse, natural language prompts simulating real user requests. These will cover:
        *   *Typical Usage:* Standard, expected ways a user would invoke the tool.
        *   *Variations:* Using different optional parameters or identification methods (e.g., `listName` vs. `listId`).
        *   *Semantic Errors:* Scenarios like referencing non-existent items (e.g., deleting a task that doesn't exist, adding a non-existent tag), permission issues (if applicable), or logical contradictions. Focus will be on these rather than basic syntactic errors (which the MCP framework likely handles).
    *   **Expected Behavior:** Describe the anticipated outcome – successful creation/modification/deletion, data retrieval, or specific error messages for invalid semantic requests.
    *   **Verification Method:** Define how to confirm the outcome, primarily using:
        *   Other MCP tools (e.g., `get_task` after `create_task`).
        *   Checking the structure and content of the returned JSON data.
        *   Verifying absence after destructive actions (e.g., using `get_task` after `delete_task`).
3.  **Structure:** The final deliverable will be a single Markdown document containing the detailed test cases for all tools.
</file>

<file path="mcp_test_plan.md">
# ClickUp MCP Server Test Plan

## 🎯 Objective
This test plan evaluates all tools in the ClickUp MCP Server through diverse, natural language prompts simulating practical usage scenarios. Each test case includes verification methods.

## 📋 Test Data Preparation
Before executing the tests, you must generate the necessary test data in your ClickUp workspace:

1. **Create Test Spaces, Folders, and Lists**:
   - Create at least one space in each category (e.g., Development, Marketing, Design, QA)
   - Create folders within these spaces
   - Create lists within spaces and folders

2. **Create Test Tasks**:
   - Add several tasks with various properties (priorities, due dates, descriptions)
   - Create tasks with comments
   - Add tags to some tasks

3. **Update Test Plan with Actual IDs**:
   - Replace all placeholder IDs (e.g., "123456789") with actual IDs from your workspace
   - Update all task names, list names, folder names, and space names to match your actual data
   - Make sure all referenced entities actually exist in your workspace before testing

## 🧪 Test Cases

### Workspace

#### Tool Name: `get_workspace_hierarchy`
- **Objective:** Retrieve the complete workspace hierarchy including spaces, folders, and lists.
- **Prompts:**
  1. "Show me the entire workspace structure"
  2. "Get my ClickUp workspace hierarchy"
  3. "What spaces, folders and lists do I have in my workspace?"
- **Expected Behavior:** Returns a structured JSON with all spaces, folders, and lists with their respective IDs.
- **Verification Method:** Check that the returned data includes spaces with folders and lists in a hierarchical structure.

### Task (Single Operations)

#### Tool Name: `create_task`
- **Objective:** Create a single task in a specified list.
- **Prompts:**
  1. "Create a task called '🚀 Implement login feature' in the Development list"
  2. "Add a new task to the Marketing list with the name '📊 Review Q2 analytics' due next Friday"
  3. "Create a high priority task in the Design list called '🎨 Update homepage mockups' with the description 'Focus on mobile responsiveness'"
  4. "Add a bug task in the QA list using the listId '123456789' with custom fields for browser and severity"
  5. "Create a subtask under task 123456789 named '📝 Update documentation'"
- **Expected Behavior:** Successfully creates task with specified parameters and returns the created task data including ID.
- **Verification Method:** Use `get_task` with the returned ID to verify all properties were set correctly.

#### Tool Name: `get_task`
- **Objective:** Retrieve detailed information about a specific task.
- **Prompts:**
  1. "Show me details for task 123456789"
  2. "Get information about the task named 'Website redesign'"
  3. "Find task 987654321 in the Development list"
  4. "Show details of task 123456789 including all subtasks"
  5. "What's the status of the task called 'Quarterly report'?"
- **Expected Behavior:** Returns comprehensive task data including name, status, description, due date, etc.
- **Verification Method:** Verify that all expected task fields are present in the response, including custom fields.

#### Tool Name: `update_task`
- **Objective:** Modify properties of an existing task.
- **Prompts:**
  1. "Change the status of task 123456789 to 'In Progress'"
  2. "Update the due date for 'Website migration' to next Monday"
  3. "Add a markdown description to task 123456789 with '## Meeting Notes\n- Discussed key features\n- Set Q3 goals'"
  4. "Set the priority of task 'Bug fix' to urgent"
  5. "Rename task 987654321 to '🔄 Refactor authentication service'"
- **Expected Behavior:** Updates the specified task fields and returns the updated task.
- **Verification Method:** Use `get_task` to verify the changes were applied correctly.

#### Tool Name: `move_task`
- **Objective:** Move a task from one list to another.
- **Prompts:**
  1. "Move task 123456789 to the QA list"
  2. "Transfer 'Homepage redesign' task from Design to Development list"
  3. "Move task 123456789 to list 987654321"
  4. "Shift the 'Security audit' task to the 'Urgent' list"
- **Expected Behavior:** Relocates the task to the specified list and returns confirmation.
- **Verification Method:** Use `get_task` to verify the task's listId has changed to the target list.

#### Tool Name: `duplicate_task`
- **Objective:** Create a copy of an existing task.
- **Prompts:**
  1. "Duplicate task 123456789"
  2. "Make a copy of 'Quarterly review' in the same list"
  3. "Clone task 123456789 to the 'Campaign Ideas' list"
  4. "Create a duplicate of task 123456789 in list 987654321"
- **Expected Behavior:** Creates a new task with identical properties to the original and returns the new task data.
- **Verification Method:** Compare the duplicated task with the original using `get_task` to ensure properties match.

#### Tool Name: `delete_task`
- **Objective:** Permanently remove a task.
- **Prompts:**
  1. "Delete task 123456789"
  2. "Remove the 'Outdated feature' task from the Development list"
  3. "Permanently delete task 123456789"
  4. "Delete the task named 'Old campaign' if it exists"
  5. "Remove a non-existent task 999999999"
- **Expected Behavior:** Successfully deletes the task if it exists and returns confirmation. For non-existent tasks, returns appropriate error.
- **Verification Method:** Use `get_task` to confirm the task no longer exists.

#### Tool Name: `get_tasks`
- **Objective:** Retrieve all tasks from a specific list.
- **Prompts:**
  1. "Show all tasks in the Development list"
  2. "Get tasks from list 123456789"
  3. "Retrieve all items in the 'Backlog' list"
  4. "Show incomplete tasks in the 'Current Sprint' list"
  5. "Find all tasks in a non-existent list"
- **Expected Behavior:** Returns an array of tasks from the specified list with their details.
- **Verification Method:** Check that the returned data structure contains tasks with the expected fields and proper list association.

#### Tool Name: `get_task_comments`
- **Objective:** Retrieve comments associated with a specific task.
- **Prompts:**
  1. "Show comments for task 123456789"
  2. "Get all comment history on 'Website redesign' task"
  3. "Retrieve the latest comments from task 123456789"
  4. "Show communication thread on task 987654321"
  5. "Get comments for a task that has no comments"
- **Expected Behavior:** Returns an array of comments with author, content, and timestamp details.
- **Verification Method:** Verify the structure of returned comments and confirm they belong to the specified task.

#### Tool Name: `create_task_comment`
- **Objective:** Add a comment to a specific task.
- **Prompts:**
  1. "Add comment 'Fixed the bug in login flow' to task 123456789"
  2. "Comment on 'Website redesign' task: 'Client approved the mockups'"
  3. "Post update 'Meeting scheduled for Thursday 2pm' on task 123456789"
  4. "Add feedback to task 123456789: 'Please review the latest changes'"
  5. "Comment on a non-existent task 999999999"
- **Expected Behavior:** Successfully adds the comment to the task and returns the created comment data.
- **Verification Method:** Use `get_task_comments` to verify the comment was added correctly.

### Task (Bulk Operations)

#### Tool Name: `create_bulk_tasks`
- **Objective:** Create multiple tasks in a single list simultaneously.
- **Prompts:**
  1. "Create 3 tasks in the Development list: '🚀 Setup API', '🔒 Implement authentication', and '📱 Build mobile view'"
  2. "Add multiple tasks to the Marketing list: '📊 Create analytics report' due next Monday, '📧 Draft email campaign' due Wednesday, and '🎨 Design social media assets'"
  3. "Bulk create 5 bug tasks in the QA list with high priority"
  4. "Create several tasks in list 123456789 with custom fields for each"
  5. "Add tasks to a non-existent list"
- **Expected Behavior:** Creates all specified tasks in the target list and returns data for all created tasks.
- **Verification Method:** Use `get_tasks` to verify all tasks were created with correct properties.

#### Tool Name: `update_bulk_tasks`
- **Objective:** Modify properties of multiple tasks simultaneously.
- **Prompts:**
  1. "Change status to 'In Progress' for tasks 123456789, 234567890, and 345678901"
  2. "Update priority to high for all tasks in the 'Current Sprint' list"
  3. "Set due date to next Friday for tasks 123456789, 234567890, and 345678901"
  4. "Add the tag 'needs-review' to 5 specific tasks in the QA list"
  5. "Change assignee for multiple tasks including some that don't exist"
- **Expected Behavior:** Updates all specified tasks with the desired properties and returns data for the updated tasks.
- **Verification Method:** Use `get_task` for multiple tasks to verify changes were applied correctly.

#### Tool Name: `move_bulk_tasks`
- **Objective:** Move multiple tasks to a different list simultaneously.
- **Prompts:**
  1. "Move tasks 123456789, 234567890, and 345678901 to the 'Completed' list"
  2. "Transfer all 'bug' tasks from 'Development' to 'QA' list"
  3. "Move tasks 123456789, 234567890, and 345678901 to list 987654321"
  4. "Shift all high priority tasks from 'Backlog' to 'Current Sprint'"
  5. "Move several tasks including some that don't exist to a target list"
- **Expected Behavior:** Relocates all specified tasks to the target list and returns confirmation.
- **Verification Method:** Use `get_tasks` on the target list to verify all tasks were moved correctly.

#### Tool Name: `delete_bulk_tasks`
- **Objective:** Permanently remove multiple tasks simultaneously.
- **Prompts:**
  1. "Delete tasks 123456789, 234567890, and 345678901"
  2. "Remove all completed tasks from the 'Archive' list"
  3. "Permanently delete tasks 123456789, 234567890, and 345678901"
  4. "Delete all low priority tasks from the 'Backlog' list"
  5. "Remove several tasks including some that don't exist"
- **Expected Behavior:** Deletes all specified existing tasks and returns confirmation, with appropriate errors for non-existent tasks.
- **Verification Method:** Use `get_task` for multiple tasks to confirm they no longer exist.

### Task (Workspace Operations)

#### Tool Name: `get_workspace_tasks`
- **Objective:** Retrieve tasks from across the entire workspace with filtering options.
- **Prompts:**
  1. "Show all tasks tagged with 'urgent' across the workspace"
  2. "Find all tasks assigned to John in any list"
  3. "Get all tasks due this week across all projects"
  4. "Show all tasks with 'bug' in their name from any list"
  5. "Find all tasks created in the last 30 days with high priority"
- **Expected Behavior:** Returns filtered tasks from across the workspace matching the specified criteria.
- **Verification Method:** Verify that returned tasks match the filter criteria and represent data from multiple lists.

### Task (Attachments)

#### Tool Name: `attach_task_file`
- **Objective:** Add a file attachment to a specific task.
- **Prompts:**
  1. "Attach a screenshot to task 123456789"
  2. "Upload requirements.pdf to the 'Project plan' task"
  3. "Add design mockups from URL https://example.com/design.png to task 123456789"
  4. "Attach local file /path/to/document.docx to task 987654321"
  5. "Upload a large file to task 123456789 using chunked upload"
- **Expected Behavior:** Successfully attaches the file to the task and returns confirmation with file metadata.
- **Verification Method:** Verify the attachment appears in the task's attachments when retrieved with `get_task`.

### List

#### Tool Name: `create_list`
- **Objective:** Create a new list within a ClickUp space.
- **Prompts:**
  1. "Create a list called 'Q3 Projects' in the Development space"
  2. "Add a new list 'Marketing Campaigns' to space 123456789"
  3. "Create list 'Design Tasks' in Marketing space with description 'All design tasks for Q3 campaigns'"
  4. "Set up a 'Bug Tracking' list in the QA space with high priority"
  5. "Create a list in a non-existent space"
- **Expected Behavior:** Successfully creates the list in the specified space and returns the list data including ID.
- **Verification Method:** Use `get_list` to verify the list was created with correct properties.

#### Tool Name: `create_list_in_folder`
- **Objective:** Create a new list within a specific folder.
- **Prompts:**
  1. "Create a list called 'Sprint 22' in the 'Active Sprints' folder"
  2. "Add a 'Feature Requests' list to the Product folder in Development space"
  3. "Create list 'Social Media Content' in folder 123456789"
  4. "Set up 'Documentation' list in the 'Resources' folder with description 'All product documentation'"
  5. "Create a list in a non-existent folder"
- **Expected Behavior:** Successfully creates the list in the specified folder and returns the list data including ID.
- **Verification Method:** Use `get_list` to verify the list was created in the correct folder with proper properties.

#### Tool Name: `get_list`
- **Objective:** Retrieve details about a specific list.
- **Prompts:**
  1. "Show details for list 'Current Sprint'"
  2. "Get information about list 123456789"
  3. "Retrieve properties of the 'Marketing Campaigns' list"
  4. "What tasks are in the 'Bug Fixes' list?"
  5. "Get details for a non-existent list"
- **Expected Behavior:** Returns comprehensive list data including name, content, and associated tasks.
- **Verification Method:** Verify that all expected list fields are present in the response.

#### Tool Name: `update_list`
- **Objective:** Modify properties of an existing list.
- **Prompts:**
  1. "Rename list 'Backlog' to 'Product Backlog'"
  2. "Update the description of list 123456789 to 'High priority tasks for Q3'"
  3. "Change the status of 'Current Sprint' list to 'In Progress'"
  4. "Update content and name of the 'Bug Fixes' list"
  5. "Modify a non-existent list"
- **Expected Behavior:** Updates the specified list fields and returns the updated list data.
- **Verification Method:** Use `get_list` to verify the changes were applied correctly.

#### Tool Name: `delete_list`
- **Objective:** Permanently remove a list and all its tasks.
- **Prompts:**
  1. "Delete list 'Archived Projects'"
  2. "Remove list 123456789 completely"
  3. "Permanently delete the 'Old Campaigns' list"
  4. "Delete all tasks in the 'Completed' list by removing the list"
  5. "Remove a non-existent list"
- **Expected Behavior:** Successfully deletes the list if it exists and returns confirmation. For non-existent lists, returns appropriate error.
- **Verification Method:** Attempt to use `get_list` to confirm the list no longer exists.

### Folder

#### Tool Name: `create_folder`
- **Objective:** Create a new folder within a ClickUp space.
- **Prompts:**
  1. "Create a folder called 'Q3 Initiatives' in the Development space"
  2. "Add a new folder 'Campaign Materials' to the Marketing space"
  3. "Create folder 'Active Projects' in space 123456789 with custom statuses"
  4. "Set up a 'Resources' folder in the Design space"
  5. "Create a folder in a non-existent space"
- **Expected Behavior:** Successfully creates the folder in the specified space and returns the folder data including ID.
- **Verification Method:** Use `get_folder` to verify the folder was created with correct properties.

#### Tool Name: `get_folder`
- **Objective:** Retrieve details about a specific folder.
- **Prompts:**
  1. "Show details for folder 'Active Sprints'"
  2. "Get information about folder 123456789"
  3. "Retrieve properties of the 'Marketing Campaigns' folder in the Marketing space"
  4. "What lists are in the 'Resources' folder?"
  5. "Get details for a non-existent folder"
- **Expected Behavior:** Returns comprehensive folder data including name, associated lists, and space information.
- **Verification Method:** Verify that all expected folder fields are present in the response.

#### Tool Name: `update_folder`
- **Objective:** Modify properties of an existing folder.
- **Prompts:**
  1. "Rename folder 'Sprints' to 'Development Sprints'"
  2. "Update folder 123456789 to use custom statuses"
  3. "Change the name of the 'Resources' folder in the Marketing space"
  4. "Update both name and status configuration of 'Old Projects' folder"
  5. "Modify a non-existent folder"
- **Expected Behavior:** Updates the specified folder fields and returns the updated folder data.
- **Verification Method:** Use `get_folder` to verify the changes were applied correctly.

#### Tool Name: `delete_folder`
- **Objective:** Permanently remove a folder and all its contents.
- **Prompts:**
  1. "Delete folder 'Archived Projects'"
  2. "Remove folder 123456789 completely"
  3. "Permanently delete the 'Old Campaigns' folder in the Marketing space"
  4. "Delete all lists in the 'Completed' folder by removing the folder"
  5. "Remove a non-existent folder"
- **Expected Behavior:** Successfully deletes the folder if it exists and returns confirmation. For non-existent folders, returns appropriate error.
- **Verification Method:** Attempt to use `get_folder` to confirm the folder no longer exists.

### Tag

#### Tool Name: `get_space_tags`
- **Objective:** Retrieve all tags defined in a ClickUp space.
- **Prompts:**
  1. "Show all tags in the Development space"
  2. "Get tags from space 123456789"
  3. "What tags are available in the Marketing space?"
  4. "List all existing tags for the Design team space"
  5. "Get tags from a non-existent space"
- **Expected Behavior:** Returns an array of all tags defined in the specified space.
- **Verification Method:** Verify that the returned data structure contains tag names, colors, and IDs.

#### Tool Name: `create_space_tag`
- **Objective:** Create a new tag within a ClickUp space.
- **Prompts:**
  1. "Create a tag called 'urgent' with red color in the Development space"
  2. "Add a new tag 'qa-approved' to space 123456789"
  3. "Create tag 'needs-review' in the Marketing space with yellow color"
  4. "Set up a 'blocked' tag in the Design space"
  5. "Create a tag in a non-existent space"
- **Expected Behavior:** Successfully creates the tag in the specified space and returns the tag data.
- **Verification Method:** Use `get_space_tags` to verify the tag was created with correct properties.

#### Tool Name: `update_space_tag`
- **Objective:** Modify properties of an existing tag.
- **Prompts:**
  1. "Change the color of tag 'urgent' to orange in the Development space"
  2. "Rename tag 'bug' to 'critical-bug' in space 123456789"
  3. "Update tag 'needs-review' in the Marketing space to have green color"
  4. "Modify both name and color of the 'blocked' tag in Design space"
  5. "Update a non-existent tag"
- **Expected Behavior:** Updates the specified tag fields and returns the updated tag data.
- **Verification Method:** Use `get_space_tags` to verify the changes were applied correctly.

#### Tool Name: `delete_space_tag`
- **Objective:** Permanently remove a tag from a space.
- **Prompts:**
  1. "Delete tag 'obsolete' from the Development space"
  2. "Remove tag 'old-version' from space 123456789"
  3. "Permanently delete the 'draft' tag from the Marketing space"
  4. "Delete the unused 'legacy' tag from Design space"
  5. "Remove a non-existent tag"
- **Expected Behavior:** Successfully deletes the tag if it exists and returns confirmation. For non-existent tags, returns appropriate error.
- **Verification Method:** Use `get_space_tags` to confirm the tag no longer exists in the list of space tags.

#### Tool Name: `add_tag_to_task`
- **Objective:** Apply an existing tag to a specific task.
- **Prompts:**
  1. "Tag task 123456789 with 'urgent'"
  2. "Add the 'needs-review' tag to 'Homepage redesign' task"
  3. "Apply tag 'qa-approved' to task 123456789"
  4. "Add 'blocked' tag to the task 'API integration'"
  5. "Tag a task with a non-existent tag"
- **Expected Behavior:** Successfully adds the tag to the task and returns confirmation.
- **Verification Method:** Use `get_task` to verify the tag appears in the task's tags array.

#### Tool Name: `remove_tag_from_task`
- **Objective:** Remove a tag from a specific task.
- **Prompts:**
  1. "Remove 'urgent' tag from task 123456789"
  2. "Delete the 'needs-review' tag from 'Homepage redesign' task"
  3. "Take off tag 'qa-approved' from task 123456789"
  4. "Remove 'blocked' tag from the task 'API integration'"
  5. "Remove a tag that isn't applied to the task"
- **Expected Behavior:** Successfully removes the tag from the task and returns confirmation.
- **Verification Method:** Use `get_task` to verify the tag no longer appears in the task's tags array.

## 📊 Test Execution

For each test case:
1. Execute the prompt against the ClickUp MCP Server
2. Capture the response
3. Verify the result matches the expected behavior using the specified verification method
4. Document any discrepancies or unexpected behavior

## 🔄 Maintenance

This test plan should be updated when:
- New tools are added to the ClickUp MCP Server
- Existing tools are modified or have parameter changes
- New edge cases or usage patterns are identified
</file>

<file path=".github/workflows/publish.yml">
name: Build, Tag and Publish

on:
  # Only run this workflow manually, not automatically on push
  workflow_dispatch:
    inputs:
      version_increment:
        description: 'Version increment (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # This ensures all history is fetched for proper versioning
      
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
      
      - name: Get current version
        id: package_version
        run: echo "current_version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
      
      - name: Calculate new version
        id: new_version
        run: |
          if [ "${{ github.event.inputs.version_increment }}" = "patch" ]; then
            npm --no-git-tag-version version patch
          elif [ "${{ github.event.inputs.version_increment }}" = "minor" ]; then
            npm --no-git-tag-version version minor
          elif [ "${{ github.event.inputs.version_increment }}" = "major" ]; then
            npm --no-git-tag-version version major
          fi
          echo "new_version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
      
      - name: Update server.ts version
        run: |
          sed -i "s/version: \"${{ steps.package_version.outputs.current_version }}\"/version: \"${{ steps.new_version.outputs.new_version }}\"/g" src/server.ts
      
      - name: Commit all version changes
        run: |
          git add package.json package-lock.json src/server.ts
          git commit -m "Bump version to ${{ steps.new_version.outputs.new_version }} [skip ci]"
          git tag -a v${{ steps.new_version.outputs.new_version }} -m "Version ${{ steps.new_version.outputs.new_version }}"
      
      - name: Build
        run: npm run build
      
      - name: Publish to NPM
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      
      - name: Create GitHub Release
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let releaseNotes = '';
            
            try {
              // Read release notes from file
              releaseNotes = fs.readFileSync('./release-notes.md', 'utf8');
            } catch (error) {
              console.log('Warning: Could not read release-notes.md, using default message');
              releaseNotes = 'See CHANGELOG.md for detailed changes in this version.';
            }
            
            // Create the release
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: `v${{ steps.new_version.outputs.new_version }}`,
              name: `v${{ steps.new_version.outputs.new_version }}`,
              body: releaseNotes,
              draft: false,
              prerelease: false
            });
      
      - name: Push changes
        run: git push --follow-tags
</file>

<file path="src/services/clickup/task/index.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Module Exports
 * 
 * Exports all task-related functionality:
 * - Core task operations (CRUD)
 * - Task searching and filtering
 * - Task comments
 * - File attachments
 * - Task tags
 * - Custom fields
 */

// Export the main TaskService class
export { TaskService } from './task-service.js';

// Export all component services
export { TaskServiceCore } from './task-core.js';
export { TaskServiceSearch } from './task-search.js';
export { TaskServiceAttachments } from './task-attachments.js';
export { TaskServiceComments } from './task-comments.js';
export { TaskServiceTags } from './task-tags.js';
export { TaskServiceCustomFields } from './task-custom-fields.js';

// Export types and interfaces from all modules
export * from './task-core.js';
export * from './task-search.js';
export * from './task-attachments.js';
export * from './task-comments.js';
export * from './task-tags.js';
export * from './task-custom-fields.js';

// Re-export TaskService as the default export
export { TaskService as default } from './task-service.js';
</file>

<file path="src/services/clickup/task/task-attachments.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Attachments Module
 * 
 * Handles file attachment operations for ClickUp tasks, supporting three methods:
 * - Uploading file attachments from base64/buffer data
 * - Uploading file attachments from a URL (web URLs like http/https)
 * - Uploading file attachments from local file paths (absolute paths)
 */

import { TaskServiceSearch } from './task-search.js';
import { ClickUpTaskAttachment } from '../types.js';

/**
 * Attachment functionality for the TaskService
 */
export class TaskServiceAttachments extends TaskServiceSearch {
  /**
   * Upload a file attachment to a ClickUp task
   * @param taskId The ID of the task to attach the file to
   * @param fileData The file data as a Buffer
   * @param fileName The name of the file
   * @returns Promise resolving to the attachment response from ClickUp
   */
  async uploadTaskAttachment(taskId: string, fileData: Buffer, fileName: string): Promise<ClickUpTaskAttachment> {
    this.logOperation('uploadTaskAttachment', { taskId, fileName, fileSize: fileData.length });
    
    try {
      return await this.makeRequest(async () => {
        // Create FormData for multipart/form-data upload
        const FormData = (await import('form-data')).default;
        const formData = new FormData();
        
        // Add the file to the form data
        formData.append('attachment', fileData, {
          filename: fileName,
          contentType: 'application/octet-stream' // Let ClickUp determine the content type
        });
        
        // Use the raw axios client for this request since we need to handle FormData
        const response = await this.client.post(
          `/task/${taskId}/attachment`,
          formData,
          {
            headers: {
              ...formData.getHeaders(),
              'Authorization': this.apiKey
            }
          }
        );
        
        return response.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to upload attachment to task ${taskId}`);
    }
  }

  /**
   * Upload a file attachment to a ClickUp task from a URL
   * @param taskId The ID of the task to attach the file to
   * @param fileUrl The URL of the file to download and attach
   * @param fileName Optional file name (if not provided, it will be extracted from the URL)
   * @param authHeader Optional authorization header for the URL
   * @returns Promise resolving to the attachment response from ClickUp
   */
  async uploadTaskAttachmentFromUrl(
    taskId: string, 
    fileUrl: string, 
    fileName?: string, 
    authHeader?: string
  ): Promise<ClickUpTaskAttachment> {
    this.logOperation('uploadTaskAttachmentFromUrl', { taskId, fileUrl, fileName });
    
    try {
      return await this.makeRequest(async () => {
        // Import required modules
        const axios = (await import('axios')).default;
        const FormData = (await import('form-data')).default;
        
        // Download the file from the URL
        const headers: Record<string, string> = {};
        if (authHeader) {
          headers['Authorization'] = authHeader;
        }
        
        const response = await axios.get(fileUrl, {
          responseType: 'arraybuffer',
          headers
        });
        
        // Extract filename from URL if not provided
        const actualFileName = fileName || fileUrl.split('/').pop() || 'downloaded-file';
        
        // Create FormData for multipart/form-data upload
        const formData = new FormData();
        
        // Add the file to the form data
        formData.append('attachment', Buffer.from(response.data), {
          filename: actualFileName,
          contentType: 'application/octet-stream'
        });
        
        // Upload the file to ClickUp
        const uploadResponse = await this.client.post(
          `/task/${taskId}/attachment`,
          formData,
          {
            headers: {
              ...formData.getHeaders(),
              'Authorization': this.apiKey
            }
          }
        );
        
        return uploadResponse.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to upload attachment from URL to task ${taskId}`);
    }
  }
}
</file>

<file path="src/services/clickup/task/task-comments.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Comments Module
 * 
 * Handles comment operations for ClickUp tasks, including:
 * - Retrieving comments for a task
 * - Creating comments on a task
 */

import { TaskServiceAttachments } from './task-attachments.js';
import { ClickUpComment } from '../types.js';

/**
 * Comments functionality for the TaskService
 */
export class TaskServiceComments extends TaskServiceAttachments {
  /**
   * Get all comments for a task
   * 
   * @param taskId ID of the task to get comments for
   * @param start Optional pagination start
   * @param startId Optional comment ID to start from
   * @returns Array of task comments
   */
  async getTaskComments(taskId: string, start?: number, startId?: string): Promise<ClickUpComment[]> {
    this.logOperation('getTaskComments', { taskId, start, startId });
    
    try {
      // Build query parameters for pagination
      const queryParams = new URLSearchParams();
      if (start !== undefined) {
        queryParams.append('start', start.toString());
      }
      if (startId) {
        queryParams.append('start_id', startId);
      }
      
      const queryString = queryParams.toString() ? `?${queryParams.toString()}` : '';
      const response = await this.client.get<{ comments: ClickUpComment[] }>(
        `/task/${taskId}/comment${queryString}`
      );
      
      return response.data.comments || [];
    } catch (error) {
      throw this.handleError(error, 'Failed to get task comments');
    }
  }

  /**
   * Create a comment on a task
   * 
   * @param taskId ID of the task to comment on
   * @param commentText Text content of the comment
   * @param notifyAll Whether to notify all assignees
   * @param assignee Optional user ID to assign the comment to
   * @returns The created comment
   */
  async createTaskComment(
    taskId: string, 
    commentText: string, 
    notifyAll: boolean = false,
    assignee?: number | null
  ): Promise<ClickUpComment> {
    this.logOperation('createTaskComment', { taskId, commentText, notifyAll, assignee });
    
    try {
      const payload: {
        comment_text: string;
        notify_all: boolean;
        assignee?: number;
      } = {
        comment_text: commentText,
        notify_all: notifyAll
      };
      
      if (assignee) {
        payload.assignee = assignee;
      }
      
      // Make the request directly without using makeRequest for better error handling
      const response = await this.client.post(
        `/task/${taskId}/comment`,
        payload
      );
      
      // Handle different response formats from ClickUp API
      if (response.data) {
        if (response.data.comment) {
          // Standard format: { comment: ClickUpComment }
          return response.data.comment;
        } else if (response.data.id && (response.data.comment_text || response.data.comment)) {
          // Direct format: the comment object itself
          return response.data as ClickUpComment;
        } else {
          // Fallback: construct a minimal valid comment object
          return {
            id: response.data.id || `custom-${Date.now()}`,
            comment: response.data.comment || commentText,
            comment_text: response.data.comment_text || commentText,
            user: response.data.user || { id: 0, username: 'Unknown', email: '', color: '' },
            date: response.data.date || new Date().toISOString(),
            resolved: false
          } as ClickUpComment;
        }
      }
      
      throw new Error('Invalid response from ClickUp API');
    } catch (error: any) {
      // Check if comment might have been created despite error
      if (error.response?.status === 200 || error.response?.status === 201) {
        // Try to construct a comment object from what we know
        return {
          id: `fallback-${Date.now()}`,
          comment: commentText,
          comment_text: commentText, 
          user: { id: 0, username: 'Unknown', email: '', color: '' },
          date: new Date().toISOString(),
          resolved: false
        } as ClickUpComment;
      }
      
      throw this.handleError(error, 'Failed to create task comment');
    }
  }
}
</file>

<file path="src/services/clickup/types.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Common type definitions for ClickUp API entities
 */

/**
 * Task priority level (1-4 or null)
 * 1 = Urgent (Highest)
 * 2 = High
 * 3 = Normal
 * 4 = Low (Lowest)
 * null = No priority
 */
export type TaskPriority = 1 | 2 | 3 | 4 | null;

// Helper function to validate and convert priority values
export function toTaskPriority(value: unknown): TaskPriority | undefined {
  if (value === null) return null;
  if (value === undefined) return undefined;
  if (value === "null") return null;
  
  // Convert string to number if needed
  const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
  
  // Validate it's a valid priority number
  if (typeof numValue === 'number' && !isNaN(numValue) && [1, 2, 3, 4].includes(numValue)) {
    return numValue as TaskPriority;
  }
  
  return undefined;
}

/**
 * Priority object as returned by the ClickUp API
 */
export interface ClickUpPriority {
  id: string;
  priority: string;
  color: string;
  orderindex: string;
}

/**
 * Status object as returned by the ClickUp API
 */
export interface ClickUpStatus {
  id: string;
  status: string;
  color: string;
  orderindex: number;
  type: string;
}

/**
 * User object as returned by the ClickUp API
 */
export interface ClickUpUser {
  id: number;
  username: string;
  email: string;
  color: string;
  profilePicture?: string;
  initials?: string;
}

/**
 * Space object as returned by the ClickUp API
 */
export interface ClickUpSpace {
  id: string;
  name: string;
  private: boolean;
  statuses: ClickUpStatus[];
  multiple_assignees: boolean;
  features?: {
    due_dates: {
      enabled: boolean;
      start_date: boolean;
      remap_due_dates: boolean;
      remap_closed_due_date: boolean;
    };
    time_tracking: {
      enabled: boolean;
    };
    tags: {
      enabled: boolean;
    };
    time_estimates: {
      enabled: boolean;
    };
    checklists: {
      enabled: boolean;
    };
    custom_fields: {
      enabled: boolean;
    };
    remap_dependencies: {
      enabled: boolean;
    };
    dependency_warning: {
      enabled: boolean;
    };
    portfolios: {
      enabled: boolean;
    };
  };
  archived: boolean;
}

/**
 * Folder object as returned by the ClickUp API
 */
export interface ClickUpFolder {
  id: string;
  name: string;
  orderindex: number;
  override_statuses: boolean;
  hidden: boolean;
  space: {
    id: string;
    name: string;
  };
  task_count: string;
  lists: ClickUpList[];
  archived: boolean;
}

/**
 * List object as returned by the ClickUp API
 */
export interface ClickUpList {
  id: string;
  name: string;
  orderindex: number;
  content: string;
  status: {
    status: string;
    color: string;
    hide_label: boolean;
  };
  priority: {
    priority: string;
    color: string;
  };
  assignee: ClickUpUser | null;
  task_count: number;
  due_date: string | null;
  start_date: string | null;
  folder: {
    id: string;
    name: string;
    hidden: boolean;
    access: boolean;
  } | null;
  space: {
    id: string;
    name: string;
  };
  archived: boolean;
  override_statuses: boolean;
  statuses?: ClickUpStatus[];
}

/**
 * Task object as returned by the ClickUp API
 */
export interface ClickUpTask {
  id: string;
  name: string;
  custom_id?: string;
  text_content: string;
  description: string;
  status: ClickUpStatus;
  orderindex: string;
  date_created: string;
  date_updated: string;
  date_closed: string | null;
  creator: {
    id: number;
    username: string;
    color: string;
    profilePicture: string | null;
  };
  assignees: ClickUpUser[];
  watchers: ClickUpUser[];
  checklists: any[];
  tags: {
    name: string;
    tag_fg: string;
    tag_bg: string;
    creator?: number;
  }[];
  parent: string | null;
  top_level_parent?: string | null;
  priority: ClickUpPriority | null;
  due_date: string | null;
  start_date: string | null;
  time_estimate: number | null;
  time_spent: number | null;
  custom_fields: Record<string, any>;
  dependencies: string[];
  linked_tasks: string[];
  team_id: string;
  list: {
    id: string;
    name: string;
    access: boolean;
  };
  folder: {
    id: string;
    name: string;
    hidden: boolean;
    access: boolean;
  } | null;
  space: {
    id: string;
    name: string;
  };
  url: string;
  subtasks?: ClickUpTask[];
}

/**
 * Data for creating a task
 */
export interface CreateTaskData {
  name: string;
  description?: string;
  markdown_description?: string;
  assignees?: (number | string)[];
  tags?: string[];
  status?: string;
  priority?: TaskPriority;
  due_date?: number;
  due_date_time?: boolean;
  time_estimate?: number;
  start_date?: number;
  start_date_time?: boolean;
  notify_all?: boolean;
  parent?: string | null;
  links_to?: string | null;
  check_required_custom_fields?: boolean;
  custom_fields?: Array<{
    id: string;
    value: any;
  }>;
}

/**
 * Data for creating a list
 */
export interface CreateListData {
  name: string;
  content?: string;
  due_date?: number;
  due_date_time?: boolean;
  priority?: TaskPriority;
  assignee?: number;
  status?: string;
}

/**
 * Data for creating a folder
 */
export interface CreateFolderData {
  name: string;
  override_statuses?: boolean;
}

/**
 * Update task data (partial)
 */
export interface UpdateTaskData extends Partial<CreateTaskData> {}

/**
 * Task filtering parameters
 */
export interface TaskFilters {
  tags?: string[];
  list_ids?: string[];
  folder_ids?: string[];
  space_ids?: string[];
  statuses?: string[];
  assignees?: string[];
  date_created_gt?: number;
  date_created_lt?: number;
  date_updated_gt?: number;
  date_updated_lt?: number;
  due_date_gt?: number;
  due_date_lt?: number;
  include_closed?: boolean;
  include_archived_lists?: boolean;
  include_closed_lists?: boolean;
  archived?: boolean;
  order_by?: 'id' | 'created' | 'updated' | 'due_date';
  reverse?: boolean;
  page?: number;
  subtasks?: boolean;
  include_subtasks?: boolean;
  include_compact_time_entries?: boolean;
  custom_fields?: Record<string, any>;
}

/**
 * Response when retrieving tasks from a list
 */
export interface TasksResponse {
  tasks: ClickUpTask[];
  statuses: string[];
}

/**
 * Node in the workspace hierarchy tree
 */
export interface WorkspaceNode {
  id: string;
  name: string;
  type: 'space' | 'folder' | 'list';
  parentId?: string;
  children?: WorkspaceNode[];
}

/**
 * Complete workspace hierarchy tree
 */
export interface WorkspaceTree {
  root: {
    id: string;
    name: string;
    children: WorkspaceNode[];
  };
}

/**
 * Data for creating multiple tasks at once
 */
export interface BulkCreateTasksData {
  tasks: CreateTaskData[];
}

/**
 * Comment object as returned by the ClickUp API
 */
export interface ClickUpComment {
  id: string;
  comment: string; // The comment text
  comment_text: string; // The comment text without formatting
  user: {
    id: number;
    username: string;
    email: string;
    color: string;
    profilePicture?: string;
  };
  resolved: boolean;
  assigned_by?: {
    id: number;
    username: string;
    email: string;
    color: string;
    profilePicture?: string;
  };
  assigned?: {
    id: number;
    username: string;
    email: string;
    color: string;
    profilePicture?: string;
  };
  date: string; // ISO date string
  reactions?: {
    [key: string]: {
      count: number;
      users: Array<{
        id: number;
        username: string;
        email: string;
        color: string;
        profilePicture: string | null;
      }>;
    };
  };
  attachments?: ClickUpCommentAttachment[];
}

/**
 * Comment attachment object as returned by the ClickUp API
 */
export interface ClickUpCommentAttachment {
  id: string;
  date: string;
  title: string;
  type: string;
  source: string;
  thumbnail_small?: string;
  thumbnail_medium?: string;
  thumbnail_large?: string;
  url: string;
  url_viewer?: string;
}

/**
 * Comments response object returned by the ClickUp API
 */
export interface CommentsResponse {
  comments: ClickUpComment[];
}

/**
 * Task attachment object as returned by the ClickUp API
 */
export interface ClickUpTaskAttachment {
  id: string;
  date: string;
  title: string;
  type: string; // File extension or type
  source: string; // Usually "upload"
  thumbnail_small?: string;
  thumbnail_medium?: string;
  thumbnail_large?: string;
  url: string; // Download URL
  user: {
    id: number;
    username: string;
    email: string;
    color: string;
    profilePicture: string | null;
  };
  size?: number; // File size in bytes
  extension?: string; // File extension
}

/**
 * Response from the task attachment endpoint
 */
export interface TaskAttachmentResponse {
  success: true;
  message: string;
  attachment: ClickUpTaskAttachment;
}

/**
 * Response for chunked upload initialization
 */
export interface ChunkedUploadInitResponse {
  success: true;
  message: string;
  chunk_session: string;
  chunks_total: number;
  chunk_uploaded: number;
  attachment: null;
  details: {
    taskId: string;
    fileName: string;
    fileSize: number;
    chunkCount: number;
    progress: number;
  };
}

/**
 * Response for chunked upload progress
 */
export interface ChunkedUploadProgressResponse {
  success: true;
  message: string;
  chunk_session: string;
  chunks_remaining: number;
  details: {
    taskId: string;
    fileName: string;
    chunksReceived: number;
    progress: number;
  };
}

/**
 * Union type for all possible attachment responses
 */
export type AttachmentResponse = 
  | TaskAttachmentResponse 
  | ChunkedUploadInitResponse 
  | ChunkedUploadProgressResponse;

/**
 * Tag object as returned by the ClickUp API
 */
export interface ClickUpTag {
  name: string;
  tag_bg: string;
  tag_fg: string;
  creator?: number;
}

/**
 * Response when retrieving tags from a space
 */
export interface SpaceTagsResponse {
  tags: ClickUpTag[];
}

/**
 * Data for creating a space tag
 */
export interface CreateSpaceTagData {
  tag_name: string;
  tag_bg: string;
  tag_fg: string;
}

/**
 * Data for updating a space tag
 */
export interface UpdateSpaceTagData {
  tag_name?: string;
  tag_bg?: string;
  tag_fg?: string;
}

/**
 * Response type for team tasks endpoint
 */
export interface TeamTasksResponse {
  tasks: ClickUpTask[];
}

/**
 * Minimal task data for summary view
 */
export interface TaskSummary {
  id: string;
  name: string;
  status: string;
  list: {
    id: string;
    name: string;
  };
  due_date: string | null;
  url: string;
  priority: number | null;
  tags: {
    name: string;
    tag_bg: string;
    tag_fg: string;
  }[];
}

/**
 * Response format for detailed task data
 */
export interface DetailedTaskResponse {
  tasks: ClickUpTask[];
  total_count: number;
  has_more: boolean;
  next_page: number;
}

/**
 * Response format for task summaries
 */
export interface WorkspaceTasksResponse {
  summaries: TaskSummary[];
  total_count: number;
  has_more: boolean;
  next_page: number;
}

/**
 * Extended task filters with detail level option
 */
export interface ExtendedTaskFilters extends TaskFilters {
  detail_level?: 'summary' | 'detailed';
}

/**
 * Options for listing documents
 */
export interface ListDocumentsOptions {
  id?: string;
  creator?: number;
  deleted?: boolean;
  archived?: boolean;
  parent_id?: string;
  parent_type?: 'space' | 'folder' | 'list';
  limit?: number;
  next_cursor?: string;
}

/**
 * Document object as returned by the ClickUp API
 */
export interface ClickUpDocument {
  id: string;
  date_created: number;
  date_updated: number;
  name: string;
  parent: {
    id: string;
    type: number;
  };
  public: boolean;
  workspace_id: number;
  creator: number;
  deleted: boolean;
  type: number;
}

/**
 * ClickUp parent container types
 */
export enum ClickUpParentType {
  Space = 4,
  Folder = 5,
  List = 6,
  All = 7,
  Workspace = 12
}

/**
 * Data for creating a document
 */
export interface CreateDocumentData {
  name: string;
  parent: {
    id: string;
    type: ClickUpParentType;
  };
  visibility: 'PUBLIC' | 'PRIVATE';
  create_page: boolean;
}

export interface ClickUpDocumentResponse {
  docs: ClickUpDocument[];
  next_cursor?: string;
}

export interface ClickUpDocumentPage {
  id: string;
  name: string;
  content?: string;
  sub_title?: string;
  parent_id?: string;
  parent_page_id?: string | null;
  children?: ClickUpDocumentPage[];
}

export interface DocumentPagesResponse {
  pages: ClickUpDocumentPage[];
}

export interface DocumentPageListingOptions {
  max_page_depth?: number;
}

/**
 * Data for creating a document page
 */
export interface CreateDocumentPageData {
  name: string;
  sub_title?: string;
  parent_page_id?: string;
  content?: string;
  content_format?: 'text/md' | 'text/plain';
}

/**
 * Data for updating a document page
 */
export interface UpdateDocumentPageData {
  name?: string;
  sub_title?: string;
  content?: string;
  content_format?: 'text/md' | 'text/plain';
  content_edit_mode?: 'replace' | 'append' | 'prepend';
}

/**
 * Options for retrieving document pages (query parameters)
 */
export interface DocumentPagesOptions {
  content_format?: 'text/md' | 'text/html';
  max_page_depth?: number;
  pageIds: string[];
}
</file>

<file path="src/services/clickup/workspace.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Workspace Service Module
 * 
 * Handles workspace hierarchy and space-related operations
 */

import { BaseClickUpService, ClickUpServiceError, ErrorCode } from './base.js';
import { 
  ClickUpSpace, 
  ClickUpFolder,
  ClickUpList,
  WorkspaceTree, 
  WorkspaceNode
} from './types.js';
import { Logger } from '../../logger.js';

// Create a logger instance for workspace service
const logger = new Logger('WorkspaceService');

/**
 * Service for workspace-related operations
 */
export class WorkspaceService extends BaseClickUpService {
  
  // Store the workspace hierarchy in memory
  private workspaceHierarchy: WorkspaceTree | null = null;

  /**
   * Creates an instance of WorkspaceService
   * @param apiKey - ClickUp API key
   * @param teamId - ClickUp team ID
   * @param baseUrl - Optional custom API URL
   */
  constructor(
    apiKey: string, 
    teamId: string, 
    baseUrl?: string
  ) {
    super(apiKey, teamId, baseUrl);
  }

  /**
   * Helper method to handle errors consistently
   * @param error - Error caught from a try/catch
   * @param message - Optional message to add to the error
   * @returns - A standardized ClickUpServiceError
   */
  private handleError(error: any, message?: string): ClickUpServiceError {
    logger.error('WorkspaceService error:', error);
    
    // If the error is already a ClickUpServiceError, return it
    if (error instanceof ClickUpServiceError) {
      return error;
    }

    // Otherwise, create a new ClickUpServiceError
    const errorMessage = message || 'An error occurred in WorkspaceService';
    return new ClickUpServiceError(errorMessage, ErrorCode.WORKSPACE_ERROR, error);
  }

  /**
   * Get all spaces for the team
   * @returns - Promise resolving to array of spaces
   */
  async getSpaces(): Promise<ClickUpSpace[]> {
    try {
      const response = await this.makeRequest(async () => {
        const result = await this.client.get(`/team/${this.teamId}/space`);
        return result.data;
      });
      return response.spaces || [];
    } catch (error) {
      throw this.handleError(error, 'Failed to get spaces');
    }
  }

  /**
   * Get a specific space by ID
   * @param spaceId - The ID of the space to retrieve
   * @returns - Promise resolving to the space object
   */
  async getSpace(spaceId: string): Promise<ClickUpSpace> {
    try {
      // Validate spaceId
      if (!spaceId) {
        throw new ClickUpServiceError(
          'Space ID is required', 
          ErrorCode.INVALID_PARAMETER
        );
      }

      return await this.makeRequest(async () => {
        const result = await this.client.get(`/space/${spaceId}`);
        return result.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get space with ID ${spaceId}`);
    }
  }

  /**
   * Find a space by name
   * @param spaceName - The name of the space to find
   * @returns - Promise resolving to the space or null if not found
   */
  async findSpaceByName(spaceName: string): Promise<ClickUpSpace | null> {
    try {
      // Validate spaceName
      if (!spaceName) {
        throw new ClickUpServiceError(
          'Space name is required', 
          ErrorCode.INVALID_PARAMETER
        );
      }

      // Get all spaces and find the one with the matching name
      const spaces = await this.getSpaces();
      const space = spaces.find(s => s.name === spaceName);
      
      return space || null;
    } catch (error) {
      throw this.handleError(error, `Failed to find space with name ${spaceName}`);
    }
  }

  /**
   * Get the complete workspace hierarchy including spaces, folders, and lists
   * @param forceRefresh - Whether to force a refresh of the hierarchy
   * @returns - Promise resolving to the workspace tree
   */
  async getWorkspaceHierarchy(forceRefresh = false): Promise<WorkspaceTree> {
    try {
      // If we have the hierarchy in memory and not forcing refresh, return it
      if (this.workspaceHierarchy && !forceRefresh) {
        logger.debug('Returning cached workspace hierarchy');
        return this.workspaceHierarchy;
      }

      const startTime = Date.now();
      logger.info('Starting workspace hierarchy fetch');

      // Start building the workspace tree
      const workspaceTree: WorkspaceTree = {
        root: {
          id: this.teamId,
          name: 'Workspace',
          children: []
        }
      };

      // Get all spaces
      const spacesStartTime = Date.now();
      const spaces = await this.getSpaces();
      const spacesTime = Date.now() - spacesStartTime;
      logger.info(`Fetched ${spaces.length} spaces in ${spacesTime}ms`);

      // Process spaces in batches to respect rate limits
      const batchSize = 3; // Process 3 spaces at a time
      const spaceNodes: WorkspaceNode[] = [];
      let totalFolders = 0;
      let totalLists = 0;

      for (let i = 0; i < spaces.length; i += batchSize) {
        const batchStartTime = Date.now();
        const spaceBatch = spaces.slice(i, i + batchSize);
        logger.debug(`Processing space batch ${i / batchSize + 1} of ${Math.ceil(spaces.length / batchSize)} (${spaceBatch.length} spaces)`);

        const batchNodes = await Promise.all(spaceBatch.map(async (space) => {
          const spaceStartTime = Date.now();
          const spaceNode: WorkspaceNode = {
            id: space.id,
            name: space.name,
            type: 'space',
            children: []
          };

          // Fetch initial space data
          const [folders, listsInSpace] = await Promise.all([
            this.getFoldersInSpace(space.id),
            this.getListsInSpace(space.id)
          ]);

          totalFolders += folders.length;
          totalLists += listsInSpace.length;

          // Process folders in smaller batches
          const folderBatchSize = 5; // Process 5 folders at a time
          const folderNodes: WorkspaceNode[] = [];

          for (let j = 0; j < folders.length; j += folderBatchSize) {
            const folderBatchStartTime = Date.now();
            const folderBatch = folders.slice(j, j + folderBatchSize);
            const batchFolderNodes = await Promise.all(folderBatch.map(async (folder) => {
              const folderNode: WorkspaceNode = {
                id: folder.id,
                name: folder.name,
                type: 'folder',
                parentId: space.id,
                children: []
              };

              // Get lists in the folder
              const listsInFolder = await this.getListsInFolder(folder.id);
              totalLists += listsInFolder.length;
              folderNode.children = listsInFolder.map(list => ({
                id: list.id,
                name: list.name,
                type: 'list',
                parentId: folder.id
              }));

              return folderNode;
            }));

            folderNodes.push(...batchFolderNodes);
            const folderBatchTime = Date.now() - folderBatchStartTime;
            logger.debug(`Processed folder batch in space ${space.name} in ${folderBatchTime}ms (${folderBatch.length} folders)`);
          }

          // Add folder nodes to space
          spaceNode.children?.push(...folderNodes);

          // Add folderless lists to space
          logger.debug(`Adding ${listsInSpace.length} lists directly to space ${space.name}`);
          
          const listNodes = listsInSpace.map(list => ({
            id: list.id,
            name: list.name,
            type: 'list' as const,
            parentId: space.id
          }));

          spaceNode.children?.push(...listNodes);

          const spaceTime = Date.now() - spaceStartTime;
          logger.info(`Processed space ${space.name} in ${spaceTime}ms (${folders.length} folders, ${listsInSpace.length} lists)`);

          return spaceNode;
        }));

        spaceNodes.push(...batchNodes);
        const batchTime = Date.now() - batchStartTime;
        logger.info(`Processed space batch in ${batchTime}ms (${spaceBatch.length} spaces)`);
      }

      // Add all space nodes to the workspace tree
      workspaceTree.root.children.push(...spaceNodes);

      const totalTime = Date.now() - startTime;
      logger.info('Workspace hierarchy fetch completed', {
        duration: totalTime,
        spaces: spaces.length,
        folders: totalFolders,
        lists: totalLists,
        averageTimePerSpace: totalTime / spaces.length,
        averageTimePerNode: totalTime / (spaces.length + totalFolders + totalLists)
      });

      // Store the hierarchy for later use
      this.workspaceHierarchy = workspaceTree;
      return workspaceTree;
    } catch (error) {
      throw this.handleError(error, 'Failed to get workspace hierarchy');
    }
  }

  /**
   * Clear the stored workspace hierarchy, forcing a fresh fetch on next request
   */
  clearWorkspaceHierarchy(): void {
    this.workspaceHierarchy = null;
  }

  /**
   * Find a node in the workspace tree by name and type
   * @param node - The node to start searching from
   * @param name - The name to search for
   * @param type - The type of node to search for
   * @returns - The node and its path if found, null otherwise
   */
  private findNodeInTree(
    node: WorkspaceNode | WorkspaceTree['root'],
    name: string,
    type: 'space' | 'folder' | 'list'
  ): { node: WorkspaceNode; path: string } | null {
    // If this is the node we're looking for, return it
    if ('type' in node && node.type === type && node.name === name) {
      return { node, path: node.name };
    }

    // Otherwise, search its children recursively
    for (const child of (node.children || [])) {
      const result = this.findNodeInTree(child, name, type);
      if (result) {
        // Prepend this node's name to the path
        const currentNodeName = 'name' in node ? node.name : 'Workspace';
        result.path = `${currentNodeName} > ${result.path}`;
        return result;
      }
    }

    // Not found in this subtree
    return null;
  }

  /**
   * Find an ID by name and type in the workspace hierarchy
   * @param hierarchy - The workspace hierarchy
   * @param name - The name to search for
   * @param type - The type of node to search for
   * @returns - The ID and path if found, null otherwise
   */
  findIDByNameInHierarchy(
    hierarchy: WorkspaceTree,
    name: string,
    type: 'space' | 'folder' | 'list'
  ): { id: string; path: string } | null {
    const result = this.findNodeInTree(hierarchy.root, name, type);
    if (result) {
      return { id: result.node.id, path: result.path };
    }
    return null;
  }

  /**
   * Find a space ID by name
   * @param spaceName - The name of the space to find
   * @returns - Promise resolving to the space ID or null if not found
   */
  async findSpaceIDByName(spaceName: string): Promise<string | null> {
    const space = await this.findSpaceByName(spaceName);
    return space ? space.id : null;
  }

  /**
   * Get folderless lists from the API (lists that are directly in a space)
   * @param spaceId - The ID of the space
   * @returns - Promise resolving to array of lists
   */
  private async getFolderlessLists(spaceId: string): Promise<any[]> {
    try {
      const response = await this.makeRequest(async () => {
        const result = await this.client.get(`/space/${spaceId}/list`);
        return result.data;
      });
      return response.lists || [];
    } catch (error) {
      throw this.handleError(error, `Failed to get folderless lists for space ${spaceId}`);
    }
  }

  /**
   * Get lists in a space (not in any folder)
   * @param spaceId - The ID of the space
   * @returns - Promise resolving to array of lists
   */
  async getListsInSpace(spaceId: string): Promise<ClickUpList[]> {
    try {
      // The /space/{space_id}/list endpoint already returns folderless lists only
      const lists = await this.getFolderlessLists(spaceId);
      
      logger.debug(`Found ${lists.length} folderless lists in space ${spaceId}`);
      
      // Return all lists without filtering since the API already returns folderless lists
      return lists;
    } catch (error) {
      throw this.handleError(error, `Failed to get lists in space ${spaceId}`);
    }
  }

  /**
   * Get folders from the API
   * @param spaceId - The ID of the space
   * @returns - Promise resolving to array of folders
   */
  private async getFolders(spaceId: string): Promise<any[]> {
    try {
      const response = await this.makeRequest(async () => {
        const result = await this.client.get(`/space/${spaceId}/folder`);
        return result.data;
      });
      return response.folders || [];
    } catch (error) {
      throw this.handleError(error, `Failed to get folders for space ${spaceId}`);
    }
  }

  /**
   * Get a specific folder by ID
   * @param folderId - The ID of the folder to retrieve
   * @returns - Promise resolving to the folder
   */
  async getFolder(folderId: string): Promise<any> {
    try {
      return await this.makeRequest(async () => {
        const result = await this.client.get(`/folder/${folderId}`);
        return result.data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get folder with ID ${folderId}`);
    }
  }

  /**
   * Get folders in a space
   * @param spaceId - The ID of the space
   * @returns - Promise resolving to array of folders
   */
  async getFoldersInSpace(spaceId: string): Promise<ClickUpFolder[]> {
    try {
      return await this.getFolders(spaceId);
    } catch (error) {
      throw this.handleError(error, `Failed to get folders in space ${spaceId}`);
    }
  }

  /**
   * Get lists in a folder
   * @param folderId - The ID of the folder
   * @returns - Promise resolving to array of lists
   */
  async getListsInFolder(folderId: string): Promise<ClickUpList[]> {
    try {
      const response = await this.makeRequest(async () => {
        const result = await this.client.get(`/folder/${folderId}/list`);
        return result.data;
      });
      return response.lists || [];
    } catch (error) {
      throw this.handleError(error, `Failed to get lists in folder ${folderId}`);
    }
  }
}
</file>

<file path="src/services/shared.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Shared Services Module
 * 
 * This module maintains singleton instances of services that should be shared
 * across the application to ensure consistent state.
 */

import { createClickUpServices, ClickUpServices } from './clickup/index.js';
import config from '../config.js';
import { Logger } from '../logger.js';

const logger = new Logger('SharedServices');

// Singleton instances
let clickUpServicesInstance: ClickUpServices | null = null;

/**
 * Get or create the ClickUp services instance
 */
function getClickUpServices(): ClickUpServices {
  if (!clickUpServicesInstance) {
    logger.info('Creating shared ClickUp services singleton');
    
    // Create the services instance
    clickUpServicesInstance = createClickUpServices({
      apiKey: config.clickupApiKey,
      teamId: config.clickupTeamId
    });
    
    // Log what services were initialized with more clarity
    logger.info('Services initialization complete', { 
      services: Object.keys(clickUpServicesInstance).join(', '),
      teamId: config.clickupTeamId
    });
  }
  return clickUpServicesInstance;
}

// Create a single instance of ClickUp services to be shared
export const clickUpServices = getClickUpServices();

// Export individual services for convenience
export const {
  list: listService,
  task: taskService,
  folder: folderService,
  workspace: workspaceService,
  timeTracking: timeTrackingService,
  document: documentService
} = clickUpServices;
</file>

<file path="src/tools/task/index.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Task Tools
 * 
 * This module re-exports all task-related tools and handlers.
 */

// Re-export from main module
export * from './main.js';

// Re-export single task operation tools
export { 
  createTaskTool,
  getTaskTool,
  getTasksTool,
  updateTaskTool,
  moveTaskTool,
  duplicateTaskTool,
  deleteTaskTool,
  getTaskCommentsTool,
  createTaskCommentTool
} from './single-operations.js';

// Re-export bulk task operation tools
export {
  createBulkTasksTool,
  updateBulkTasksTool,
  moveBulkTasksTool,
  deleteBulkTasksTool
} from './bulk-operations.js';

// Re-export workspace task operation tools
export {
  getWorkspaceTasksTool
} from './workspace-operations.js';

// Re-export time tracking tools and handlers
export {
  getTaskTimeEntriesTool,
  startTimeTrackingTool,
  stopTimeTrackingTool,
  addTimeEntryTool,
  deleteTimeEntryTool,
  getCurrentTimeEntryTool,
  handleGetTaskTimeEntries,
  handleStartTimeTracking,
  handleStopTimeTracking,
  handleAddTimeEntry,
  handleDeleteTimeEntry,
  handleGetCurrentTimeEntry,
  timeTrackingTools,
  timeTrackingHandlers
} from './time-tracking.js';

// Re-export attachment tool
export {
  attachTaskFileTool,
  handleAttachTaskFile
} from './attachments.js';

// Re-export handlers
export {
  // Single task operation handlers
  createTaskHandler,
  getTaskHandler,
  getTasksHandler,
  updateTaskHandler,
  moveTaskHandler,
  duplicateTaskHandler,
  deleteTaskHandler,
  getTaskCommentsHandler,
  createTaskCommentHandler,
  
  // Bulk task operation handlers
  createBulkTasksHandler,
  updateBulkTasksHandler,
  moveBulkTasksHandler,
  deleteBulkTasksHandler,
  
  // Team task operation handlers
  getWorkspaceTasksHandler
} from './handlers.js';

// Re-export utilities
export {
  formatTaskData,
  validateTaskIdentification,
  validateListIdentification,
  validateTaskUpdateData,
  validateBulkTasks,
  parseBulkOptions,
  resolveListIdWithValidation
} from './utilities.js';
</file>

<file path="src/tools/task/workspace-operations.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Workspace Task Operations
 * 
 * This module defines tools for workspace-wide task operations, including
 * filtering tasks across the entire workspace with tag-based filtering.
 */

import { TaskFilters } from '../../services/clickup/types.js';

/**
 * Tool definition for getting workspace tasks
 */
export const getWorkspaceTasksTool = {
  name: "get_workspace_tasks",
  description: `Purpose: Retrieve tasks from across the entire workspace with powerful filtering options, including tag-based filtering.

Valid Usage:
1. Apply any combination of filters (tags, lists, folders, spaces, statuses, etc.)
2. Use pagination to manage large result sets

Requirements:
- At least one filter parameter is REQUIRED (tags, list_ids, folder_ids, space_ids, statuses, assignees, or date filters)
- Pagination parameters (page, order_by, reverse) alone are not considered filters

Notes:
- Provides workspace-wide task access (unlike get_tasks which only searches in one list)
- Returns complete task details including descriptions, assignees, custom fields, and all metadata
- Tag filtering is especially useful for cross-list organization (e.g., "project-x", "blocker", "needs-review")
- Combine multiple filters to narrow down your search scope
- Use pagination for large result sets
- Use the detail_level parameter to control the amount of data returned:
  - "summary": Returns lightweight task data (name, status, list, tags)
  - "detailed": Returns complete task data with all fields (DEFAULT if not specified)
- Responses exceeding 50,000 tokens automatically switch to summary format to avoid hitting LLM token limits
`,
  parameters: {
    type: 'object',
    properties: {
      tags: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by tag names. Only tasks with ALL specified tags will be returned.'
      },
      list_ids: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by list IDs. Narrows the search to specific lists.'
      },
      folder_ids: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by folder IDs. Narrows the search to specific folders.'
      },
      space_ids: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by space IDs. Narrows the search to specific spaces.'
      },
      statuses: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by status names (e.g., [\'To Do\', \'In Progress\']).'
      },
      assignees: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by assignee IDs.'
      },
      date_created_gt: {
        type: 'number',
        description: 'Filter for tasks created after this timestamp.'
      },
      date_created_lt: {
        type: 'number',
        description: 'Filter for tasks created before this timestamp.'
      },
      date_updated_gt: {
        type: 'number',
        description: 'Filter for tasks updated after this timestamp.'
      },
      date_updated_lt: {
        type: 'number',
        description: 'Filter for tasks updated before this timestamp.'
      },
      due_date_gt: {
        type: 'number',
        description: 'Filter for tasks with due date greater than this timestamp.'
      },
      due_date_lt: {
        type: 'number',
        description: 'Filter for tasks with due date less than this timestamp.'
      },
      include_closed: {
        type: 'boolean',
        description: 'Include closed tasks in the results.'
      },
      include_archived_lists: {
        type: 'boolean',
        description: 'Include tasks from archived lists.'
      },
      include_closed_lists: {
        type: 'boolean',
        description: 'Include tasks from closed lists.'
      },
      archived: {
        type: 'boolean',
        description: 'Include archived tasks in the results.'
      },
      order_by: {
        type: 'string',
        enum: ['id', 'created', 'updated', 'due_date'],
        description: 'Sort field for ordering results.'
      },
      reverse: {
        type: 'boolean',
        description: 'Reverse sort order (descending).'
      },
      page: {
        type: 'number',
        description: 'Page number for pagination (0-based).'
      },
      detail_level: {
        type: 'string',
        enum: ['summary', 'detailed'],
        description: 'Level of detail to return. Use summary for lightweight responses or detailed for full task data. If not specified, defaults to "detailed".'
      }
    }
  },
  inputSchema: {
    type: 'object',
    properties: {
      tags: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by tag names. Only tasks with ALL specified tags will be returned.'
      },
      list_ids: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by list IDs. Narrows the search to specific lists.'
      },
      folder_ids: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by folder IDs. Narrows the search to specific folders.'
      },
      space_ids: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by space IDs. Narrows the search to specific spaces.'
      },
      statuses: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by status names (e.g., [\'To Do\', \'In Progress\']).'
      },
      assignees: {
        type: 'array',
        items: { type: 'string' },
        description: 'Filter tasks by assignee IDs.'
      },
      date_created_gt: {
        type: 'number',
        description: 'Filter for tasks created after this timestamp.'
      },
      date_created_lt: {
        type: 'number',
        description: 'Filter for tasks created before this timestamp.'
      },
      date_updated_gt: {
        type: 'number',
        description: 'Filter for tasks updated after this timestamp.'
      },
      date_updated_lt: {
        type: 'number',
        description: 'Filter for tasks updated before this timestamp.'
      },
      due_date_gt: {
        type: 'number',
        description: 'Filter for tasks with due date greater than this timestamp.'
      },
      due_date_lt: {
        type: 'number',
        description: 'Filter for tasks with due date less than this timestamp.'
      },
      include_closed: {
        type: 'boolean',
        description: 'Include closed tasks in the results.'
      },
      include_archived_lists: {
        type: 'boolean',
        description: 'Include tasks from archived lists.'
      },
      include_closed_lists: {
        type: 'boolean',
        description: 'Include tasks from closed lists.'
      },
      archived: {
        type: 'boolean',
        description: 'Include archived tasks in the results.'
      },
      order_by: {
        type: 'string',
        enum: ['id', 'created', 'updated', 'due_date'],
        description: 'Sort field for ordering results.'
      },
      reverse: {
        type: 'boolean',
        description: 'Reverse sort order (descending).'
      },
      page: {
        type: 'number',
        description: 'Page number for pagination (0-based).'
      },
      detail_level: {
        type: 'string',
        enum: ['summary', 'detailed'],
        description: 'Level of detail to return. Use summary for lightweight responses or detailed for full task data. If not specified, defaults to "detailed".'
      }
    }
  }
};
</file>

<file path="src/tools/folder.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Folder Tools
 * 
 * This module defines folder-related tools for creating, retrieving,
 * updating, and deleting folders in the ClickUp workspace hierarchy.
 */

import { 
  CreateFolderData, 
  ClickUpFolder
} from '../services/clickup/types.js';
import { clickUpServices } from '../services/shared.js';
import config from '../config.js';
import { sponsorService } from '../utils/sponsor-service.js';

// Use shared services instance
const { folder: folderService, workspace: workspaceService } = clickUpServices;

/**
 * Tool definition for creating a folder
 */
export const createFolderTool = {
  name: "create_folder",
  description: `Creates folder in ClickUp space. Use spaceId (preferred) or spaceName + folder name. Optional: override_statuses for folder-specific statuses. Use create_list_in_folder to add lists after creation.`,
  inputSchema: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "Name of the folder"
      },
      spaceId: {
        type: "string",
        description: "ID of the space to create the folder in (preferred). Use this instead of spaceName if you have it."
      },
      spaceName: {
        type: "string",
        description: "Name of the space to create the folder in. Only use if you don't have spaceId."
      },
      override_statuses: {
        type: "boolean",
        description: "Whether to override space statuses with folder-specific statuses"
      }
    },
    required: ["name"]
  }
};

/**
 * Tool definition for retrieving folder details
 */
export const getFolderTool = {
  name: "get_folder",
  description: `Gets folder details. Use folderId (preferred) or folderName + (spaceId/spaceName). Helps understand folder structure before creating/updating lists.`,
  inputSchema: {
    type: "object",
    properties: {
      folderId: {
        type: "string",
        description: "ID of folder to retrieve (preferred). Use this instead of folderName if you have it."
      },
      folderName: {
        type: "string",
        description: "Name of folder to retrieve. When using this, you MUST also provide spaceId or spaceName."
      },
      spaceId: {
        type: "string",
        description: "ID of space containing the folder (required with folderName). Use this instead of spaceName if you have it."
      },
      spaceName: {
        type: "string",
        description: "Name of space containing the folder (required with folderName). Only use if you don't have spaceId."
      }
    },
    required: []
  }
};

/**
 * Tool definition for updating a folder
 */
export const updateFolderTool = {
  name: "update_folder",
  description: `Updates folder properties. Use folderId (preferred) or folderName + (spaceId/spaceName). At least one update field (name/override_statuses) required. Changes apply to all lists in folder.`,
  inputSchema: {
    type: "object",
    properties: {
      folderId: {
        type: "string",
        description: "ID of folder to update (preferred). Use this instead of folderName if you have it."
      },
      folderName: {
        type: "string",
        description: "Name of folder to update. When using this, you MUST also provide spaceId or spaceName."
      },
      spaceId: {
        type: "string",
        description: "ID of space containing the folder (required with folderName). Use this instead of spaceName if you have it."
      },
      spaceName: {
        type: "string",
        description: "Name of space containing the folder (required with folderName). Only use if you don't have spaceId."
      },
      name: {
        type: "string",
        description: "New name for the folder"
      },
      override_statuses: {
        type: "boolean",
        description: "Whether to override space statuses with folder-specific statuses"
      }
    },
    required: []
  }
};

/**
 * Tool definition for deleting a folder
 */
export const deleteFolderTool = {
  name: "delete_folder",
  description: `PERMANENTLY deletes folder and all contents. Use folderId (preferred/safest) or folderName + (spaceId/spaceName). WARNING: Cannot be undone, all lists/tasks deleted, folderName risky if not unique.`,
  inputSchema: {
    type: "object",
    properties: {
      folderId: {
        type: "string",
        description: "ID of folder to delete (preferred). Use this instead of folderName for safety."
      },
      folderName: {
        type: "string",
        description: "Name of folder to delete. When using this, you MUST also provide spaceId or spaceName."
      },
      spaceId: {
        type: "string",
        description: "ID of space containing the folder (required with folderName). Use this instead of spaceName if you have it."
      },
      spaceName: {
        type: "string",
        description: "Name of space containing the folder (required with folderName). Only use if you don't have spaceId."
      }
    },
    required: []
  }
};

/**
 * Handler for the create_folder tool
 * Creates a new folder in a space
 */
export async function handleCreateFolder(parameters: any) {
  const { name, spaceId, spaceName, override_statuses } = parameters;
  
  // Validate required fields
  if (!name) {
    throw new Error("Folder name is required");
  }
  
  let targetSpaceId = spaceId;
  
  // If no spaceId but spaceName is provided, look up the space ID
  if (!targetSpaceId && spaceName) {
    const spaceIdResult = await workspaceService.findSpaceByName(spaceName);
    if (!spaceIdResult) {
      throw new Error(`Space "${spaceName}" not found`);
    }
    targetSpaceId = spaceIdResult.id;
  }
  
  if (!targetSpaceId) {
    throw new Error("Either spaceId or spaceName must be provided");
  }

  // Prepare folder data
  const folderData: CreateFolderData = {
    name
  };

  // Add optional fields if provided
  if (override_statuses !== undefined) folderData.override_statuses = override_statuses;

  try {
    // Create the folder
    const newFolder = await folderService.createFolder(targetSpaceId, folderData);
    
    return sponsorService.createResponse({
      id: newFolder.id,
      name: newFolder.name,
      space: {
        id: newFolder.space.id,
        name: newFolder.space.name
      },
      message: `Folder "${newFolder.name}" created successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to create folder: ${error.message}`);
  }
}

/**
 * Handler for the get_folder tool
 * Retrieves details about a specific folder
 */
export async function handleGetFolder(parameters: any) {
  const { folderId, folderName, spaceId, spaceName } = parameters;
  
  let targetFolderId = folderId;
  
  // If no folderId provided but folderName is, look up the folder ID
  if (!targetFolderId && folderName) {
    let targetSpaceId = spaceId;
    
    // If no spaceId provided but spaceName is, look up the space ID first
    if (!targetSpaceId && spaceName) {
      const spaceIdResult = await workspaceService.findSpaceByName(spaceName);
      if (!spaceIdResult) {
        throw new Error(`Space "${spaceName}" not found`);
      }
      targetSpaceId = spaceIdResult.id;
    }
    
    if (!targetSpaceId) {
      throw new Error("Either spaceId or spaceName must be provided when using folderName");
    }
    
    const folderResult = await folderService.findFolderByName(targetSpaceId, folderName);
    if (!folderResult) {
      throw new Error(`Folder "${folderName}" not found in space`);
    }
    targetFolderId = folderResult.id;
  }
  
  if (!targetFolderId) {
    throw new Error("Either folderId or folderName must be provided");
  }

  try {
    // Get the folder
    const folder = await folderService.getFolder(targetFolderId);
    
    return sponsorService.createResponse({
      id: folder.id,
      name: folder.name,
      space: {
        id: folder.space.id,
        name: folder.space.name
      }
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to retrieve folder: ${error.message}`);
  }
}

/**
 * Handler for the update_folder tool
 * Updates an existing folder's properties
 */
export async function handleUpdateFolder(parameters: any) {
  const { folderId, folderName, name, override_statuses, spaceId, spaceName } = parameters;
  
  let targetFolderId = folderId;
  
  // If no folderId provided but folderName is, look up the folder ID
  if (!targetFolderId && folderName) {
    let targetSpaceId = spaceId;
    
    // If no spaceId provided but spaceName is, look up the space ID first
    if (!targetSpaceId && spaceName) {
      const spaceIdResult = await workspaceService.findSpaceByName(spaceName);
      if (!spaceIdResult) {
        throw new Error(`Space "${spaceName}" not found`);
      }
      targetSpaceId = spaceIdResult.id;
    }
    
    if (!targetSpaceId) {
      throw new Error("Either spaceId or spaceName must be provided when using folderName");
    }
    
    const folderResult = await folderService.findFolderByName(targetSpaceId, folderName);
    if (!folderResult) {
      throw new Error(`Folder "${folderName}" not found in space`);
    }
    targetFolderId = folderResult.id;
  }
  
  if (!targetFolderId) {
    throw new Error("Either folderId or folderName must be provided");
  }
  
  // Ensure at least one update field is provided
  if (!name && override_statuses === undefined) {
    throw new Error("At least one of name or override_statuses must be provided for update");
  }

  // Prepare update data
  const updateData: Partial<CreateFolderData> = {};
  if (name) updateData.name = name;
  if (override_statuses !== undefined) updateData.override_statuses = override_statuses;

  try {
    // Update the folder
    const updatedFolder = await folderService.updateFolder(targetFolderId, updateData);
    
    return sponsorService.createResponse({
      id: updatedFolder.id,
      name: updatedFolder.name,
      space: {
        id: updatedFolder.space.id,
        name: updatedFolder.space.name
      },
      message: `Folder "${updatedFolder.name}" updated successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to update folder: ${error.message}`);
  }
}

/**
 * Handler for the delete_folder tool
 * Permanently removes a folder from the workspace
 */
export async function handleDeleteFolder(parameters: any) {
  const { folderId, folderName, spaceId, spaceName } = parameters;
  
  let targetFolderId = folderId;
  
  // If no folderId provided but folderName is, look up the folder ID
  if (!targetFolderId && folderName) {
    let targetSpaceId = spaceId;
    
    // If no spaceId provided but spaceName is, look up the space ID first
    if (!targetSpaceId && spaceName) {
      const spaceIdResult = await workspaceService.findSpaceByName(spaceName);
      if (!spaceIdResult) {
        throw new Error(`Space "${spaceName}" not found`);
      }
      targetSpaceId = spaceIdResult.id;
    }
    
    if (!targetSpaceId) {
      throw new Error("Either spaceId or spaceName must be provided when using folderName");
    }
    
    const folderResult = await folderService.findFolderByName(targetSpaceId, folderName);
    if (!folderResult) {
      throw new Error(`Folder "${folderName}" not found in space`);
    }
    targetFolderId = folderResult.id;
  }
  
  if (!targetFolderId) {
    throw new Error("Either folderId or folderName must be provided");
  }

  try {
    // Get folder details before deletion for confirmation message
    const folder = await folderService.getFolder(targetFolderId);
    const folderName = folder.name;
    
    // Delete the folder
    await folderService.deleteFolder(targetFolderId);
    
    return sponsorService.createResponse({
      success: true,
      message: `Folder "${folderName || targetFolderId}" deleted successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to delete folder: ${error.message}`);
  }
}
</file>

<file path="src/utils/sponsor-service.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Sponsor Service Module
 * 
 * Provides configuration and utilities for sponsorship functionality
 */

import { Logger } from '../logger.js';
import config from '../config.js';

// Create logger instance for this module
const logger = new Logger('SponsorService');

/**
 * SponsorService - Provides sponsorship configuration and message handling
 */
export class SponsorService {
  private isEnabled: boolean;
  private readonly sponsorUrl: string = 'https://github.com/sponsors/taazkareem';
  
  constructor() {
    this.isEnabled = config.enableSponsorMessage;
    logger.info('SponsorService initialized', { enabled: this.isEnabled });
  }
  
  /**
   * Get sponsor information (for documentation/reference purposes)
   */
  public getSponsorInfo(): { isEnabled: boolean; url: string } {
    return {
      isEnabled: this.isEnabled,
      url: this.sponsorUrl
    };
  }

  /**
   * Creates a response with optional sponsorship message
   */
  public createResponse(data: any, includeSponsorMessage: boolean = false): { content: { type: string; text: string }[] } {
    const content: { type: string; text: string }[] = [];
    
    // Special handling for workspace hierarchy which contains a preformatted tree
    if (data && typeof data === 'object' && 'hierarchy' in data && typeof data.hierarchy === 'string') {
      // Handle workspace hierarchy specially - it contains a preformatted tree
      content.push({
        type: "text",
        text: data.hierarchy
      });
    } else if (typeof data === 'string') {
      // If it's already a string, use it directly
      content.push({
        type: "text",
        text: data
      });
    } else {
      // Otherwise, stringify the JSON object
      content.push({
        type: "text",
        text: JSON.stringify(data, null, 2)
      });
    }
    
    // Then add sponsorship message if enabled
    if (this.isEnabled && includeSponsorMessage) {
      content.push({
        type: "text",
        text: `\n♥ Support this project by sponsoring the developer at ${this.sponsorUrl}`
      });
    }
    
    
    return { content };
  }

  /**
   * Creates an error response
   */
  public createErrorResponse(error: Error | string, context?: any): { content: { type: string; text: string }[] } {
    return this.createResponse({
      error: typeof error === 'string' ? error : error.message,
      ...context
    });
  }

  /**
   * Creates a bulk operation response with sponsorship message
   */
  public createBulkResponse(result: any): { content: { type: string; text: string }[] } {
    return this.createResponse({
      success: true,
      total: result.totals.total,
      successful: result.totals.success,
      failed: result.totals.failure,
      failures: result.failed.map((failure: any) => ({
        id: failure.item?.id || failure.item,
        error: failure.error.message
      }))
    }, true); // Always include sponsor message for bulk operations
  }
}

// Export a singleton instance
export const sponsorService = new SponsorService();
</file>

<file path="docs/api-reference.md">
# ClickUp MCP Server Documentation

This document provides detailed information about all available tools, their parameters, and usage examples for the ClickUp MCP Server.

## Table of Contents
- [Task Management](#task-management)
- [List Management](#list-management)
- [Folder Management](#folder-management)
- [Tag Management](#tag-management)
- [Workspace Organization](#workspace-organization)
- [Prompts](#prompts)
- [Common Parameters](#common-parameters)
- [Error Handling](#error-handling)

## Task Management

| Tool | Description | Required Parameters | Optional Parameters |
|------|-------------|-------------------|-------------------|
| get_tasks | Retrieve tasks from a list | Either `listId` or `listName` | archived, page, order_by, reverse, subtasks, statuses, include_closed, assignees, due_date_gt/lt |
| get_task | Get single task details with global lookup | Either `taskId` or `taskName` (list context optional) | `listName` (for disambiguation), `subtasks` |
| get_task_comments | Retrieve comments for a task | Either `taskId` or `taskName` | `listName`, `start`, `startId` |
| create_task_comment | Add a comment to a task | `commentText` and either `taskId` or (`taskName` + `listName`) | `notifyAll`, `assignee` |
| attach_task_file | Attach a file to a task | Either `taskId` or `taskName`, and EITHER `file_data` OR `file_url` | `file_name`, `chunk_*` parameters for large files |
| create_task | Create a new task | `name` and either `listId` or `listName` | description, status, priority (1-4), dueDate, startDate, parent |
| create_bulk_tasks | Create multiple tasks | `tasks[]` | `listId` or `listName` |
| update_task | Modify task properties | Either `taskId` or `taskName` | name, description, status, priority, dueDate, startDate |
| update_bulk_tasks | Modify multiple tasks | `tasks[]` with task identifiers | Each task can have: name, description, status, priority, dueDate, startDate, etc. |
| delete_task | Remove a task | `taskId` | `taskName`, `listName` |
| delete_bulk_tasks | Remove multiple tasks | `tasks[]` with task identifiers | None |
| move_task | Move task to another list | Either `taskId` or `taskName`, and either `listId` or `listName` | `sourceListName` |
| move_bulk_tasks | Move multiple tasks | `tasks[]` with task identifiers, and target list | None |
| duplicate_task | Copy task to another list | Either `taskId` or `taskName`, and either `listId` or `listName` | `sourceListName` |
| get_workspace_tasks | Retrieve tasks across the workspace with filtering | At least one filter parameter (tags, list_ids, folder_ids, space_ids, statuses, assignees, or date filters) | page, order_by, reverse |

### Task Parameters

- **Priority Levels**: 1 (Urgent/Highest) to 4 (Low)
- **Dates**: Unix timestamps in milliseconds
- **Status**: Uses list's default if not specified
- **Description**: Supports both plain text and markdown
- **Files**: Attach files using base64 encoding or URLs
- **Subtasks**: 
  - Retrieve subtasks with `subtasks: true` parameter on `get_task` or `get_tasks`
  - Create subtasks by setting `parent` parameter with parent task ID on `create_task`
  - Multi-level subtasks are supported (subtasks can have their own subtasks)
- **Date Parameters**:
  - `dueDate`: When the task is due (deadline)
  - `startDate`: When work on the task should begin
  - Both support natural language expressions (e.g., "now", "today", "tomorrow at 9am")
  - Date ranges can be specified using `start of today` and `end of today`
- **Global Task Lookup**:
  - Find tasks by name across the entire workspace without specifying a list
  - Smart disambiguation when multiple tasks share the same name
  - Shows context (list, folder, space) for each matching task
  - Prioritizes most recently updated task when multiple matches exist
  - Backward compatible with list-specific lookups

### Examples

#### Creating a Task
**User Prompt:**
```
Create a new task in the "Development Tasks" list called "Implement Authentication". 
It should be high priority and due on January 1st, 2024. 
Add these requirements:
- OAuth2 support
- JWT tokens
- Refresh token flow
```

**System Response:**
```json
{
  "listName": "Development Tasks",
  "name": "Implement Authentication",
  "markdown_description": "## Requirements\n- OAuth2 support\n- JWT tokens\n- Refresh token flow",
  "priority": 1,
  "dueDate": 1703980800000
}
```

#### Creating a Task with Start Date and Due Date
**User Prompt:**
```
Create a task called "Database Migration" that starts tomorrow at 9am and is due by the end of the week.
It should be in the "Backend Tasks" list.
```

**System Response:**
```json
{
  "listName": "Backend Tasks",
  "name": "Database Migration",
  "startDate": "tomorrow at 9am",
  "dueDate": "end of week"
}
```

#### Updating a Task's Start Date
**User Prompt:**
```
Change the start date of the "Database Migration" task to next Monday at 8am
```

**System Response:**
```json
{
  "taskName": "Database Migration",
  "startDate": "next Monday at 8am"
}
```

#### Getting Task Comments
**User Prompt:**
```
Show me the comments on the "Bug Fix" task.
```

**System Response:**
```json
{
  "taskName": "Bug Fix",
  "comments": [
    {
      "id": "abcd1234",
      "comment": "I've identified the root cause. It's related to a race condition in the auth flow.",
      "comment_text": "I've identified the root cause. It's related to a race condition in the auth flow.",
      "user": {
        "id": 1234567,
        "username": "developer1",
        "email": "dev1@example.com",
        "color": "#ff7800"
      },
      "resolved": false,
      "date": "2024-03-15T10:30:45.000Z"
    },
    {
      "id": "efgh5678",
      "comment": "Great work! Could you submit a PR by tomorrow?",
      "comment_text": "Great work! Could you submit a PR by tomorrow?",
      "user": {
        "id": 7654321,
        "username": "manager1",
        "email": "manager@example.com",
        "color": "#0080ff"
      },
      "resolved": false,
      "date": "2024-03-15T11:15:20.000Z"
    }
  ],
  "totalComments": 2,
  "pagination": {
    "hasMore": false
  }
}
```

#### Creating a Task Comment
**User Prompt:**
```
Add a comment to the "Bug Fix" task saying "I've fixed the issue by implementing proper mutex locks."
```

**System Response:**
```json
{
  "success": true,
  "message": "Comment added successfully",
  "comment": {
    "id": "ijkl9012",
    "comment": "I've fixed the issue by implementing proper mutex locks.",
    "comment_text": "I've fixed the issue by implementing proper mutex locks.",
    "user": {
      "id": 1234567,
      "username": "developer1",
      "email": "dev1@example.com",
      "color": "#ff7800"
    },
    "date": "2024-03-16T09:45:30.000Z",
    "resolved": false
  }
}
```

#### Moving a Task
**User Prompt:**
```
Move the "Bug Fix" task from the "Sprint Backlog" list to "Current Sprint" list
```

**System Response:**
```json
{
  "taskName": "Bug Fix",
  "sourceListName": "Sprint Backlog",
  "destinationListName": "Current Sprint"
}
```

#### Global Task Lookup
**User Prompt:**
```
Get details for task "Roadmap Planning"
```

**System Response:**
```json
{
  "taskName": "Roadmap Planning"
}
```

**Response for Multiple Matches:**
```json
{
  "matches": [
    {
      "id": "abc123",
      "name": "🌐 Website Update",
      "description": "First instance of Website Update task in Programming list",
      "list": {
        "name": "Programming",
        "id": "123"
      },
      "folder": {
        "name": "Development",
        "id": "456"
      },
      "space": {
        "name": "Education",
        "id": "789"
      },
      "date_updated": "2024-03-15T10:30:45.000Z"
    },
    {
      "id": "def456",
      "name": "🌐 Website Update",
      "description": "Second instance of Website Update task in AI Assistant App list",
      "list": {
        "name": "AI Assistant App",
        "id": "234"
      },
      "folder": {
        "name": "Macrodroid",
        "id": "567"
      },
      "space": {
        "name": "Custom Space",
        "id": "890"
      },
      "date_updated": "2024-03-10T11:15:20.000Z"
    }
  ],
  "count": 2
}
```

**For Disambiguation Resolution:**
```
Get details for task "Website Update" in list "AI Assistant App"
```

#### Updating Task Status
**User Prompt:**
```
Update the "Bug Fix" task status to "Done"
```

**System Response:**
```json
{
  "taskName": "Bug Fix",
  "status": "Done"
}
```

#### Bulk Creating Tasks
**User Prompt:**
```
Create these tasks in the "Sprint Backlog" list:
1. Set up CI/CD pipeline (high priority)
2. Write unit tests (normal priority)
3. Update documentation (low priority)
```

**System Response:**
```json
{
  "listName": "Sprint Backlog",
  "tasks": [
    {
      "name": "Set up CI/CD pipeline",
      "priority": 2
    },
    {
      "name": "Write unit tests",
      "priority": 3
    },
    {
      "name": "Update documentation",
      "priority": 4
    }
  ]
}
```

#### Bulk Creating Tasks with Start and Due Dates
**User Prompt:**
```
Create these tasks in the "Project X" list:
1. Research - starts today, due in 3 days
2. Design - starts after Research ends, due in a week from start
3. Implementation - starts after Design, due in 2 weeks from start
```

**System Response:**
```json
{
  "listName": "Project X",
  "tasks": [
    {
      "name": "Research",
      "startDate": "today",
      "dueDate": "3 days from now"
    },
    {
      "name": "Design",
      "startDate": "4 days from now", 
      "dueDate": "11 days from now"
    },
    {
      "name": "Implementation",
      "startDate": "12 days from now",
      "dueDate": "26 days from now"
    }
  ]
}
```

#### Filtering Tasks by Tags
**User Prompt:**
```
Find all tasks with the tags "bug" and "high-priority" across the workspace
```

**System Response:**
```json
{
  "name": "get_workspace_tasks",
  "params": {
    "tags": ["bug", "high-priority"],
    "include_closed": false
  },
  "response": {
    "tasks": [
      {
        "id": "abcd1234",
        "name": "Fix authentication bug",
        "description": "Detailed bug description...",
        "text_content": "Plain text version...",
        "status": {
          "status": "In Progress",
          "color": "#f1c975"
        },
        "creator": {
          "id": 123,
          "username": "dev1",
          "email": "dev1@example.com"
        },
        "assignees": [
          {
            "id": 456,
            "username": "dev2",
            "email": "dev2@example.com"
          }
        ],
        "watchers": [...],
        "checklists": [...],
        "custom_fields": [...],
        "list": {
          "id": "list123",
          "name": "Current Sprint"
        },
        "tags": [
          {
            "name": "bug",
            "tag_bg": "#e50000",
            "tag_fg": "#ffffff"
          },
          {
            "name": "high-priority",
            "tag_bg": "#ff7800",
            "tag_fg": "#ffffff"
          }
        ]
      }
    ],
    "count": 1
  }
}
```

#### Adaptive Response Format in Workspace Tasks

The `get_workspace_tasks` tool offers two response formats to optimize for different use cases:

1. **Summary Format** (`detail_level: 'summary'`):
   - Lightweight response with essential task information
   - Ideal for lists, overviews, and large datasets
   - Includes: id, name, status, list info, due date, URL, priority, and tags
   - Automatically used when response size exceeds 50,000 tokens

2. **Detailed Format** (`detail_level: 'detailed'`):
   - Complete task information including all fields
   - Best for detailed views and task management
   - Includes: all task data, custom fields, descriptions, comments, etc.

Example using summary format:
```json
{
  "summaries": [
    {
      "id": "123abc",
      "name": "🎯 Important Task",
      "status": "in progress",
      "list": {
        "id": "456def",
        "name": "Project Alpha"
      },
      "due_date": "2024-03-20T10:00:00Z",
      "url": "https://app.clickup.com/t/123abc",
      "priority": 1,
      "tags": [
        {
          "name": "urgent",
          "tag_bg": "#ff0000",
          "tag_fg": "#ffffff"
        }
      ]
    }
  ],
  "total_count": 100,
  "has_more": true,
  "next_page": 1
}
```

Example using detailed format:
```json
{
  "tasks": [
    {
      // Full task object with all fields
      "id": "123abc",
      "name": "🎯 Important Task",
      "description": "Detailed task description...",
      "status": {
        "status": "in progress",
        "color": "#4A90E2"
      },
      "custom_fields": [...],
      "assignees": [...],
      "watchers": [...],
      "checklists": [...],
      // ... all other task fields
    }
  ],
  "total_count": 100,
  "has_more": true,
  "next_page": 1
}
```

##### Best Practices for Workspace Tasks

1. **Use Filters**: At least one filter parameter is required to prevent overly broad queries:
   - `tags`: Filter by tag names
   - `list_ids`: Filter by specific lists
   - `folder_ids`: Filter by folders
   - `space_ids`: Filter by spaces
   - `statuses`: Filter by task status
   - `assignees`: Filter by assigned users
   - Date filters: `due_date_gt`, `due_date_lt`, etc.

2. **Pagination**: Use `page`, `order_by`, and `reverse` parameters to navigate through results:
   ```json
   {
     "list_ids": ["123"],
     "page": 0,
     "order_by": "due_date",
     "reverse": true
   }
   ```

3. **Response Size**: For large datasets:
   - Use `detail_level: 'summary'` to get lightweight responses
   - The tool automatically switches to summary format if response exceeds 50,000 tokens
   - Use filters to narrow down results

4. **Adaptive Response Pattern**:
   1. Fetch summaries first for list views
   2. Load details on-demand when viewing specific tasks
   3. Use pagination to load more items as needed

#### Bulk Updating Tasks
**User Prompt:**
```
Update all the following tasks to high priority:
1. "Implement login screen"
2. "Create database schema"
3. "Set up CI pipeline"
```

**System Response:**
```json
{
  "tasks": [
    {
      "taskName": "Implement login screen",
      "listName": "Development Tasks",
      "priority": 2
    },
    {
      "taskName": "Create database schema",
      "listName": "Development Tasks",
      "priority": 2
    },
    {
      "taskName": "Set up CI pipeline",
      "listName": "Development Tasks",
      "priority": 2
    }
  ]
}
```

#### Bulk Updating Tasks with Start Dates
**User Prompt:**
```
Update these tasks to have new start dates:
1. "Research" should start now
2. "Design" should start after "Research" is done (3 days from now)
3. "Implementation" should start next week
```

**System Response:**
```json
{
  "tasks": [
    {
      "taskName": "Research",
      "listName": "Project X",
      "startDate": "now"
    },
    {
      "taskName": "Design",
      "listName": "Project X",
      "startDate": "3 days from now"
    },
    {
      "taskName": "Implementation",
      "listName": "Project X",
      "startDate": "next week"
    }
  ]
}
```

#### Bulk Moving Tasks
**User Prompt:**
```
Move all the completed tasks from "In Progress" list to "Done" list:
1. "Backend API implementation"
2. "Frontend form validation"
```

**System Response:**
```json
{
  "tasks": [
    {
      "taskName": "Backend API implementation",
      "listName": "In Progress"
    },
    {
      "taskName": "Frontend form validation",
      "listName": "In Progress"
    }
  ],
  "targetListName": "Done"
}
```

#### Bulk Deleting Tasks
**User Prompt:**
```
Delete all these tasks from the "Archived" list:
1. "Outdated feature"
2. "Duplicate bug report"
```

**System Response:**
```json
{
  "tasks": [
    {
      "taskName": "Outdated feature",
      "listName": "Archived"
    },
    {
      "taskName": "Duplicate bug report",
      "listName": "Archived"
    }
  ]
}
```

#### Attaching a File to a Task
**User Prompt:**
```
Attach a file to the task "Implement Authentication". The file is at URL "https://example.com/files/specs.pdf"
```

**System Response:**
```json
{
  "taskName": "Implement Authentication",
  "file_url": "https://example.com/files/specs.pdf",
  "file_name": "specs.pdf"
}
```

**User Prompt:**
```
Attach this document to the task with ID 86b4bnnny
```

**System Response:**
```json
{
  "taskId": "86b4bnnny",
  "file_data": "<base64-encoded-content>",
  "file_name": "document.txt"
}
```

#### Handling Different File Types
The attach_task_file tool supports various file types including:
- Documents (PDF, DOCX, TXT)
- Images (PNG, JPG, SVG)
- Data files (CSV, JSON)
- And many others

Files can be attached using either:
1. **Base64 Method**: For small files (using `file_data` parameter)
2. **URL Method**: For files already available online (using `file_url` parameter)
3. **Local File Path**: For files on the local filesystem (using `file_url` parameter with an absolute file path)
4. **Chunked Upload**: For large files (automatically selected for `file_data` > 10MB)

#### Retrieving Tasks with Subtasks
**User Prompt:**
```
Get the "Project Planning" task with all its subtasks
```

**System Response:**
```json
{
  "taskName": "Project Planning",
  "subtasks": true
}
```

**Response will include:**
```json
{
  "id": "abc123",
  "name": "Project Planning",
  "description": "Plan the new project phase",
  "subtasks": [
    {
      "id": "def456",
      "name": "Define Requirements",
      "parent": "abc123",
      "top_level_parent": "abc123"
    },
    {
      "id": "ghi789",
      "name": "Create Timeline",
      "parent": "abc123",
      "top_level_parent": "abc123"
    }
  ]
}
```

#### Creating a Subtask
**User Prompt:**
```
Create a subtask under "Project Planning" called "Schedule Team Meeting"
```

**System Response:**
```json
{
  "name": "Schedule Team Meeting",
  "parent": "abc123",
  "listName": "Development Tasks"
}
```

#### Natural Language Date Support

The server supports a wide range of natural language date expressions:

1. **Basic expressions**:
   - "now" - current date and time
   - "today" - end of current day
   - "tomorrow" - end of tomorrow
   - "next week" - end of next week
   - "in 3 days" - 3 days from current time

2. **Time-specific expressions**:
   - "tomorrow at 9am"
   - "next Monday at 2pm"
   - "Friday at noon"

3. **Range expressions**:
   - "start of today" - beginning of current day (midnight)
   - "end of today" - end of current day (23:59:59)
   - "beginning of next week"
   - "end of this month"

4. **Relative expressions**:
   - "30 minutes from now"
   - "2 hours from now"
   - "5 days after tomorrow"

These expressions can be used with both `dueDate` and `startDate` parameters.

## List Management

| Tool | Description | Required Parameters | Optional Parameters |
|------|-------------|-------------------|-------------------|
| create_list | Create a new list | `name` and either `spaceId` or `spaceName` | content, dueDate, priority, assignee |
| create_list_in_folder | Create list in folder | `name` and either `folderId` or `folderName` | content, status |
| get_list | Get list details | Either `listId` or `listName` | None |
| update_list | Update list properties | Either `listId` or `listName` | name, content, status |
| delete_list | Delete a list | Either `listId` or `listName` | None |

### List Parameters

- **Content**: Description or purpose of the list
- **Priority**: Same scale as tasks (1-4)
- **Status**: Initial status for the list

### Examples

#### Getting List Details
**User Prompt:**
```
Get details for the "Sprint Backlog" list
```

**System Response:**
```json
{
  "listName": "Sprint Backlog"
}
```

#### Updating a List
**User Prompt:**
```
Update the "Sprint Backlog" list to have the description "Current sprint planning items and priorities"
```

**System Response:**
```json
{
  "listName": "Sprint Backlog",
  "content": "Current sprint planning items and priorities"
}
```

## Folder Management

| Tool | Description | Required Parameters | Optional Parameters |
|------|-------------|-------------------|-------------------|
| create_folder | Create a new folder | `name` and either `spaceId` or `spaceName` | override_statuses |
| get_folder | Get folder details | Either `folderId` or `folderName` | `spaceId` or `spaceName` (if using `folderName`) |
| update_folder | Update folder properties | Either `folderId` or `folderName` | name, override_statuses, `spaceId` or `spaceName` (if using `folderName`) |
| delete_folder | Delete a folder | Either `folderId` or `folderName` | `spaceId` or `spaceName` (if using `folderName`) |

### Folder Parameters

- **override_statuses**: Boolean to determine if folder should use custom statuses
- **name**: Display name for the folder

### Examples

#### Getting Folder Details
**User Prompt:**
```
Get details for the "Development Projects" folder
```

**System Response:**
```json
{
  "folderName": "Development Projects"
}
```

#### Updating a Folder
**User Prompt:**
```
Update the "Development Projects" folder to be named "Active Development Projects"
```

**System Response:**
```json
{
  "folderName": "Development Projects",
  "name": "Active Development Projects"
}
```

## Tag Management

| Tool | Description | Required Parameters | Optional Parameters |
|------|-------------|-------------------|-------------------|
| get_space_tags | Get all tags in a space | Either `spaceId` or `spaceName` | None |
| create_space_tag | Create a new tag | `tagName` and either `spaceId` or `spaceName` | `tagBg` (hex color), `tagFg` (hex color), `colorCommand` (natural language) |
| update_space_tag | Update an existing tag | `tagName` and either `spaceId` or `spaceName` | `newTagName`, `tagBg`, `tagFg`, `colorCommand` (natural language) |
| delete_space_tag | Delete a tag | `tagName` and either `spaceId` or `spaceName` | None |
| add_tag_to_task | Add tag to a task | `tagName` and either `taskId` or (`taskName` + `listName`) | None |
| remove_tag_from_task | Remove tag from task | `tagName` and either `taskId` or (`taskName` + `listName`) | None |

### Tag Parameters

- **tagName**: Name of the tag (case-sensitive)
- **tagBg**: Background color in hex format (e.g., "#FF5733")
- **tagFg**: Foreground (text) color in hex format (e.g., "#FFFFFF")
- **newTagName**: New name when updating a tag
- **colorCommand**: Natural language color description (e.g., "blue tag", "dark red background")

### Examples

#### Getting Space Tags
**User Prompt:**
```
Show me all tags in the "Development" space
```

**System Response:**
```json
{
  "spaceName": "Development",
  "tags": [
    {
      "name": "feature",
      "tag_bg": "#FF5733",
      "tag_fg": "#FFFFFF"
    },
    {
      "name": "bug",
      "tag_bg": "#DC3545",
      "tag_fg": "#FFFFFF"
    }
  ]
}
```
#### Creating a Tag
**User Prompt:**
```
Create a new tag called "priority" in the "Development" space with red background
```

**System Response:**
```json
{
  "spaceName": "Development",
  "tagName": "priority",
  "tagBg": "#FF0000",
  "tagFg": "#FFFFFF"
}
```

#### Creating a Tag with Natural Language Color Command
**User Prompt:**
```
Create a new tag called "important" in the "Development" space using dark blue color
```

**System Response:**
```json
{
  "spaceName": "Development",
  "tagName": "important",
  "colorCommand": "dark blue color"
}
```

#### Updating a Tag
**User Prompt:**
```
Update the "priority" tag to have a blue background
```

**System Response:**
```json
{
  "spaceName": "Development",
  "tagName": "priority",
  "tagBg": "#0000FF"
}
```

#### Updating a Tag with Natural Language Color Command
**User Prompt:**
```
Change the "priority" tag color to light green
```

**System Response:**
```json
{
  "spaceName": "Development",
  "tagName": "priority",
  "colorCommand": "light green"
}
```

#### Adding a Tag to a Task
**User Prompt:**
```
Add the "feature" tag to the task "Implement Authentication"
```

**System Response:**
```json
{
  "taskName": "Implement Authentication",
  "tagName": "feature"
}
```

### Important Notes

1. **Tag Existence**: Before adding a tag to a task, ensure the tag exists in the space. Use `get_space_tags` to verify tag existence and `create_space_tag` to create it if needed.

2. **Color Formats**: 
   - **Hex Format**: Colors can be provided in hex format (e.g., "#FF5733", "#fff")
   - **Natural Language**: Colors can be specified using natural language (e.g., "blue", "dark red", "light green")
   - When using natural language colors, the system automatically generates appropriate foreground (text) colors for optimal contrast

3. **Case Sensitivity**: Tag names are case-sensitive. "Feature" and "feature" are treated as different tags.

4. **Task Tags**: When creating or updating tasks, you can include tags in the task properties:
   ```json
   {
     "name": "New Task",
     "tags": ["feature", "priority"]
   }
   ```

5. **Supported Color Names**: Basic colors (red, blue, green, etc.) and common variations (dark blue, light green, etc.) are supported.

## Document Management

| Tool | Description | Required Parameters | Optional Parameters |
|------|-------------|-------------------|-------------------|
| create_document | Create a document | `name`, `parent` (with `id` and `type`), `visibility`, `create_page` | None |
| get_document | Get document details | `documentId` | None |
| list_documents | List documents | None | `id`, `creator`, `deleted`, `archived`, `parent_id`, `parent_type`, `limit`, `next_cursor` |
| list_document_pages | List document pages | `documentId` | `max_page_depth` (-1 for unlimited) |
| get_document_pages | Get document pages | `documentId`, `pageIds` | `content_format` ('text/md'/'text/html') |
| create_document_page | Create a document page | `documentId`, `name` | `content`, `sub_title`, `parent_page_id` |
| update_document_page | Update a document page | `documentId`, `pageId` | `name`, `sub_title`, `content`, `content_format`, `content_edit_mode` |

### Document Parameters

- **Parent Types**:
  - Space (4)
  - Folder (5)
  - List (6)
  - All (7)
  - Workspace (12)

- **Visibility Settings**:
  - PUBLIC: Document is visible to all workspace members
  - PRIVATE: Document is visible only to specific members

- **Content Formats**:
  - text/md: Markdown format (default)
  - text/html: HTML format (for get_document_pages)
  - text/plain: Plain text format (for update_document_page)

- **Content Edit Modes**:
  - replace: Replace existing content (default)
  - append: Add content at the end
  - prepend: Add content at the beginning

### Best Practices and Limits

1. **Document Creation**:
   - Choose appropriate parent type based on your organization structure
   - Use meaningful names that follow your documentation standards
   - Consider visibility settings carefully for sensitive information

2. **Page Organization**:
   - Create a clear hierarchy using parent_page_id
   - Use descriptive titles and subtitles
   - Keep content modular and well-structured

3. **Performance Considerations**:
   - Use pagination (limit and next_cursor) when listing documents
   - Set appropriate max_page_depth when listing pages
   - Batch page retrievals using get_document_pages with multiple pageIds

4. **API Limits**:
   - Maximum content size: 2MB per page
   - Rate limits: 100 requests per minute
   - Maximum page depth: No hard limit, but recommended to stay under 5 levels
   - Maximum pages per document: 1000

### Common Use Cases and Examples

#### Creating a Document with Initial Page
```json
{
  "name": "Technical Documentation",
  "parent": {
    "id": "123456",
    "type": 4
  },
  "visibility": "PUBLIC",
  "create_page": true
}
```

#### Getting Document Details
**User Prompt:**
```
Get details for the document with id 8cdu22c-13153
```

**System Response:**
```json
{
  "id": "8cdu22c-13153",
  "name": "Project Documentation",
  "parent": {
    "id": "90130315830",
    "type": 4
  },
  "created": "2025-04-18T20:47:23.611Z",
  "updated": "2025-04-18T20:47:23.611Z",
  "creator": 55154194,
  "public": false,
  "type": 1,
  "url": "https://app.clickup.com/..."
}
```

#### Listing Documents
**User Prompt:**
```
Show me all documents in the workspace
```

**System Response:**
```json
{
  "documents": [
    {
      "id": "8cdu22c-10153",
      "name": "First Doc name",''
      "url": "https://app.clickup.com/...",
      "parent": {
        "id": "90131843402",
        "type": 5
      },
      "created": "2024-08-16T19:30:17.853Z",
      "updated": "2025-04-02T14:07:42.454Z",
      "creator": 55158625,
      "public": false,
      "type": 1
    },
    {
      "id": "8cdu22c-10173",
      ...
    },
  ]
}
```

#### Listing Document Pages
**User Prompt:**
``` 
Show me all pages for the document with id 8cdu22c-13153
```

**System Response:**
```json
[
  {
    "id": "8cdu22c-11473",
    "doc_id": "8cdu22c-3747",
    "workspace_id": 9007073356,
    "name": "Model"
  },
  {
    "id": "8cdu22c-13013",
    "doc_id": "8cdu22c-3747",
    "workspace_id": 9007073356,
    "name": "Document Example",
    "pages": [
      {
        "id": "8cdu22c-1687",
        "doc_id": "8cdu22c-3747",
        "parent_page_id": "8cdu22c-13013",
        "workspace_id": 9007073356,
        "name": "Aditional Features",
        "pages": [
          {
            "id": "8cdu22c-1687",
            "doc_id": "8cdu22c-3747",
            "parent_page_id": "8cdu22c-13013",
            "workspace_id": 9007073356,
            "name": "Aditional Features pt 2",
          },
          ...
        ],
      }
    ]
  }
]
```

#### Getting Document Page
**User Prompt:**
```
Get details for the page "Milestones" in the document with id 8cdu22c-13153

Obs: you can also ask for more pages at once
```

**System Response:**
```json
{
  "pages": [
    {
      "id": "8cdu22c-36253",
      "doc_id": "8cdu22c-13133",
      "workspace_id": 9007073356,
      "name": "teste2",
      "date_created": 1745010444340,
      "date_updated": 1745010454496,
      "content": "....#md",
      "creator_id": 55154194,
      "deleted": false,
      "date_edited": 1745010454496,
      "edited_by": 55154194,
      "archived": false,
      "protected": false,
      "presentation_details": {
        "show_contributor_header": false
      }
    },
    ....
  ]
}
```

#### Creating Document Page
**User Prompt:**
```
Create a page at the document 8cdu22c-13133 with ...
or
Create a subpage for page 8cdu22c-151232 with ...
```

**System Response:**
```json
{
  "id": "8cdu22c-36273",
  "doc_id": "8cdu22c-13133",
  "workspace_id": 9007073356,
  "name": "📝 Página de Exemplo",
  "sub_title": "Demonstração de criação de página",
  "date_created": 1745171083589,
  "date_updated": 1745171083589,
  "content": "Md example content",
  "creator_id": 55154194,
  "deleted": false,
  "archived": false,
  "protected": false
}
```

#### Updating / Editing Document Page
**User Prompt:**
```
Edit page 8cdu22c-36293 adding, in the end, another information...
```

**System Response:**
```json
{
  "message": "Page updated successfully"
}
```

## Workspace Organization

| Tool | Description | Required Parameters | Response |
|------|-------------|-------------------|----------|
| get_workspace_hierarchy | Get complete structure | None | Full workspace tree with spaces, folders, and lists |

### Workspace Tree Structure
```json
{
  "workspace": {
    "id": "team_id",
    "name": "Workspace Name",
    "spaces": [{
      "id": "space_id",
      "name": "Space Name",
      "lists": [...],
      "folders": [{
        "id": "folder_id",
        "name": "Folder Name",
        "lists": [...]
      }]
    }]
  }
}
```

## Prompts

| Prompt | Purpose | Features |
|--------|---------|----------|
| summarize_tasks | Generate task overview | Status summary, relationships, current states |
| analyze_priorities | Review task priorities | Priority review, adjustments, sequencing |
| generate_description | Create task descriptions | Structure, objectives, dependencies |

## Common Parameters

### Name-based Lookup
All tools support looking up items by name instead of ID:
- `listName` instead of `listId`
- `taskName` instead of `taskId`
- `spaceName` instead of `spaceId`
- `folderName` instead of `folderId`

### Date Formats
- All dates should be provided as Unix timestamps in milliseconds
- Example: `1703980800000` for January 1, 2024

### Priority Levels
1. Urgent/Highest
2. High
3. Normal
4. Low

## Error Handling

The server provides clear error messages for:
- Missing required parameters
- Invalid IDs or names
- Items not found
- Permission issues
- API rate limiting

### Common Error Responses
```json
{
  "error": "List with name 'Development' not found",
  "type": "NOT_FOUND"
}
```

```json
{
  "error": "Either taskId or taskName is required",
  "type": "MISSING_PARAMETER"
}
```

### Rate Limiting
- Automatic handling of ClickUp API rate limits
- Built-in retry mechanism with exponential backoff
- Status updates during rate limit waits
</file>

<file path="src/services/clickup/base.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Base ClickUp Service Class
 * 
 * This class provides core functionality for all ClickUp service modules:
 * - Axios client configuration
 * - Rate limiting and request throttling
 * - Error handling
 * - Common request methods
 */

import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { Logger, LogLevel } from '../../logger.js';

/**
 * Basic service response interface
 */
export interface ServiceResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    message: string;
    code?: string;
    details?: any;
  }
}

/**
 * Error types for better error handling
 */
export enum ErrorCode {
  RATE_LIMIT = 'rate_limit_exceeded',
  NOT_FOUND = 'resource_not_found',
  UNAUTHORIZED = 'unauthorized',
  VALIDATION = 'validation_error',
  SERVER_ERROR = 'server_error',
  NETWORK_ERROR = 'network_error',
  WORKSPACE_ERROR = 'workspace_error',
  INVALID_PARAMETER = 'invalid_parameter',
  UNKNOWN = 'unknown_error'
}

/**
 * Custom error class for ClickUp API errors
 */
export class ClickUpServiceError extends Error {
  readonly code: ErrorCode;
  readonly data?: any;
  readonly status?: number;
  context?: Record<string, any>;

  constructor(
    message: string,
    code: ErrorCode = ErrorCode.UNKNOWN,
    data?: any,
    status?: number,
    context?: Record<string, any>
  ) {
    super(message);
    this.name = 'ClickUpServiceError';
    this.code = code;
    this.data = data;
    this.status = status;
    this.context = context;
  }
}

/**
 * Rate limit response headers from ClickUp API
 */
interface RateLimitHeaders {
  'x-ratelimit-limit': number;
  'x-ratelimit-remaining': number;
  'x-ratelimit-reset': number;
}

/**
 * Helper function to safely parse JSON
 * @param data Data to parse
 * @param fallback Optional fallback value if parsing fails
 * @returns Parsed JSON or fallback value
 */
function safeJsonParse(data: any, fallback: any = undefined): any {
  if (typeof data !== 'string') {
    return data;
  }
  
  try {
    return JSON.parse(data);
  } catch (error) {
    return fallback;
  }
}

/**
 * Base ClickUp service class that handles common functionality
 */
export class BaseClickUpService {
  protected readonly apiKey: string;
  protected readonly teamId: string;
  protected readonly client: AxiosInstance;
  protected readonly logger: Logger;
  
  protected readonly defaultRequestSpacing = 600; // Default milliseconds between requests
  protected readonly rateLimit = 100; // Maximum requests per minute (Free Forever plan)
  protected requestSpacing: number; // Current request spacing, can be adjusted
  protected readonly timeout = 65000; // 65 seconds (safely under the 1-minute window)
  protected requestQueue: (() => Promise<any>)[] = [];
  protected processingQueue = false;
  protected lastRateLimitReset: number = 0;

  /**
   * Creates an instance of BaseClickUpService.
   * @param apiKey - ClickUp API key for authentication
   * @param teamId - ClickUp team ID for targeting the correct workspace
   * @param baseUrl - Optional custom base URL for the ClickUp API
   */
  constructor(apiKey: string, teamId: string, baseUrl: string = 'https://api.clickup.com/api/v2') {
    this.apiKey = apiKey;
    this.teamId = teamId;
    this.requestSpacing = this.defaultRequestSpacing;
    
    // Create a logger with the actual class name for better context
    const className = this.constructor.name;
    this.logger = new Logger(`ClickUp:${className}`);

    // Configure the Axios client with default settings
    this.client = axios.create({
      baseURL: baseUrl,
      headers: {
        'Authorization': apiKey,
        'Content-Type': 'application/json'
      },
      timeout: this.timeout,
      transformResponse: [
        // Add custom response transformer to handle both JSON and text responses
        (data: any) => {
          if (!data) return data;
          
          // If it's already an object, return as is
          if (typeof data !== 'string') return data;
          
          // Try to parse as JSON, fall back to raw text if parsing fails
          const parsed = safeJsonParse(data, null);
          return parsed !== null ? parsed : data;
        }
      ]
    });

    this.logger.debug(`Initialized ${className}`, { teamId, baseUrl });

    // Add response interceptor for error handling
    this.client.interceptors.response.use(
      response => response,
      error => this.handleAxiosError(error)
    );
  }

  /**
   * Handle errors from Axios requests
   * @private
   * @param error Error from Axios
   * @returns Never - always throws an error
   */
  private handleAxiosError(error: any): never {
    // Determine error details
    const status = error.response?.status;
    const responseData = error.response?.data;
    const errorMsg = responseData?.err || responseData?.error || error.message || 'Unknown API error';
    const path = error.config?.url || 'unknown path';
    
    // Context object for providing more detailed log information
    const errorContext: {
      path: string;
      status: number | undefined;
      method: string;
      requestData: any;
      rateLimitInfo?: {
        limit: number;
        remaining: number;
        reset: number;
        timeToReset: number;
      };
    } = {
      path,
      status,
      method: error.config?.method?.toUpperCase() || 'UNKNOWN',
      requestData: error.config?.data ? safeJsonParse(error.config.data, error.config.data) : undefined
    };

    // Pick the appropriate error code based on status
    let code: ErrorCode;
    let logMessage: string;
    let errorMessage: string;

    if (error.code === 'ECONNABORTED' || error.message?.includes('timeout')) {
      code = ErrorCode.NETWORK_ERROR;
      logMessage = `Request timeout for ${path}`;
      errorMessage = 'Request timed out. Please try again.';
    } else if (!error.response) {
      code = ErrorCode.NETWORK_ERROR;
      logMessage = `Network error accessing ${path}: ${error.message}`;
      errorMessage = 'Network error. Please check your connection and try again.';
    } else if (status === 429) {
      code = ErrorCode.RATE_LIMIT;
      this.handleRateLimitHeaders(error.response.headers);
      
      // Calculate time until reset
      const reset = error.response.headers['x-ratelimit-reset'];
      const now = Date.now() / 1000; // Convert to seconds
      const timeToReset = Math.max(0, reset - now);
      const resetMinutes = Math.ceil(timeToReset / 60);
      
      logMessage = `Rate limit exceeded for ${path}`;
      errorMessage = `Rate limit exceeded. Please wait ${resetMinutes} minute${resetMinutes === 1 ? '' : 's'} before trying again.`;
      
      // Add more context to the error
      errorContext.rateLimitInfo = {
        limit: error.response.headers['x-ratelimit-limit'],
        remaining: error.response.headers['x-ratelimit-remaining'],
        reset: reset,
        timeToReset: timeToReset
      };
    } else if (status === 401 || status === 403) {
      code = ErrorCode.UNAUTHORIZED;
      logMessage = `Authorization failed for ${path}`;
      errorMessage = 'Authorization failed. Please check your API key.';
    } else if (status === 404) {
      code = ErrorCode.NOT_FOUND;
      logMessage = `Resource not found: ${path}`;
      errorMessage = 'Resource not found.';
    } else if (status >= 400 && status < 500) {
      code = ErrorCode.VALIDATION;
      logMessage = `Validation error for ${path}: ${errorMsg}`;
      errorMessage = errorMsg;
    } else if (status >= 500) {
      code = ErrorCode.SERVER_ERROR;
      logMessage = `ClickUp server error: ${errorMsg}`;
      errorMessage = 'ClickUp server error. Please try again later.';
    } else {
      code = ErrorCode.UNKNOWN;
      logMessage = `Unknown API error: ${errorMsg}`;
      errorMessage = 'An unexpected error occurred. Please try again.';
    }

    // Log the error with context
    this.logger.error(logMessage, errorContext);

    // Throw a formatted error with user-friendly message
    throw new ClickUpServiceError(errorMessage, code, error);
  }

  /**
   * Handle rate limit headers from ClickUp API
   * @private
   * @param headers Response headers from ClickUp
   */
  private handleRateLimitHeaders(headers: any): void {
    try {
      // Parse the rate limit headers
      const limit = headers['x-ratelimit-limit'];
      const remaining = headers['x-ratelimit-remaining'];
      const reset = headers['x-ratelimit-reset'];
      
      // Only log if we're getting close to the limit
      if (remaining < limit * 0.2) {
        this.logger.warn('Approaching rate limit', { remaining, limit, reset });
      } else {
        this.logger.debug('Rate limit status', { remaining, limit, reset });
      }

      if (reset) {
        this.lastRateLimitReset = reset;
        
        // If reset is in the future, calculate a safe request spacing
        const now = Date.now();
        const resetTime = reset * 1000; // convert to milliseconds
        const timeToReset = Math.max(0, resetTime - now);
        
        // Proactively adjust spacing when remaining requests get low
        // This helps avoid hitting rate limits in the first place
        if (remaining < limit * 0.3) {
          // More aggressive spacing when close to limit
          let safeSpacing;
          
          if (remaining <= 5) {
            // Very aggressive spacing for last few requests
            safeSpacing = Math.ceil((timeToReset / remaining) * 2);
            // Start processing in queue mode preemptively
            if (!this.processingQueue) {
              this.logger.info('Preemptively switching to queue mode (low remaining requests)', { 
                remaining, 
                limit 
              });
              this.processingQueue = true;
              this.processQueue().catch(err => {
                this.logger.error('Error processing request queue', err);
              });
            }
          } else if (remaining <= 20) {
            // More aggressive spacing
            safeSpacing = Math.ceil((timeToReset / remaining) * 1.5);
          } else {
            // Standard safe spacing with buffer
            safeSpacing = Math.ceil((timeToReset / remaining) * 1.1);
          }
          
          // Apply updated spacing, but with a reasonable maximum
          const maxSpacing = 5000; // 5 seconds max spacing
          const adjustedSpacing = Math.min(safeSpacing, maxSpacing);
          
          // Only adjust if it's greater than our current spacing
          if (adjustedSpacing > this.requestSpacing) {
            this.logger.debug(`Adjusting request spacing: ${this.requestSpacing}ms → ${adjustedSpacing}ms`, { 
              remaining, 
              timeToReset 
            });
            this.requestSpacing = adjustedSpacing;
          }
        }
      }
    } catch (error) {
      this.logger.warn('Failed to parse rate limit headers', error);
    }
  }

  /**
   * Process the request queue, respecting rate limits by spacing out requests
   * @private
   */
  private async processQueue(): Promise<void> {
    if (this.requestQueue.length === 0) {
      this.logger.debug('Queue empty, exiting queue processing mode');
      this.processingQueue = false;
      return;
    }

    const queueLength = this.requestQueue.length;
    this.logger.debug(`Processing request queue (${queueLength} items)`);

    const startTime = Date.now();
    try {
      // Take the first request from the queue
      const request = this.requestQueue.shift();
      if (request) {
        // Adjust delay based on queue size
        // Longer delays for bigger queues to prevent overwhelming the API
        let delay = this.requestSpacing;
        if (queueLength > 20) {
          delay = this.requestSpacing * 2;
        } else if (queueLength > 10) {
          delay = this.requestSpacing * 1.5;
        }
        
        // Wait for the calculated delay
        await new Promise(resolve => setTimeout(resolve, delay));
        
        // Run the request
        await request();
      }
    } catch (error) {
      if (error instanceof ClickUpServiceError && error.code === ErrorCode.RATE_LIMIT) {
        // If we still hit rate limits, increase the spacing
        this.requestSpacing = Math.min(this.requestSpacing * 1.5, 10000); // Max 10s
        this.logger.warn(`Rate limit hit during queue processing, increasing delay to ${this.requestSpacing}ms`);
      } else {
        this.logger.error('Error executing queued request', error);
      }
    } finally {
      const duration = Date.now() - startTime;
      this.logger.trace(`Queue item processed in ${duration}ms, ${this.requestQueue.length} items remaining`);
      
      // Continue processing the queue after the calculated delay
      setTimeout(() => this.processQueue(), this.requestSpacing);
    }
  }

  /**
   * Makes an API request with rate limiting.
   * @protected
   * @param fn - Function that executes the API request
   * @returns Promise that resolves with the result of the API request
   */
  protected async makeRequest<T>(fn: () => Promise<T>): Promise<T> {
    // If we're being rate limited, queue the request rather than executing immediately
    if (this.processingQueue) {
      const queuePosition = this.requestQueue.length + 1;
      const estimatedWaitTime = Math.ceil((queuePosition * this.requestSpacing) / 1000);
      
      this.logger.info('Request queued due to rate limiting', {
        queuePosition,
        estimatedWaitSeconds: estimatedWaitTime,
        currentSpacing: this.requestSpacing
      });

      return new Promise<T>((resolve, reject) => {
        this.requestQueue.push(async () => {
          try {
            const result = await fn();
            resolve(result);
          } catch (error) {
            // Enhance error message with queue context if it's a rate limit error
            if (error instanceof ClickUpServiceError && error.code === ErrorCode.RATE_LIMIT) {
              const enhancedError = new ClickUpServiceError(
                `${error.message} (Request was queued at position ${queuePosition})`,
                error.code,
                error.data
              );
              reject(enhancedError);
            } else {
              reject(error);
            }
          }
        });
      });
    }

    // Track request metadata
    let requestMethod = 'unknown';
    let requestPath = 'unknown';
    let requestData: any = undefined;

    // Set up interceptor to capture request details
    const requestInterceptorId = this.client.interceptors.request.use(
      (config) => {
        // Capture request metadata
        requestMethod = config.method?.toUpperCase() || 'unknown';
        requestPath = config.url || 'unknown';
        requestData = config.data;
        return config;
      }
    );

    const startTime = Date.now();
    try {
      // Execute the request function
      const result = await fn();
      
      // Debug log for successful requests with timing information
      const duration = Date.now() - startTime;
      this.logger.debug(`Request completed successfully in ${duration}ms`, {
        method: requestMethod,
        path: requestPath,
        duration,
        responseType: result ? typeof result : 'undefined'
      });
      
      return result;
    } catch (error) {
      // If we hit a rate limit, start processing the queue
      if (error instanceof ClickUpServiceError && error.code === ErrorCode.RATE_LIMIT) {
        this.logger.warn('Rate limit reached, switching to queue mode', {
          reset: this.lastRateLimitReset,
          queueLength: this.requestQueue.length
        });
        
        if (!this.processingQueue) {
          this.processingQueue = true;
          this.processQueue().catch(err => {
            this.logger.error('Error processing request queue', err);
          });
        }

        // Queue this failed request and return a promise that will resolve when it's retried
        return new Promise<T>((resolve, reject) => {
          this.requestQueue.push(async () => {
            try {
              const result = await fn();
              resolve(result);
            } catch (retryError) {
              reject(retryError);
            }
          });
        });
      }

      // For other errors, just throw
      throw error;
    } finally {
      // Always remove the interceptor
      this.client.interceptors.request.eject(requestInterceptorId);
    }
  }

  /**
   * Gets the ClickUp team ID associated with this service instance
   * @returns The team ID
   */
  getTeamId(): string {
    return this.teamId;
  }

  /**
   * Helper method to log API operations
   * @protected
   * @param operation - Name of the operation being performed
   * @param details - Details about the operation
   */
  protected logOperation(operation: string, details: any): void {
    this.logger.info(`Operation: ${operation}`, details);
  }

  /**
   * Log detailed information about a request (path and payload)
   * For trace level logging only
   */
  protected traceRequest(method: string, url: string, data?: any): void {
    if (this.logger.isLevelEnabled(LogLevel.TRACE)) {
      this.logger.trace(`${method} ${url}`, {
        payload: data,
        teamId: this.teamId
      });
    }
  }
}
</file>

<file path="src/services/clickup/bulk.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Bulk Service
 * 
 * Enhanced implementation for bulk operations that leverages the existing single-operation methods.
 * This approach reduces code duplication while offering powerful concurrency management.
 */
import { Logger } from '../../logger.js';
import { TaskService } from './task/index.js';
import { ClickUpTask, CreateTaskData, UpdateTaskData } from './types.js';
import { BatchProcessingOptions, BatchResult, processBatch } from '../../utils/concurrency-utils.js';
import { ClickUpServiceError, ErrorCode } from './base.js';
import { clickUpServices } from '../shared.js';
import { findListIDByName } from '../../tools/list.js';

// Create logger instance
const logger = new Logger('BulkService');

/**
 * Service for performing bulk operations in ClickUp
 */
export class BulkService {
  private taskService: TaskService;

  /**
   * Create a new bulk service
   * @param taskService ClickUp Task Service instance
   */
  constructor(taskService: TaskService) {
    this.taskService = taskService;
    logger.info('BulkService initialized');
  }

  /**
   * Create multiple tasks in a list efficiently
   * 
   * @param listId ID of the list to create tasks in
   * @param tasks Array of task data
   * @param options Batch processing options
   * @returns Results containing successful and failed tasks
   */
  async createTasks(
    listId: string,
    tasks: CreateTaskData[],
    options?: BatchProcessingOptions
  ): Promise<BatchResult<ClickUpTask>> {
    logger.info(`Creating ${tasks.length} tasks in list ${listId}`, {
      batchSize: options?.batchSize,
      concurrency: options?.concurrency
    });

    try {
      // First validate that the list exists - do this once for all tasks
      await this.taskService.validateListExists(listId);

      // Process the tasks in batches
      return await processBatch(
        tasks,
        (task, index) => {
          logger.debug(`Creating task ${index + 1}/${tasks.length}`, {
            taskName: task.name
          });
          
          // Reuse the single-task creation method
          return this.taskService.createTask(listId, task);
        },
        options
      );
    } catch (error) {
      logger.error(`Failed to create tasks in bulk`, {
        listId,
        taskCount: tasks.length,
        error: error instanceof Error ? error.message : String(error)
      });

      throw new ClickUpServiceError(
        `Failed to create tasks in bulk: ${error instanceof Error ? error.message : String(error)}`,
        error instanceof ClickUpServiceError ? error.code : ErrorCode.UNKNOWN,
        { listId, taskCount: tasks.length }
      );
    }
  }

  /**
   * Find task by name within a specific list
   */
  private async findTaskInList(taskName: string, listName: string): Promise<string> {
    try {
      const result = await this.taskService.findTasks({
        taskName,
        listName,
        allowMultipleMatches: false,
        useSmartDisambiguation: true,
        includeFullDetails: false
      });

      if (!result || Array.isArray(result)) {
        throw new ClickUpServiceError(
          `Task "${taskName}" not found in list "${listName}"`,
          ErrorCode.NOT_FOUND
        );
      }

      logger.info(`Task "${taskName}" found with ID: ${result.id}`);
      return result.id;
    } catch (error) {
      // Enhance the error message
      if (error instanceof ClickUpServiceError) {
        throw error;
      }
      throw new ClickUpServiceError(
        `Error finding task "${taskName}" in list "${listName}": ${error instanceof Error ? error.message : String(error)}`,
        ErrorCode.UNKNOWN
      );
    }
  }

  /**
   * Resolve task ID using provided identifiers
   */
  private async resolveTaskId(task: { taskId?: string; taskName?: string; listName?: string; customTaskId?: string }): Promise<string> {
    const { taskId, taskName, listName, customTaskId } = task;

    if (taskId) {
      return taskId;
    }

    if (customTaskId) {
      const resolvedTask = await this.taskService.getTaskByCustomId(customTaskId);
      return resolvedTask.id;
    }

    if (taskName && listName) {
      return await this.findTaskInList(taskName, listName);
    }

    throw new ClickUpServiceError(
      'Invalid task identification. Provide either taskId, customTaskId, or both taskName and listName',
      ErrorCode.INVALID_PARAMETER
    );
  }

  /**
   * Update multiple tasks
   * @param tasks Array of tasks to update with their new data
   * @param options Optional batch processing settings
   * @returns Array of updated tasks
   */
  async updateTasks(
    tasks: (UpdateTaskData & { taskId?: string; taskName?: string; listName?: string; customTaskId?: string })[],
    options?: BatchProcessingOptions
  ): Promise<BatchResult<ClickUpTask>> {
    logger.info('Starting bulk update operation', { taskCount: tasks.length });
    
    try {
      return await processBatch(
        tasks,
        async (task) => {
          const { taskId, taskName, listName, customTaskId, ...updateData } = task;
          const resolvedTaskId = await this.resolveTaskId({ taskId, taskName, listName, customTaskId });
          return await this.taskService.updateTask(resolvedTaskId, updateData);
        },
        options
      );
    } catch (error) {
      logger.error('Bulk update operation failed', error);
      throw error;
    }
  }

  /**
   * Move multiple tasks to a different list
   * @param tasks Array of tasks to move (each with taskId or taskName + listName)
   * @param targetListId ID of the destination list or list name
   * @param options Optional batch processing settings
   * @returns Array of moved tasks
   */
  async moveTasks(
    tasks: { taskId?: string; taskName?: string; listName?: string; customTaskId?: string }[],
    targetListId: string,
    options?: BatchProcessingOptions
  ): Promise<BatchResult<ClickUpTask>> {
    logger.info('Starting bulk move operation', { taskCount: tasks.length, targetListId });
    
    try {
      // Determine if targetListId is actually an ID or a name
      let resolvedTargetListId = targetListId;
      
      // If the targetListId doesn't match the pattern of a list ID (usually just numbers),
      // assume it's a list name and try to resolve it
      if (!/^\d+$/.test(targetListId)) {
        logger.info(`Target list appears to be a name: "${targetListId}", attempting to resolve`);
        const listInfo = await findListIDByName(clickUpServices.workspace, targetListId);
        if (!listInfo) {
          throw new ClickUpServiceError(
            `Target list "${targetListId}" not found`,
            ErrorCode.NOT_FOUND
          );
        }
        resolvedTargetListId = listInfo.id;
        logger.info(`Resolved target list to ID: ${resolvedTargetListId}`);
      }

      // Validate the destination list exists
      await this.taskService.validateListExists(resolvedTargetListId);

      return await processBatch(
        tasks,
        async (task) => {
          const resolvedTaskId = await this.resolveTaskId(task);
          return await this.taskService.moveTask(resolvedTaskId, resolvedTargetListId);
        },
        options
      );
    } catch (error) {
      logger.error('Bulk move operation failed', error);
      throw error;
    }
  }

  /**
   * Delete multiple tasks
   * @param tasks Array of tasks to delete (each with taskId or taskName + listName)
   * @param options Batch processing options
   * @returns Results containing successful and failed deletions
   */
  async deleteTasks(
    tasks: { taskId?: string; taskName?: string; listName?: string; customTaskId?: string }[],
    options?: BatchProcessingOptions
  ): Promise<BatchResult<void>> {
    logger.info('Starting bulk delete operation', { taskCount: tasks.length });
    
    try {
      return await processBatch(
        tasks,
        async (task) => {
          const resolvedTaskId = await this.resolveTaskId(task);
          await this.taskService.deleteTask(resolvedTaskId);
        },
        options
      );
    } catch (error) {
      logger.error('Bulk delete operation failed', error);
      throw error;
    }
  }
}
</file>

<file path="src/services/clickup/index.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Service Entry Point
 * 
 * This file re-exports all service modules for the ClickUp API integration.
 * It also provides a convenient factory method to create instances of all services.
 */

// Export base service components
export { 
  BaseClickUpService, 
  ClickUpServiceError, 
  ErrorCode,
  ServiceResponse 
} from './base.js';

// Export type definitions
export * from './types.js';

// Export service modules
export { WorkspaceService } from './workspace.js';
export { TaskService } from './task/index.js';
export { ListService } from './list.js';
export { FolderService } from './folder.js';
export { ClickUpTagService } from './tag.js';
export { TimeTrackingService } from './time.js';
export { DocumentService } from './document.js';

// Import service classes for the factory function
import { WorkspaceService } from './workspace.js';
import { TaskService } from './task/index.js';
import { ListService } from './list.js';
import { FolderService } from './folder.js';
import { ClickUpTagService } from './tag.js';
import { TimeTrackingService } from './time.js';
import { Logger } from '../../logger.js';
import { DocumentService } from './document.js';

/**
 * Configuration options for ClickUp services
 */
export interface ClickUpServiceConfig {
  apiKey: string;
  teamId: string;
  baseUrl?: string;
}

/**
 * Collection of all ClickUp service instances
 */
export interface ClickUpServices {
  workspace: WorkspaceService;
  task: TaskService;
  list: ListService;
  folder: FolderService;
  tag: ClickUpTagService;
  timeTracking: TimeTrackingService;
  document: DocumentService;
}

// Singleton logger for ClickUp services
const logger = new Logger('ClickUpServices');

/**
 * Factory function to create instances of all ClickUp services
 * @param config Configuration for the services
 * @returns Object containing all service instances
 */
export function createClickUpServices(config: ClickUpServiceConfig): ClickUpServices {
  const { apiKey, teamId, baseUrl } = config;

  // Log start of overall initialization
  logger.info('Starting ClickUp services initialization', { 
    teamId, 
    baseUrl: baseUrl || 'https://api.clickup.com/api/v2' 
  });

  // Create workspace service first since others depend on it
  logger.info('Initializing ClickUp Workspace service');
  const workspaceService = new WorkspaceService(apiKey, teamId, baseUrl);

  // Initialize remaining services with workspace dependency
  logger.info('Initializing ClickUp Task service');
  const taskService = new TaskService(apiKey, teamId, baseUrl, workspaceService);
  
  logger.info('Initializing ClickUp List service');
  const listService = new ListService(apiKey, teamId, baseUrl, workspaceService);
  
  logger.info('Initializing ClickUp Folder service');
  const folderService = new FolderService(apiKey, teamId, baseUrl, workspaceService);

  logger.info('Initializing ClickUp Tag service');
  const tagService = new ClickUpTagService(apiKey, teamId, baseUrl);

  logger.info('Initializing ClickUp Time Tracking service');
  const timeTrackingService = new TimeTrackingService(apiKey, teamId, baseUrl);

  logger.info('Initializing ClickUp Document service');
  const documentService = new DocumentService(apiKey, teamId, baseUrl);

  const services = {
    workspace: workspaceService,
    task: taskService,
    list: listService,
    folder: folderService,
    tag: tagService,
    timeTracking: timeTrackingService,
    document: documentService
  };

  // Log successful completion
  logger.info('All ClickUp services initialized successfully', {
    services: Object.keys(services),
    baseUrl: baseUrl || 'https://api.clickup.com/api/v2'
  });
  
  return services;
}
</file>

<file path="src/tools/task/main.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Task Tools
 * 
 * This is the main task module that connects tool definitions to their handlers.
 * The actual implementations are organized in sub-modules for better maintainability.
 */

import { sponsorService } from '../../utils/sponsor-service.js';

// Import tool definitions
import {
  createTaskTool,
  getTaskTool,
  getTasksTool,
  updateTaskTool,
  moveTaskTool,
  duplicateTaskTool,
  deleteTaskTool,
  getTaskCommentsTool,
  createTaskCommentTool
} from './single-operations.js';

import {
  createBulkTasksTool,
  updateBulkTasksTool,
  moveBulkTasksTool,
  deleteBulkTasksTool
} from './bulk-operations.js';

import {
  getWorkspaceTasksTool
} from './workspace-operations.js';

// Import handlers
import {
  createTaskHandler,
  getTaskHandler,
  getTasksHandler,
  updateTaskHandler,
  moveTaskHandler,
  duplicateTaskHandler,
  deleteTaskHandler,
  getTaskCommentsHandler,
  createTaskCommentHandler,
  createBulkTasksHandler,
  updateBulkTasksHandler,
  moveBulkTasksHandler,
  deleteBulkTasksHandler,
  getWorkspaceTasksHandler,
  formatTaskData
} from './index.js';

// Import shared services
import { clickUpServices } from '../../services/shared.js';
const { task: taskService } = clickUpServices;

import { BatchResult } from '../../utils/concurrency-utils.js';
import { ClickUpTask } from '../../services/clickup/types.js';

//=============================================================================
// HANDLER WRAPPER UTILITY
//=============================================================================

/**
 * Creates a wrapped handler function with standard error handling and response formatting
 */
function createHandlerWrapper<T>(
  handler: (params: any) => Promise<T>,
  formatResponse: (result: T) => any = (result) => result
) {
  return async (parameters: any) => {
    try {
      const result = await handler(parameters);
      return sponsorService.createResponse(formatResponse(result), true);
    } catch (error) {
      return sponsorService.createErrorResponse(error, parameters);
    }
  };
}

//=============================================================================
// SINGLE TASK OPERATIONS - HANDLER IMPLEMENTATIONS
//=============================================================================

export const handleCreateTask = createHandlerWrapper(createTaskHandler);
export const handleGetTask = createHandlerWrapper(getTaskHandler);
export const handleGetTasks = createHandlerWrapper(getTasksHandler, (tasks) => ({
  tasks,
  count: tasks.length
}));

/**
 * Handle task update operation
 */
export async function handleUpdateTask(parameters: any) {
  try {
    const result = await updateTaskHandler(taskService, parameters);
    return sponsorService.createResponse(formatTaskData(result), true);
  } catch (error) {
    return sponsorService.createErrorResponse(error instanceof Error ? error.message : String(error));
  }
}

export const handleMoveTask = createHandlerWrapper(moveTaskHandler);
export const handleDuplicateTask = createHandlerWrapper(duplicateTaskHandler);
export const handleDeleteTask = createHandlerWrapper(deleteTaskHandler, () => ({
  success: true,
  message: "Task deleted successfully"
}));
export const handleGetTaskComments = createHandlerWrapper(getTaskCommentsHandler, (comments) => ({
  comments,
  count: comments.length
}));
export const handleCreateTaskComment = createHandlerWrapper(createTaskCommentHandler, (comment) => ({
  success: true,
  message: "Comment added successfully",
  comment: comment && typeof comment === 'object' ? comment : {
    id: `generated-${Date.now()}`,
    comment_text: typeof comment === 'string' ? comment : "Comment text unavailable"
  }
}));

//=============================================================================
// BULK TASK OPERATIONS - HANDLER IMPLEMENTATIONS
//=============================================================================

export const handleCreateBulkTasks = createHandlerWrapper(createBulkTasksHandler, (result: BatchResult<ClickUpTask>) => ({
  successful: result.successful,
  failed: result.failed,
  count: result.totals.total,
  success_count: result.totals.success,
  failure_count: result.totals.failure,
  errors: result.failed.map(f => f.error)
}));

export const handleUpdateBulkTasks = createHandlerWrapper(updateBulkTasksHandler, (result: BatchResult<ClickUpTask>) => ({
  successful: result.successful,
  failed: result.failed,
  count: result.totals.total,
  success_count: result.totals.success,
  failure_count: result.totals.failure,
  errors: result.failed.map(f => f.error)
}));

export const handleMoveBulkTasks = createHandlerWrapper(moveBulkTasksHandler, (result: BatchResult<ClickUpTask>) => ({
  successful: result.successful,
  failed: result.failed,
  count: result.totals.total,
  success_count: result.totals.success,
  failure_count: result.totals.failure,
  errors: result.failed.map(f => f.error)
}));

export const handleDeleteBulkTasks = createHandlerWrapper(deleteBulkTasksHandler, (result: BatchResult<void>) => ({
  successful: result.successful,
  failed: result.failed,
  count: result.totals.total,
  success_count: result.totals.success,
  failure_count: result.totals.failure,
  errors: result.failed.map(f => f.error)
}));

//=============================================================================
// WORKSPACE TASK OPERATIONS - HANDLER IMPLEMENTATIONS
//=============================================================================

export const handleGetWorkspaceTasks = createHandlerWrapper(
  // This adapts the new handler signature to match what createHandlerWrapper expects
  (params) => getWorkspaceTasksHandler(taskService, params),
  (response) => response // Pass through the response as is
);

//=============================================================================
// TOOL DEFINITIONS AND HANDLERS EXPORT
//=============================================================================

// Tool definitions with their handler mappings
export const tools = [
  { 
    definition: createTaskTool, 
    handler: createTaskHandler
  },
  { 
    definition: updateTaskTool, 
    handler: updateTaskHandler
  },
  { 
    definition: moveTaskTool, 
    handler: moveTaskHandler
  },
  { 
    definition: duplicateTaskTool, 
    handler: duplicateTaskHandler
  },
  { 
    definition: getTaskTool, 
    handler: getTaskHandler
  },
  { 
    definition: getTasksTool, 
    handler: getTasksHandler
  },
  { 
    definition: getTaskCommentsTool, 
    handler: getTaskCommentsHandler
  },
  { 
    definition: createTaskCommentTool, 
    handler: createTaskCommentHandler
  },
  { 
    definition: deleteTaskTool, 
    handler: deleteTaskHandler
  },
  { 
    definition: getWorkspaceTasksTool, 
    handler: getWorkspaceTasksHandler
  },
  { 
    definition: createBulkTasksTool, 
    handler: async (params: any) => {
      const result = await createBulkTasksHandler(params) as BatchResult<ClickUpTask>;
      return {
        successful: result.successful,
        failed: result.failed,
        count: result.totals.total,
        success_count: result.totals.success,
        failure_count: result.totals.failure,
        errors: result.failed.map(f => f.error)
      };
    }
  },
  { 
    definition: updateBulkTasksTool, 
    handler: async (params: any) => {
      const result = await updateBulkTasksHandler(params) as BatchResult<ClickUpTask>;
      return {
        successful: result.successful,
        failed: result.failed,
        count: result.totals.total,
        success_count: result.totals.success,
        failure_count: result.totals.failure,
        errors: result.failed.map(f => f.error)
      };
    }
  },
  { 
    definition: moveBulkTasksTool, 
    handler: async (params: any) => {
      const result = await moveBulkTasksHandler(params) as BatchResult<ClickUpTask>;
      return {
        successful: result.successful,
        failed: result.failed,
        count: result.totals.total,
        success_count: result.totals.success,
        failure_count: result.totals.failure,
        errors: result.failed.map(f => f.error)
      };
    }
  },
  { 
    definition: deleteBulkTasksTool, 
    handler: async (params: any) => {
      const result = await deleteBulkTasksHandler(params) as BatchResult<void>;
      return {
        successful: result.successful,
        failed: result.failed,
        count: result.totals.total,
        success_count: result.totals.success,
        failure_count: result.totals.failure,
        errors: result.failed.map(f => f.error)
      };
    }
  }
];
</file>

<file path="src/tools/documents.ts">
/**
 * SPDX-FileCopyrightText: © 2025 João Santana <joaosantana@gmail.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Document Tools
 * 
 * This module defines document-related tools including creating,
 * retrieving, updating, and deleting documents.
 */

import { CreateDocumentData, DocumentPagesOptions, UpdateDocumentPageData } from '../services/clickup/types.js';
import { workspaceService } from '../services/shared.js';
import config from '../config.js';
import { sponsorService } from '../utils/sponsor-service.js';
import { Logger } from "../logger.js";
import { clickUpServices } from "../services/shared.js";

const logger = new Logger('DocumentTools');
const { document: documentService } = clickUpServices;

/**
 * Tool definition for creating a document
 */
export const createDocumentTool = {
  name: "create_document",
  description: `Creates a document in a ClickUp space, folder, or list. Requires name, parent info, visibility and create_page flag.`,
  inputSchema: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "Name and Title of the document"
      },
      parent: {
        type: "object",
        properties: {
          id: {
            type: "string",
            description: "ID of the parent container (space, folder, or list)"
          },
          type: {
            type: "number",
            enum: [4, 5, 6, 7, 12],
            description: "Type of the parent container (4=space, 5=folder, 6=list, 7=everything, 12=workspace)"
          }
        },
        required: ["id", "type"],
        description: "Parent container information"
      },
      visibility: {
        type: "string",
        enum: ["PUBLIC", "PRIVATE"],
        description: "Document visibility setting"
      },
      create_page: {
        type: "boolean",
        description: "Whether to create an initial blank page"
      }
    },
    required: ["name", "parent", "visibility", "create_page"]
  }
};

/**
 * Tool definition for getting a document
 */
export const getDocumentTool = {
  name: "get_document",
  description: `Gets details of a ClickUp document. Use documentId (preferred) or search by title in a container.`,
  inputSchema: {
    type: "object",
    properties: {
      documentId: {
        type: "string",
        description: "ID of the document to retrieve"
      },
    },
    required: ["documentId"]
  }
};

/**
 * Tool definition for listing documents
 */
export const listDocumentsTool = {
  name: "list_documents",
  description: `Lists all documents in a ClickUp space, folder, or list.`,
  inputSchema: {
    type: "object",
    properties: {
      id: {
        type: "string",
        description: "Optional document ID to filter by"
      },
      creator: {
        type: "number",
        description: "Optional creator ID to filter by"
      },
      deleted: {
        type: "boolean",
        description: "Whether to include deleted documents"
      },
      archived: {
        type: "boolean",
        description: "Whether to include archived documents"
      },
      parent_id: {
        type: "string",
        description: "ID of the parent container to list documents from"
      },
      parent_type: {
        type: "string",
        enum: ["TASK", "SPACE", "FOLDER", "LIST", "EVERYTHING", "WORKSPACE"],
        description: "Type of the parent container"
      },
      limit: {
        type: "number",
        description: "Maximum number of documents to return"
      },
      next_cursor: {
        type: "string",
        description: "Cursor for pagination"
      }
    },
    required: []
  }
};

/**
 * Tool definition for listing document pages
 */
export const listDocumentPagesTool = {
  name: "list_document_pages",
  description: "Lists all pages in a document with optional depth control",
  inputSchema: {
    type: "object",
    properties: {
      documentId: {
        type: "string",
        description: "ID of the document to list pages from"
      },
      max_page_depth: {
        type: "number",
        description: "Maximum depth of pages to retrieve (-1 for unlimited)",
        optional: true
      }
    },
    required: ["documentId"]
  }
};

/**
 * Tool definition for getting document pages
 */
export const getDocumentPagesTool = {
  name: "get_document_pages",
  description: "Gets the content of specific pages from a document",
  inputSchema: {
    type: "object",
    properties: {
      documentId: {
        type: "string",
        description: "ID of the document to get pages from"
      },
      pageIds: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Array of page IDs to retrieve"
      },
      content_format: {
        type: "string",
        enum: ["text/md", "text/html"],
        description: "Format of the content to retrieve",
        optional: true
      }
    },
    required: ["documentId", "pageIds"]
  }
};

/**
 * Tool definition for creating a document page
 */
export const createDocumentPageTool = {
  name: "create_document_page",
  description: "Creates a new page in a ClickUp document",
  inputSchema: {
    type: "object",
    properties: {
      documentId: {
        type: "string",
        description: "ID of the document to create the page in"
      },
      content: {
        type: "string",
        description: "Content of the page",
        optional: true
      },
      name: {
        type: "string",
        description: "Name and title of the page",
      },
      sub_title: {
        type: "string",
        description: "Subtitle of the page",
        optional: true
      },
      parent_page_id: {
        type: "string",
        description: "ID of the parent page (if this is a sub-page)",
        optional: true
      }
    },
    required: ["documentId", "name"]
  }
};

/**
 * Tool definition for updating a document page
 */
export const updateDocumentPageTool = {
  name: "update_document_page",
  description: "Updates an existing page in a ClickUp document. Supports updating name, subtitle, and content with different edit modes (replace/append/prepend).",
  inputSchema: {
    type: "object",
    properties: {
      documentId: {
        type: "string",
        description: "ID of the document containing the page"
      },
      pageId: {
        type: "string",
        description: "ID of the page to update"
      },
      name: {
        type: "string",
        description: "New name for the page",
        optional: true
      },
      sub_title: {
        type: "string",
        description: "New subtitle for the page",
        optional: true
      },
      content: {
        type: "string",
        description: "New content for the page",
        optional: true
      },
      content_edit_mode: {
        type: "string",
        enum: ["replace", "append", "prepend"],
        description: "How to update the content. Defaults to replace",
        optional: true
      },
      content_format: {
        type: "string",
        enum: ["text/md", "text/plain"],
        description: "Format of the content. Defaults to text/md",
        optional: true
      },
    },
    required: ["documentId", "pageId"]
  }
};

/**
 * Helper function to find a document by title in a container
 */
async function findDocumentByTitle(parentId: string, title: string): Promise<string | null> {
  const response = await documentService.listDocuments({
    parent_id: parentId
  });
  const document = response.docs.find(doc => doc.name === title);
  return document ? document.id : null;
}

/**
 * Helper function to find parent container ID by name and type
 */
async function findParentIdByName(name: string, type: 'space' | 'folder' | 'list'): Promise<string | null> {
  const hierarchy = await workspaceService.getWorkspaceHierarchy();
  const container = workspaceService.findIDByNameInHierarchy(hierarchy, name, type);
  return container ? container.id : null;
}

/**
 * Handler for the create_document tool
 */
export async function handleCreateDocument(parameters: any) {
  const { name, parent, visibility, create_page } = parameters;

  if (!parent || !visibility || !create_page) {
    return sponsorService.createErrorResponse('Parent, visibility, and create_page are required');
  }

  // Prepare document data
  const documentData: CreateDocumentData = {
    name,
    parent,
    visibility,
    create_page
  };

  try {
    // Create the document
    const newDocument = await clickUpServices.document.createDocument(documentData);
    
    return sponsorService.createResponse({
      id: newDocument.id,
      name: newDocument.name,
      parent: newDocument.parent,
      url: `https://app.clickup.com/${config.clickupTeamId}/v/d/${newDocument.id}`,
      message: `Document "${name}" created successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to create document: ${error.message}`);
  }
}

/**
 * Handler for the get_document tool
 */
export async function handleGetDocument(parameters: any) {
  const { documentId, title, parentId } = parameters;

  let targetDocumentId = documentId;

  // If no documentId but title and parentId are provided, look up the document ID
  if (!targetDocumentId && title && parentId) {
    targetDocumentId = await findDocumentByTitle(parentId, title);
    if (!targetDocumentId) {
      throw new Error(`Document "${title}" not found`);
    }
  }

  if (!targetDocumentId) {
    throw new Error("Either documentId or (title + parentId) must be provided");
  }

  try {
    // Get the document
    const document = await documentService.getDocument(targetDocumentId);
    
    return sponsorService.createResponse({
      id: document.id,
      name: document.name,
      parent: document.parent,
      created: new Date(document.date_created).toISOString(),
      updated: new Date(document.date_updated).toISOString(),
      creator: document.creator,
      public: document.public,
      type: document.type,
      url: `https://app.clickup.com/${config.clickupTeamId}/v/d/${document.id}`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to retrieve document: ${error.message}`);
  }
}

/**
 * Handler for the list_documents tool
 */
export async function handleListDocuments(parameters: any) {
  const { 
    id,
    creator,
    deleted,
    archived,
    parent_id,
    parent_type,
    limit,
    next_cursor
  } = parameters;

  try {
    // Prepare options object with all possible parameters
    const options: any = {};
    
    // Add each parameter to options only if it's defined
    if (id !== undefined) options.id = id;
    if (creator !== undefined) options.creator = creator;
    if (deleted !== undefined) options.deleted = deleted;
    if (archived !== undefined) options.archived = archived;
    if (parent_id !== undefined) options.parent_id = parent_id;
    if (parent_type !== undefined) options.parent_type = parent_type;
    if (limit !== undefined) options.limit = limit;
    if (next_cursor !== undefined) options.next_cursor = next_cursor;

    const response = await documentService.listDocuments(options);
    
    // Ensure we have a valid response
    if (!response || !response.docs) {
      return sponsorService.createResponse({
        documents: [],
        message: "No documents found"
      }, true);
    }

    // Map the documents to a simpler format
    const documents = response.docs.map(doc => ({
      id: doc.id,
      name: doc.name,
      url: `https://app.clickup.com/${config.clickupTeamId}/v/d/${doc.id}`,
      parent: doc.parent,
      created: new Date(doc.date_created).toISOString(),
      updated: new Date(doc.date_updated).toISOString(),
      creator: doc.creator,
      public: doc.public,
      type: doc.type
    }));

    return sponsorService.createResponse({
      documents,
      count: documents.length,
      next_cursor: response.next_cursor,
      message: `Found ${documents.length} document(s)`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to list documents: ${error.message}`);
  }
}

/**
 * Handler for listing document pages
 */
export async function handleListDocumentPages(params: any) {
  logger.info('Listing document pages', { params });
  
  try {
    const { documentId, max_page_depth = -1 } = params;
    const pages = await documentService.listDocumentPages(documentId, { max_page_depth });
    return sponsorService.createResponse(pages);
  } catch (error) {
    logger.error('Error listing document pages', error);
    return sponsorService.createErrorResponse(error);
  }
}

/**
 * Handler for getting document pages
 */
export async function handleGetDocumentPages(params: any) {
  const { documentId, pageIds, content_format } = params;

  if (!documentId) {
    return sponsorService.createErrorResponse('Document ID is required');
  }

  if (!pageIds || !Array.isArray(pageIds) || pageIds.length === 0) {
    return sponsorService.createErrorResponse('Page IDs array is required');
  }

  try {
    const options: Partial<DocumentPagesOptions> = {};
    
    // Adiciona content_format nas options se fornecido
    if (content_format) {
      options.content_format = content_format;
    }

    const pages = await clickUpServices.document.getDocumentPages(documentId, pageIds, options);
    return sponsorService.createResponse(pages);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to get document pages: ${error.message}`);
  }
}

/**
 * Handler for creating a new page in a document
 */
export async function handleCreateDocumentPage(parameters: any) {
  const { documentId, content, sub_title, name, parent_page_id } = parameters;

  if (!documentId) {
    return sponsorService.createErrorResponse('Document ID is required');
  }

  if (!name) {
    return sponsorService.createErrorResponse('Title/Name is required');
  }

  try {
    const page = await clickUpServices.document.createPage(documentId, {
      content,
      sub_title,
      name,
      parent_page_id,
    });

    return sponsorService.createResponse(page);
  } catch (error) {
    return sponsorService.createErrorResponse(
      `Failed to create document page: ${error.message}`
    );
  }
}

/**
 * Handler for updating a document page
 */
export async function handleUpdateDocumentPage(parameters: any) {
  const { documentId, pageId, name, sub_title, content, content_format, content_edit_mode } = parameters;

  if (!documentId) {
    return sponsorService.createErrorResponse('Document ID is required');
  }

  if (!pageId) {
    return sponsorService.createErrorResponse('Page ID is required');
  }

  // Prepare update data
  const updateData: UpdateDocumentPageData = {};
  if (name) updateData.name = name;
  if (sub_title) updateData.sub_title = sub_title;
  if (content) updateData.content = content;
  if (content_format) updateData.content_format = content_format;
  if (content_edit_mode) updateData.content_edit_mode = content_edit_mode;

  try {
    const page = await clickUpServices.document.updatePage(documentId, pageId, updateData);

    return sponsorService.createResponse({
      message: `Page updated successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(
      `Failed to update document page: ${error.message}`
    );
  }
}

export const documentTools = [
  createDocumentTool,
  getDocumentTool,
  listDocumentsTool,
  listDocumentPagesTool,
  getDocumentPagesTool,
  createDocumentPageTool,
  updateDocumentPageTool
];
</file>

<file path="src/tools/list.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP List Tools
 * 
 * This module defines list-related tools including creating, updating,
 * retrieving, and deleting lists. It supports creating lists both in spaces
 * and in folders.
 */

import { 
  CreateListData, 
  ClickUpList
} from '../services/clickup/types.js';
import { listService, workspaceService } from '../services/shared.js';
import config from '../config.js';
import { sponsorService } from '../utils/sponsor-service.js';

/**
 * Tool definition for creating a list directly in a space
 */
export const createListTool = {
  name: "create_list",
  description: `Creates a list in a ClickUp space. Use spaceId (preferred) or spaceName + list name. Name is required. For lists in folders, use create_list_in_folder. Optional: content, dueDate, priority, assignee, status.`,
  inputSchema: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "Name of the list"
      },
      spaceId: {
        type: "string",
        description: "ID of the space to create the list in. Use this instead of spaceName if you have the ID."
      },
      spaceName: {
        type: "string",
        description: "Name of the space to create the list in. Alternative to spaceId - one of them MUST be provided."
      },
      content: {
        type: "string",
        description: "Description or content of the list"
      },
      dueDate: {
        type: "string",
        description: "Due date for the list (Unix timestamp in milliseconds)"
      },
      priority: {
        type: "number",
        description: "Priority level: 1 (urgent), 2 (high), 3 (normal), 4 (low)"
      },
      assignee: {
        type: "number",
        description: "User ID to assign the list to"
      },
      status: {
        type: "string",
        description: "Status of the list"
      }
    },
    required: ["name"]
  }
};

/**
 * Tool definition for creating a list within a folder
 */
export const createListInFolderTool = {
  name: "create_list_in_folder",
  description: `Creates a list in a ClickUp folder. Use folderId (preferred) or folderName + space info + list name. Name is required. When using folderName, spaceId/spaceName required as folder names may not be unique. Optional: content, status.`,
  inputSchema: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "Name of the list"
      },
      folderId: {
        type: "string",
        description: "ID of the folder to create the list in. If you have this, you don't need folderName or space information."
      },
      folderName: {
        type: "string",
        description: "Name of the folder to create the list in. When using this, you MUST also provide either spaceName or spaceId."
      },
      spaceId: {
        type: "string",
        description: "ID of the space containing the folder. Required when using folderName instead of folderId."
      },
      spaceName: {
        type: "string", 
        description: "Name of the space containing the folder. Required when using folderName instead of folderId."
      },
      content: {
        type: "string",
        description: "Description or content of the list"
      },
      status: {
        type: "string",
        description: "Status of the list (uses folder default if not specified)"
      }
    },
    required: ["name"]
  }
};

/**
 * Tool definition for retrieving list details
 */
export const getListTool = {
  name: "get_list",
  description: `Gets details of a ClickUp list. Use listId (preferred) or listName. Returns list details including name, content, and space info. ListId more reliable as names may not be unique.`,
  inputSchema: {
    type: "object",
    properties: {
      listId: {
        type: "string",
        description: "ID of the list to retrieve. Use this instead of listName if you have the ID."
      },
      listName: {
        type: "string",
        description: "Name of the list to retrieve. May be ambiguous if multiple lists have the same name."
      }
    },
    required: []
  }
};

/**
 * Tool definition for updating a list
 */
export const updateListTool = {
  name: "update_list",
  description: `Updates a ClickUp list. Use listId (preferred) or listName + at least one update field (name/content/status). ListId more reliable as names may not be unique. Only specified fields updated.`,
  inputSchema: {
    type: "object",
    properties: {
      listId: {
        type: "string",
        description: "ID of the list to update. Use this instead of listName if you have the ID."
      },
      listName: {
        type: "string",
        description: "Name of the list to update. May be ambiguous if multiple lists have the same name."
      },
      name: {
        type: "string",
        description: "New name for the list"
      },
      content: {
        type: "string",
        description: "New description or content for the list"
      },
      status: {
        type: "string",
        description: "New status for the list"
      }
    },
    required: []
  }
};

/**
 * Tool definition for deleting a list
 */
export const deleteListTool = {
  name: "delete_list",
  description: `PERMANENTLY deletes a ClickUp list and all its tasks. Use listId (preferred/safest) or listName. WARNING: Cannot be undone, all tasks will be deleted, listName risky if not unique.`,
  inputSchema: {
    type: "object",
    properties: {
      listId: {
        type: "string",
        description: "ID of the list to delete. Use this instead of listName if you have the ID."
      },
      listName: {
        type: "string",
        description: "Name of the list to delete. May be ambiguous if multiple lists have the same name."
      }
    },
    required: []
  }
};

/**
 * Helper function to find a list ID by name
 * Uses the ClickUp service's global list search functionality
 */
export async function findListIDByName(workspaceService: any, listName: string): Promise<{ id: string; name: string } | null> {
  // Use workspace service to find the list in the hierarchy
  const hierarchy = await workspaceService.getWorkspaceHierarchy();
  const listInfo = workspaceService.findIDByNameInHierarchy(hierarchy, listName, 'list');
  if (!listInfo) return null;
  return { id: listInfo.id, name: listName };
}

/**
 * Handler for the create_list tool
 * Creates a new list directly in a space
 */
export async function handleCreateList(parameters: any) {
  const { name, spaceId, spaceName, content, dueDate, priority, assignee, status } = parameters;
  
  // Validate required fields
  if (!name) {
    throw new Error("List name is required");
  }
  
  let targetSpaceId = spaceId;
  
  // If no spaceId but spaceName is provided, look up the space ID
  if (!targetSpaceId && spaceName) {
    const spaceIdResult = await workspaceService.findSpaceIDByName(spaceName);
    if (!spaceIdResult) {
      throw new Error(`Space "${spaceName}" not found`);
    }
    targetSpaceId = spaceIdResult;
  }
  
  if (!targetSpaceId) {
    throw new Error("Either spaceId or spaceName must be provided");
  }

  // Prepare list data
  const listData: CreateListData = {
    name
  };

  // Add optional fields if provided
  if (content) listData.content = content;
  if (dueDate) listData.due_date = parseInt(dueDate);
  if (priority) listData.priority = priority;
  if (assignee) listData.assignee = assignee;
  if (status) listData.status = status;

  try {
    // Create the list
    const newList = await listService.createList(targetSpaceId, listData);
    
    return sponsorService.createResponse({
      id: newList.id,
      name: newList.name,
      content: newList.content,
      space: {
        id: newList.space.id,
        name: newList.space.name
      },
      url: `https://app.clickup.com/${config.clickupTeamId}/v/l/${newList.id}`,
      message: `List "${name}" created successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to create list: ${error.message}`);
  }
}

/**
 * Handler for the create_list_in_folder tool
 * Creates a new list inside a folder
 */
export async function handleCreateListInFolder(parameters: any) {
  const { name, folderId, folderName, spaceId, spaceName, content, status } = parameters;
  
  // Validate required fields
  if (!name) {
    throw new Error("List name is required");
  }
  
  let targetFolderId = folderId;
  
  // If no folderId but folderName is provided, look up the folder ID
  if (!targetFolderId && folderName) {
    let targetSpaceId = spaceId;
    
    // If no spaceId provided but spaceName is, look up the space ID first
    if (!targetSpaceId && spaceName) {
      const spaceIdResult = await workspaceService.findSpaceByName(spaceName);
      if (!spaceIdResult) {
        throw new Error(`Space "${spaceName}" not found`);
      }
      targetSpaceId = spaceIdResult.id;
    }
    
    if (!targetSpaceId) {
      throw new Error("When using folderName to identify a folder, you must also provide either spaceId or spaceName to locate the correct folder. This is because folder names might not be unique across different spaces.");
    }
    
    // Find the folder in the workspace hierarchy
    const hierarchy = await workspaceService.getWorkspaceHierarchy();
    const folderInfo = workspaceService.findIDByNameInHierarchy(hierarchy, folderName, 'folder');
    if (!folderInfo) {
      throw new Error(`Folder "${folderName}" not found in space`);
    }
    targetFolderId = folderInfo.id;
  }
  
  if (!targetFolderId) {
    throw new Error("Either folderId or folderName must be provided");
  }

  // Prepare list data
  const listData: CreateListData = {
    name
  };

  // Add optional fields if provided
  if (content) listData.content = content;
  if (status) listData.status = status;

  try {
    // Create the list in the folder
    const newList = await listService.createListInFolder(targetFolderId, listData);
    
    return sponsorService.createResponse({
      id: newList.id,
      name: newList.name,
      content: newList.content,
      folder: {
        id: newList.folder.id,
        name: newList.folder.name
      },
      space: {
        id: newList.space.id,
        name: newList.space.name
      },
      url: `https://app.clickup.com/${config.clickupTeamId}/v/l/${newList.id}`,
      message: `List "${name}" created successfully in folder "${newList.folder.name}"`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to create list in folder: ${error.message}`);
  }
}

/**
 * Handler for the get_list tool
 * Retrieves details about a specific list
 */
export async function handleGetList(parameters: any) {
  const { listId, listName } = parameters;
  
  let targetListId = listId;
  
  // If no listId provided but listName is, look up the list ID
  if (!targetListId && listName) {
    const listResult = await findListIDByName(workspaceService, listName);
    if (!listResult) {
      throw new Error(`List "${listName}" not found`);
    }
    targetListId = listResult.id;
  }
  
  if (!targetListId) {
    throw new Error("Either listId or listName must be provided");
  }

  try {
    // Get the list
    const list = await listService.getList(targetListId);
    
    return sponsorService.createResponse({
      id: list.id,
      name: list.name,
      content: list.content,
      space: {
        id: list.space.id,
        name: list.space.name
      },
      url: `https://app.clickup.com/${config.clickupTeamId}/v/l/${list.id}`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to retrieve list: ${error.message}`);
  }
}

/**
 * Handler for the update_list tool
 * Updates an existing list's properties
 */
export async function handleUpdateList(parameters: any) {
  const { listId, listName, name, content, status } = parameters;
  
  let targetListId = listId;
  
  // If no listId provided but listName is, look up the list ID
  if (!targetListId && listName) {
    const listResult = await findListIDByName(workspaceService, listName);
    if (!listResult) {
      throw new Error(`List "${listName}" not found`);
    }
    targetListId = listResult.id;
  }
  
  if (!targetListId) {
    throw new Error("Either listId or listName must be provided");
  }
  
  // Ensure at least one update field is provided
  if (!name && !content && !status) {
    throw new Error("At least one of name, content, or status must be provided for update");
  }

  // Prepare update data
  const updateData: Partial<CreateListData> = {};
  if (name) updateData.name = name;
  if (content) updateData.content = content;
  if (status) updateData.status = status;

  try {
    // Update the list
    const updatedList = await listService.updateList(targetListId, updateData);
    
    return sponsorService.createResponse({
      id: updatedList.id,
      name: updatedList.name,
      content: updatedList.content,
      space: {
        id: updatedList.space.id,
        name: updatedList.space.name
      },
      url: `https://app.clickup.com/${config.clickupTeamId}/v/l/${updatedList.id}`,
      message: `List "${updatedList.name}" updated successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to update list: ${error.message}`);
  }
}

/**
 * Handler for the delete_list tool
 * Permanently removes a list from the workspace
 */
export async function handleDeleteList(parameters: any) {
  const { listId, listName } = parameters;
  
  let targetListId = listId;
  
  // If no listId provided but listName is, look up the list ID
  if (!targetListId && listName) {
    const listResult = await findListIDByName(workspaceService, listName);
    if (!listResult) {
      throw new Error(`List "${listName}" not found`);
    }
    targetListId = listResult.id;
  }
  
  if (!targetListId) {
    throw new Error("Either listId or listName must be provided");
  }

  try {
    // Get list details before deletion for confirmation message
    const list = await listService.getList(targetListId);
    const listName = list.name;
    
    // Delete the list
    await listService.deleteList(targetListId);
    
    return sponsorService.createResponse({
      success: true,
      message: `List "${listName || targetListId}" deleted successfully`
    }, true);
  } catch (error: any) {
    return sponsorService.createErrorResponse(`Failed to delete list: ${error.message}`);
  }
}
</file>

<file path="src/utils/date-utils.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Date Utility Functions
 * 
 * This module provides utilities for handling dates, timestamps, and due date parsing.
 */

import { Logger } from '../logger.js';

// Create a logger instance for date utilities
const logger = new Logger('DateUtils');

/**
 * Get a timestamp for a relative time
 * 
 * @param minutes Minutes from now
 * @param hours Hours from now
 * @param days Days from now
 * @param weeks Weeks from now
 * @param months Months from now
 * @returns Timestamp in milliseconds
 */
export function getRelativeTimestamp(minutes = 0, hours = 0, days = 0, weeks = 0, months = 0): number {
  const now = new Date();
  
  if (minutes) now.setMinutes(now.getMinutes() + minutes);
  if (hours) now.setHours(now.getHours() + hours);
  if (days) now.setDate(now.getDate() + days);
  if (weeks) now.setDate(now.getDate() + (weeks * 7));
  if (months) now.setMonth(now.getMonth() + months);
  
  return now.getTime();
}

/**
 * Get the start of today (midnight) in Unix milliseconds
 * @returns Timestamp in milliseconds for start of current day
 */
export function getStartOfDay(): number {
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  return now.getTime();
}

/**
 * Get the end of today (23:59:59.999) in Unix milliseconds
 * @returns Timestamp in milliseconds for end of current day
 */
export function getEndOfDay(): number {
  const now = new Date();
  now.setHours(23, 59, 59, 999);
  return now.getTime();
}

/**
 * Get the current time in Unix milliseconds
 * @returns Current timestamp in milliseconds
 */
export function getCurrentTimestamp(): number {
  return new Date().getTime();
}

/**
 * Parse a due date string into a timestamp
 * Supports ISO 8601 format or natural language like "tomorrow"
 * 
 * @param dateString Date string to parse
 * @returns Timestamp in milliseconds or undefined if parsing fails
 */
export function parseDueDate(dateString: string): number | undefined {
  if (!dateString) return undefined;
  
  try {
    // Handle natural language dates
    const lowerDate = dateString.toLowerCase().trim();
    
    // Handle "now" specifically
    if (lowerDate === 'now') {
      return getCurrentTimestamp();
    }
    
    // Handle "today" with different options
    if (lowerDate === 'today') {
      return getEndOfDay();
    }
    
    if (lowerDate === 'today start' || lowerDate === 'start of today') {
      return getStartOfDay();
    }
    
    if (lowerDate === 'today end' || lowerDate === 'end of today') {
      return getEndOfDay();
    }
    
    // Handle "yesterday" and "tomorrow"
    if (lowerDate === 'yesterday') {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      yesterday.setHours(23, 59, 59, 999);
      return yesterday.getTime();
    }
    
    if (lowerDate === 'tomorrow') {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(23, 59, 59, 999);
      return tomorrow.getTime();
    }
    
    // Handle relative dates with specific times
    const relativeTimeRegex = /(?:(\d+)\s*(minutes?|hours?|days?|weeks?|months?)\s*from\s*now|tomorrow|next\s+(?:week|month|year))\s*(?:at\s+(\d+)(?::(\d+))?\s*(am|pm)?)?/i;
    const match = lowerDate.match(relativeTimeRegex);
    
    if (match) {
      const date = new Date();
      const [_, amount, unit, hours, minutes, meridian] = match;
      
      // Calculate the future date
      if (amount && unit) {
        const value = parseInt(amount);
        if (unit.startsWith('minute')) {
          date.setMinutes(date.getMinutes() + value);
        } else if (unit.startsWith('hour')) {
          date.setHours(date.getHours() + value);
        } else if (unit.startsWith('day')) {
          date.setDate(date.getDate() + value);
        } else if (unit.startsWith('week')) {
          date.setDate(date.getDate() + (value * 7));
        } else if (unit.startsWith('month')) {
          date.setMonth(date.getMonth() + value);
        }
      } else if (lowerDate.startsWith('tomorrow')) {
        date.setDate(date.getDate() + 1);
      } else if (lowerDate.includes('next week')) {
        date.setDate(date.getDate() + 7);
      } else if (lowerDate.includes('next month')) {
        date.setMonth(date.getMonth() + 1);
      } else if (lowerDate.includes('next year')) {
        date.setFullYear(date.getFullYear() + 1);
      }

      // Set the time if specified
      if (hours) {
        let parsedHours = parseInt(hours);
        const parsedMinutes = minutes ? parseInt(minutes) : 0;
        
        // Convert to 24-hour format if meridian is specified
        if (meridian?.toLowerCase() === 'pm' && parsedHours < 12) parsedHours += 12;
        if (meridian?.toLowerCase() === 'am' && parsedHours === 12) parsedHours = 0;
        
        date.setHours(parsedHours, parsedMinutes, 0, 0);
      } else {
        // Default to end of day if no time specified
        date.setHours(23, 59, 59, 999);
      }
      
      return date.getTime();
    }
    
    // Handle various relative formats
    const relativeFormats = [
      { regex: /(\d+)\s*minutes?\s*from\s*now/i, handler: (m: number) => getRelativeTimestamp(m) },
      { regex: /(\d+)\s*hours?\s*from\s*now/i, handler: (h: number) => getRelativeTimestamp(0, h) },
      { regex: /(\d+)\s*days?\s*from\s*now/i, handler: (d: number) => getRelativeTimestamp(0, 0, d) },
      { regex: /(\d+)\s*weeks?\s*from\s*now/i, handler: (w: number) => getRelativeTimestamp(0, 0, 0, w) },
      { regex: /(\d+)\s*months?\s*from\s*now/i, handler: (m: number) => getRelativeTimestamp(0, 0, 0, 0, m) }
    ];
    
    for (const format of relativeFormats) {
      if (format.regex.test(lowerDate)) {
        const value = parseInt(lowerDate.match(format.regex)![1]);
        return format.handler(value);
      }
    }
    
    // Handle specific date formats
    // Format: MM/DD/YYYY
    const usDateRegex = /^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2})(?::(\d{1,2}))?(?:\s+(am|pm))?)?$/i;
    const usDateMatch = lowerDate.match(usDateRegex);
    
    if (usDateMatch) {
      const [_, month, day, year, hours, minutes, meridian] = usDateMatch;
      const date = new Date(
        parseInt(year),
        parseInt(month) - 1, // JS months are 0-indexed
        parseInt(day)
      );
      
      // Add time if specified
      if (hours) {
        let parsedHours = parseInt(hours);
        const parsedMinutes = minutes ? parseInt(minutes) : 0;
        
        // Convert to 24-hour format if meridian is specified
        if (meridian?.toLowerCase() === 'pm' && parsedHours < 12) parsedHours += 12;
        if (meridian?.toLowerCase() === 'am' && parsedHours === 12) parsedHours = 0;
        
        date.setHours(parsedHours, parsedMinutes, 0, 0);
      } else {
        // Default to end of day if no time specified
        date.setHours(23, 59, 59, 999);
      }
      
      return date.getTime();
    }
    
    // Try to parse as a date string
    const date = new Date(dateString);
    if (!isNaN(date.getTime())) {
      return date.getTime();
    }
    
    // If all parsing fails, return undefined
    return undefined;
  } catch (error) {
    logger.warn(`Failed to parse due date: ${dateString}`, error);
    throw new Error(`Invalid date format: ${dateString}`);
  }
}

/**
 * Format a due date timestamp into a human-readable string
 * 
 * @param timestamp Unix timestamp in milliseconds
 * @returns Formatted date string or undefined if timestamp is invalid
 */
export function formatDueDate(timestamp: number | null | undefined): string | undefined {
  if (!timestamp) return undefined;
  
  try {
    const date = new Date(timestamp);
    
    if (isNaN(date.getTime())) return undefined;
    
    // Format: "March 10, 2025 at 10:56 PM"
    return date.toLocaleString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    }).replace(' at', ',');
  } catch (error) {
    logger.warn(`Failed to format due date: ${timestamp}`, error);
    throw new Error(`Invalid timestamp: ${timestamp}`);
  }
}

/**
 * Checks if a timestamp is for today
 * 
 * @param timestamp Unix timestamp in milliseconds
 * @returns Boolean indicating if the timestamp is for today
 */
export function isToday(timestamp: number): boolean {
  const date = new Date(timestamp);
  const today = new Date();
  
  return date.getDate() === today.getDate() &&
         date.getMonth() === today.getMonth() &&
         date.getFullYear() === today.getFullYear();
}

/**
 * Get timestamp range for today (start to end)
 * 
 * @returns Object with start and end timestamps for today
 */
export function getTodayRange(): { start: number, end: number } {
  return {
    start: getStartOfDay(),
    end: getEndOfDay()
  };
}

/**
 * Format a date for display in errors and messages
 * @param timestamp The timestamp to format
 * @returns A human-readable relative time (e.g., "2 hours ago")
 */
export function formatRelativeTime(timestamp: string | number): string {
  if (!timestamp) return 'Unknown';
  
  const timestampNum = typeof timestamp === 'string' ? parseInt(timestamp, 10) : timestamp;
  const now = Date.now();
  const diffMs = now - timestampNum;
  
  // Convert to appropriate time unit
  const diffSec = Math.floor(diffMs / 1000);
  if (diffSec < 60) return `${diffSec} seconds ago`;
  
  const diffMin = Math.floor(diffSec / 60);
  if (diffMin < 60) return `${diffMin} minutes ago`;
  
  const diffHour = Math.floor(diffMin / 60);
  if (diffHour < 24) return `${diffHour} hours ago`;
  
  const diffDays = Math.floor(diffHour / 24);
  if (diffDays < 30) return `${diffDays} days ago`;
  
  const diffMonths = Math.floor(diffDays / 30);
  if (diffMonths < 12) return `${diffMonths} months ago`;
  
  const diffYears = Math.floor(diffMonths / 12);
  return `${diffYears} years ago`;
}
</file>

<file path="src/utils/resolver-utils.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Resolver Utility Functions
 * 
 * This module provides utilities for resolving entity IDs from names or other identifiers.
 */

import { clickUpServices } from '../services/shared.js';
import { findListIDByName } from '../tools/list.js';

/**
 * Result of a name match operation including the quality of the match
 */
export interface NameMatchResult {
  isMatch: boolean;
  score: number; // 0-100, higher is better
  exactMatch: boolean; // Whether this is an exact match
  reason?: string; // Optional reason for debugging
}

/**
 * Check if a name matches another name using a variety of matching strategies
 * Returns a structured result with match quality information rather than just a boolean
 * 
 * @param actualName The actual name to check
 * @param searchName The name being searched for
 * @returns A structured result with match details
 */
export function isNameMatch(actualName: string, searchName: string): NameMatchResult {
  if (!actualName || !searchName) {
    return { isMatch: false, score: 0, exactMatch: false, reason: 'One of the names is empty' };
  }

  // Remove any extra whitespace
  const normalizedActualName = actualName.trim();
  const normalizedSearchName = searchName.trim();
  
  // Handle empty names after normalization
  if (normalizedActualName === '') {
    return { isMatch: false, score: 0, exactMatch: false, reason: 'Actual name is empty' };
  }
  
  if (normalizedSearchName === '') {
    return { isMatch: false, score: 0, exactMatch: false, reason: 'Search name is empty' };
  }

  // 1. Exact match (highest quality)
  if (normalizedActualName === normalizedSearchName) {
    return { 
      isMatch: true, 
      score: 100, 
      exactMatch: true,
      reason: 'Exact match' 
    };
  }

  // 2. Case-insensitive exact match (high quality)
  if (normalizedActualName.toLowerCase() === normalizedSearchName.toLowerCase()) {
    return { 
      isMatch: true, 
      score: 90, 
      exactMatch: true,
      reason: 'Case-insensitive exact match' 
    };
  }

  // 3. Match after removing emojis (moderate quality)
  const actualNameWithoutEmoji = normalizedActualName.replace(/[\p{Emoji}\u{FE00}-\u{FE0F}\u200d]+/gu, '').trim();
  const searchNameWithoutEmoji = normalizedSearchName.replace(/[\p{Emoji}\u{FE00}-\u{FE0F}\u200d]+/gu, '').trim();
  
  if (actualNameWithoutEmoji === searchNameWithoutEmoji) {
    return { 
      isMatch: true, 
      score: 80, 
      exactMatch: false,
      reason: 'Exact match after removing emojis' 
    };
  }
  
  if (actualNameWithoutEmoji.toLowerCase() === searchNameWithoutEmoji.toLowerCase()) {
    return { 
      isMatch: true, 
      score: 70, 
      exactMatch: false,
      reason: 'Case-insensitive match after removing emojis' 
    };
  }

  // 4. Substring matches (lower quality)
  const lowerActual = normalizedActualName.toLowerCase();
  const lowerSearch = normalizedSearchName.toLowerCase();
  
  // Full substring (term completely contained)
  if (lowerActual.includes(lowerSearch)) {
    return { 
      isMatch: true, 
      score: 60, 
      exactMatch: false,
      reason: 'Search term found as substring in actual name' 
    };
  }
  
  if (lowerSearch.includes(lowerActual)) {
    return { 
      isMatch: true, 
      score: 50, 
      exactMatch: false,
      reason: 'Actual name found as substring in search term' 
    };
  }
  
  // 5. Fuzzy emoji-less matches (lowest quality)
  const lowerActualNoEmoji = actualNameWithoutEmoji.toLowerCase();
  const lowerSearchNoEmoji = searchNameWithoutEmoji.toLowerCase();
  
  if (lowerActualNoEmoji.includes(lowerSearchNoEmoji)) {
    return { 
      isMatch: true, 
      score: 40, 
      exactMatch: false,
      reason: 'Search term (without emoji) found as substring in actual name' 
    };
  }
  
  if (lowerSearchNoEmoji.includes(lowerActualNoEmoji)) {
    return { 
      isMatch: true, 
      score: 30, 
      exactMatch: false,
      reason: 'Actual name (without emoji) found as substring in search term' 
    };
  }

  // No match found
  return { 
    isMatch: false, 
    score: 0, 
    exactMatch: false,
    reason: 'No match found with any matching strategy' 
  };
}

/**
 * Resolve a list ID from either a direct ID or list name
 */
export async function resolveListId(
  listId?: string,
  listName?: string,
  workspaceService = clickUpServices.workspace
): Promise<string> {
  // If list ID is directly provided, use it
  if (listId) {
    return listId;
  }
  
  // If list name is provided, find the corresponding ID
  if (listName) {
    const listInfo = await findListIDByName(workspaceService, listName);
    if (!listInfo) {
      throw new Error(`List "${listName}" not found`);
    }
    return listInfo.id;
  }
  
  // If neither is provided, throw an error
  throw new Error("Either listId or listName must be provided");
}
</file>

<file path="src/index.ts">
#!/usr/bin/env node

/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Server
 * 
 * This custom server implements the Model Context Protocol (MCP) specification to enable
 * AI applications to interact with ClickUp workspaces. It provides a standardized 
 * interface for managing tasks, lists, folders and other ClickUp entities using Natural Language.
 * 
 * Key Features:
 * - Complete task management (CRUD operations, moving, duplicating)
 * - Workspace organization (spaces, folders, lists)
 * - Bulk operations with concurrent processing
 * - Natural language date parsing
 * - File attachments support
 * - Name-based entity resolution
 * - Markdown formatting
 * - Built-in rate limiting
 * 
 * For full documentation and usage examples, please refer to the README.md file.
 */

import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { configureServer, server } from "./server.js";
import { clickUpServices } from "./services/shared.js";
import { info, error } from "./logger.js";
import config from "./config.js";
import { dirname } from 'path';
import { fileURLToPath } from 'url';

// Get directory name for module paths
const __dirname = dirname(fileURLToPath(import.meta.url));

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
  error("Uncaught Exception", { message: err.message, stack: err.stack });
  process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  error("Unhandled Rejection", { reason });
  process.exit(1);
});

/**
 * Application entry point that configures and starts the MCP server.
 */
async function main() {
  try {
    info("Starting ClickUp MCP Server...");
    
    // Log essential information about the environment
    info("Server environment", {
      pid: process.pid,
      node: process.version,
      os: process.platform,
      arch: process.arch
    });
    
    // Configure the server with all handlers
    info("Configuring server request handlers");
    await configureServer();
    
    // Connect using stdio transport
    info("Connecting to MCP stdio transport");
    const transport = new StdioServerTransport();
    await server.connect(transport);
    
    info("Server startup complete - ready to handle requests");
  } catch (err) {
    error("Error during server startup", { message: err.message, stack: err.stack });
    process.exit(1);
  }
}

main().catch((err) => {
  error("Unhandled server error", { message: err.message, stack: err.stack });
  process.exit(1);
});
</file>

<file path="src/logger.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Logger module for MCP Server
 * 
 * This module provides logging functionality for the server,
 * writing logs to only the log file to avoid interfering with JSON-RPC.
 */

import { createWriteStream } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import config, { LogLevel } from './config.js';

// Get the directory name of the current module
const __dirname = dirname(fileURLToPath(import.meta.url));

// Current process ID for logging
const pid = process.pid;

// Create a write stream for logging - use a fixed filename in the build directory
const logFileName = 'server.log';
const logStream = createWriteStream(join(__dirname, logFileName), { flags: 'w' });
// Write init message to log file only
logStream.write(`Logging initialized to ${join(__dirname, logFileName)}\n`);

// Use the configured log level from config.ts
const configuredLevel = config.logLevel;

// Re-export LogLevel enum
export { LogLevel };

/**
 * Check if a log level is enabled based on the configured level
 * @param level The log level to check
 * @returns True if the level should be logged
 */
export function isLevelEnabled(level: LogLevel): boolean {
  return level >= configuredLevel;
}

/**
 * Log function that writes only to file to avoid interfering with JSON-RPC
 * @param level Log level (trace, debug, info, warn, error)
 * @param message Message to log
 * @param data Optional data to include in log
 */
export function log(level: 'trace' | 'debug' | 'info' | 'warn' | 'error', message: string, data?: any) {
  const levelEnum = level === 'trace' ? LogLevel.TRACE 
    : level === 'debug' ? LogLevel.DEBUG
    : level === 'info' ? LogLevel.INFO
    : level === 'warn' ? LogLevel.WARN 
    : LogLevel.ERROR;
  
  // Skip if level is below configured level
  if (!isLevelEnabled(levelEnum)) {
    return;
  }
  
  const timestamp = new Date().toISOString();
  
  // Format the log message differently based on the level and data
  let logMessage = `[${timestamp}] [PID:${pid}] ${level.toUpperCase()}: ${message}`;
  
  // Format data differently based on content and log level
  if (data) {
    // For debugging and trace levels, try to make the data more readable
    if (level === 'debug' || level === 'trace') {
      // If data is a simple object with few properties, format it inline
      if (typeof data === 'object' && data !== null && !Array.isArray(data) && 
          Object.keys(data).length <= 4 && Object.keys(data).every(k => 
            typeof data[k] !== 'object' || data[k] === null)) {
        const dataStr = Object.entries(data)
          .map(([k, v]) => `${k}=${v === undefined ? 'undefined' : 
            (v === null ? 'null' : 
              (typeof v === 'string' ? `"${v}"` : v))}`)
          .join(' ');
        
        logMessage += ` (${dataStr})`;
      } else {
        // For more complex data, keep the JSON format but on new lines
        logMessage += '\n' + JSON.stringify(data, null, 2);
      }
    } else {
      // For other levels, keep the original JSON format
      logMessage += '\n' + JSON.stringify(data, null, 2);
    }
  }

  // Write to file only, not to stderr which would interfere with JSON-RPC
  logStream.write(logMessage + '\n');
}

/**
 * Shorthand for trace level logs
 * @param message Message to log
 * @param data Optional data to include in log
 */
export function trace(message: string, data?: any) {
  log('trace', message, data);
}

/**
 * Shorthand for debug level logs
 * @param message Message to log
 * @param data Optional data to include in log
 */
export function debug(message: string, data?: any) {
  log('debug', message, data);
}

/**
 * Shorthand for info level logs
 * @param message Message to log
 * @param data Optional data to include in log
 */
export function info(message: string, data?: any) {
  log('info', message, data);
}

/**
 * Shorthand for warn level logs
 * @param message Message to log
 * @param data Optional data to include in log
 */
export function warn(message: string, data?: any) {
  log('warn', message, data);
}

/**
 * Shorthand for error level logs
 * @param message Message to log
 * @param data Optional data to include in log
 */
export function error(message: string, data?: any) {
  log('error', message, data);
}

/**
 * Logger class for creating context-specific loggers
 */
export class Logger {
  private context: string;

  /**
   * Create a new logger with context
   * @param context The context to prepend to log messages
   */
  constructor(context: string) {
    this.context = context;
  }

  /**
   * Check if a log level is enabled for this logger
   * @param level The level to check
   * @returns True if logging at this level is enabled
   */
  isLevelEnabled(level: LogLevel): boolean {
    return isLevelEnabled(level);
  }

  /**
   * Log at trace level
   * @param message Message to log
   * @param data Optional data to include in log
   */
  trace(message: string, data?: any) {
    log('trace', `[${this.context}] ${message}`, data);
  }

  /**
   * Log at debug level
   * @param message Message to log
   * @param data Optional data to include in log
   */
  debug(message: string, data?: any) {
    log('debug', `[${this.context}] ${message}`, data);
  }

  /**
   * Log at info level
   * @param message Message to log
   * @param data Optional data to include in log
   */
  info(message: string, data?: any) {
    log('info', `[${this.context}] ${message}`, data);
  }

  /**
   * Log at warn level
   * @param message Message to log
   * @param data Optional data to include in log
   */
  warn(message: string, data?: any) {
    log('warn', `[${this.context}] ${message}`, data);
  }

  /**
   * Log at error level
   * @param message Message to log
   * @param data Optional data to include in log
   */
  error(message: string, data?: any) {
    log('error', `[${this.context}] ${message}`, data);
  }
}

// Handle SIGTERM for clean shutdown
process.on('SIGTERM', () => {
  log('info', 'Received SIGTERM signal, shutting down...');
  logStream.end(() => {
    process.exit(0);
  });
});
</file>

<file path="src/services/clickup/task/task-search.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Search Module
 * 
 * Handles search and lookup operations for tasks in ClickUp, including:
 * - Finding tasks by name
 * - Global workspace task lookup
 * - Task summaries and detailed task data
 */

import { TaskServiceCore } from './task-core.js';
import { 
  ClickUpTask, 
  TaskFilters, 
  TaskSummary,
  WorkspaceTasksResponse,
  DetailedTaskResponse,
  TeamTasksResponse,
  ExtendedTaskFilters,
  UpdateTaskData
} from '../types.js';
import { isNameMatch } from '../../../utils/resolver-utils.js';
import { findListIDByName } from '../../../tools/list.js';
import { estimateTokensFromObject, wouldExceedTokenLimit } from '../../../utils/token-utils.js';

/**
 * Search functionality for the TaskService
 */
export class TaskServiceSearch extends TaskServiceCore {
  /**
   * Find a task by name within a specific list
   * @param listId The ID of the list to search in
   * @param taskName The name of the task to find
   * @returns The task if found, otherwise null
   */
  async findTaskByName(listId: string, taskName: string): Promise<ClickUpTask | null> {
    this.logOperation('findTaskByName', { listId, taskName });
    
    try {
      const tasks = await this.getTasks(listId);
      return this.findTaskInArray(tasks, taskName);
    } catch (error) {
      throw this.handleError(error, `Failed to find task by name: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Find a task by name from an array of tasks
   * @param taskArray Array of tasks to search in
   * @param name Name of the task to search for
   * @param includeDetails Whether to add list context to task
   * @returns The task that best matches the name, or null if no match
   */
  private findTaskInArray(taskArray: any[], name: string, includeDetails = false): any {
    if (!taskArray || !Array.isArray(taskArray) || taskArray.length === 0 || !name) {
      return null;
    }

    // Get match scores for each task
    const taskMatchScores = taskArray
      .map(task => {
        const matchResult = isNameMatch(task.name, name);
        return {
          task,
          matchResult,
          // Parse the date_updated field as a number for sorting
          updatedAt: task.date_updated ? parseInt(task.date_updated, 10) : 0
        };
      })
      .filter(result => result.matchResult.isMatch);

    if (taskMatchScores.length === 0) {
      return null;
    }

    // First, try to find exact matches
    const exactMatches = taskMatchScores
      .filter(result => result.matchResult.exactMatch)
      .sort((a, b) => {
        // For exact matches with the same score, sort by most recently updated
        if (b.matchResult.score === a.matchResult.score) {
          return b.updatedAt - a.updatedAt;
        }
        return b.matchResult.score - a.matchResult.score;
      });

    // Get the best matches based on whether we have exact matches or need to fall back to fuzzy matches
    const bestMatches = exactMatches.length > 0 ? exactMatches : taskMatchScores.sort((a, b) => {
      // First sort by match score (highest first)
      if (b.matchResult.score !== a.matchResult.score) {
        return b.matchResult.score - a.matchResult.score;
      }
      // Then sort by most recently updated
      return b.updatedAt - a.updatedAt;
    });

    // Get the best match
    const bestMatch = bestMatches[0].task;

    // If we need to include more details
    if (includeDetails) {
      // Include any additional details needed
    }

    return bestMatch;
  }

  /**
   * Formats a task into a lightweight summary format
   * @param task The task to format
   * @returns A TaskSummary object
   */
  protected formatTaskSummary(task: ClickUpTask): TaskSummary {
    return {
      id: task.id,
      name: task.name,
      status: task.status.status,
      list: {
        id: task.list.id,
        name: task.list.name
      },
      due_date: task.due_date,
      url: task.url,
      priority: this.extractPriorityValue(task),
      tags: task.tags.map(tag => ({
        name: tag.name,
        tag_bg: tag.tag_bg,
        tag_fg: tag.tag_fg
      }))
    };
  }

  /**
   * Estimates token count for a task in JSON format
   * @param task ClickUp task
   * @returns Estimated token count
   */
  protected estimateTaskTokens(task: ClickUpTask): number {
    return estimateTokensFromObject(task);
  }

  /**
   * Get filtered tasks across the entire team/workspace using tags and other filters
   * @param filters Task filters to apply including tags, list/folder/space filtering
   * @returns Either a DetailedTaskResponse or WorkspaceTasksResponse depending on detail_level
   */
  async getWorkspaceTasks(filters: ExtendedTaskFilters = {}): Promise<DetailedTaskResponse | WorkspaceTasksResponse> {
    try {
      this.logOperation('getWorkspaceTasks', { filters });
      
      const params = this.buildTaskFilterParams(filters);
      const response = await this.makeRequest(async () => {
        return await this.client.get<TeamTasksResponse>(`/team/${this.teamId}/task`, { 
          params 
        });
      });

      const tasks = response.data.tasks;
      const totalCount = tasks.length; // Note: This is just the current page count
      const hasMore = totalCount === 100; // ClickUp returns max 100 tasks per page
      const nextPage = (filters.page || 0) + 1;

      // If the estimated token count exceeds 50,000 or detail_level is 'summary',
      // return summary format for efficiency and to avoid hitting token limits
      const TOKEN_LIMIT = 50000;
      
      // Estimate tokens for the full response
      let tokensExceedLimit = false;
      
      if (filters.detail_level !== 'summary' && tasks.length > 0) {
        // We only need to check token count if detailed was requested
        // For summary requests, we always return summary format
        
        // First check with a sample task - if one task exceeds the limit, we definitely need summary
        const sampleTask = tasks[0];
        
        // Check if all tasks would exceed the token limit
        const estimatedTokensPerTask = this.estimateTaskTokens(sampleTask);
        const estimatedTotalTokens = estimatedTokensPerTask * tasks.length;
        
        // Add 10% overhead for the response wrapper
        tokensExceedLimit = estimatedTotalTokens * 1.1 > TOKEN_LIMIT;
        
        // Double-check with more precise estimation if we're close to the limit
        if (!tokensExceedLimit && estimatedTotalTokens * 1.1 > TOKEN_LIMIT * 0.8) {
          // More precise check - build a representative sample and extrapolate
          tokensExceedLimit = wouldExceedTokenLimit(
            { tasks, total_count: totalCount, has_more: hasMore, next_page: nextPage },
            TOKEN_LIMIT
          );
        }
      }

      // Determine if we should return summary or detailed based on request and token limit
      const shouldUseSummary = filters.detail_level === 'summary' || tokensExceedLimit;

      this.logOperation('getWorkspaceTasks', { 
        totalTasks: tasks.length, 
        estimatedTokens: tasks.reduce((count, task) => count + this.estimateTaskTokens(task), 0), 
        usingDetailedFormat: !shouldUseSummary,
        requestedFormat: filters.detail_level || 'auto'
      });

      if (shouldUseSummary) {
        return {
          summaries: tasks.map(task => this.formatTaskSummary(task)),
          total_count: totalCount,
          has_more: hasMore,
          next_page: nextPage
        };
      }

      return {
        tasks,
        total_count: totalCount,
        has_more: hasMore,
        next_page: nextPage
      };
    } catch (error) {
      this.logOperation('getWorkspaceTasks', { error: error.message, status: error.response?.status });
      throw this.handleError(error, 'Failed to get workspace tasks');
    }
  }

  /**
   * Get task summaries for lightweight retrieval
   * @param filters Task filters to apply
   * @returns WorkspaceTasksResponse with task summaries
   */
  async getTaskSummaries(filters: TaskFilters = {}): Promise<WorkspaceTasksResponse> {
    return this.getWorkspaceTasks({ ...filters, detail_level: 'summary' }) as Promise<WorkspaceTasksResponse>;
  }

  /**
   * Get detailed task data
   * @param filters Task filters to apply
   * @returns DetailedTaskResponse with full task data
   */
  async getTaskDetails(filters: TaskFilters = {}): Promise<DetailedTaskResponse> {
    return this.getWorkspaceTasks({ ...filters, detail_level: 'detailed' }) as Promise<DetailedTaskResponse>;
  }

  /**
   * Unified method for finding tasks by ID or name with consistent handling of global lookup
   * 
   * This method provides a single entry point for all task lookup operations:
   * - Direct lookup by task ID (highest priority)
   * - Lookup by task name within a specific list
   * - Global lookup by task name across the entire workspace
   * 
   * @param options Lookup options with the following parameters:
   *   - taskId: Optional task ID for direct lookup
   *   - customTaskId: Optional custom task ID for direct lookup
   *   - taskName: Optional task name to search for
   *   - listId: Optional list ID to scope the search
   *   - listName: Optional list name to scope the search
   *   - allowMultipleMatches: Whether to return all matches instead of throwing an error
   *   - useSmartDisambiguation: Whether to automatically select the most recently updated task
   *   - includeFullDetails: Whether to include full task details (true) or just task summaries (false)
   *   - includeListContext: Whether to include list/folder/space context with results
   *   - requireExactMatch: Whether to only consider exact name matches (true) or allow fuzzy matches (false)
   * @returns Either a single task or an array of tasks depending on options
   * @throws Error if task cannot be found or if multiple matches are found when not allowed
   */
  async findTasks({
    taskId,
    customTaskId,
    taskName,
    listId,
    listName,
    allowMultipleMatches = false,
    useSmartDisambiguation = true,
    includeFullDetails = true,
    includeListContext = false,
    requireExactMatch = false
  }: {
    taskId?: string;
    customTaskId?: string;
    taskName?: string;
    listId?: string;
    listName?: string;
    allowMultipleMatches?: boolean;
    useSmartDisambiguation?: boolean;
    includeFullDetails?: boolean;
    includeListContext?: boolean;
    requireExactMatch?: boolean;
  }): Promise<ClickUpTask | ClickUpTask[] | null> {
    try {
      this.logOperation('findTasks', { 
        taskId, 
        customTaskId, 
        taskName, 
        listId, 
        listName,
        allowMultipleMatches,
        useSmartDisambiguation,
        requireExactMatch
      });

      // Check name-to-ID cache first if we have a task name
      if (taskName && !taskId && !customTaskId) {
        // Resolve list ID if we have a list name
        let resolvedListId = listId;
        if (listName && !listId) {
          const listInfo = await findListIDByName(this.workspaceService!, listName);
          if (listInfo) {
            resolvedListId = listInfo.id;
          }
        }

        // Try to get cached task ID
        const cachedTaskId = this.getCachedTaskId(taskName, resolvedListId);
        if (cachedTaskId) {
          this.logOperation('findTasks', { 
            message: 'Using cached task ID for name lookup',
            taskName,
            cachedTaskId
          });
          taskId = cachedTaskId;
        }
      }
      
      // Case 1: Direct task ID lookup (highest priority)
      if (taskId) {
        // Check if it looks like a custom ID
        if (taskId.includes('-') && /^[A-Z]+\-\d+$/.test(taskId)) {
          this.logOperation('findTasks', { detectedCustomId: taskId });
          
          try {
            // Try to get it as a custom ID first
            let resolvedListId: string | undefined;
            if (listId) {
              resolvedListId = listId;
            } else if (listName) {
              const listInfo = await findListIDByName(this.workspaceService!, listName);
              if (listInfo) {
                resolvedListId = listInfo.id;
              }
            }
            
            const foundTask = await this.getTaskByCustomId(taskId, resolvedListId);
            return foundTask;
          } catch (error) {
            // If it fails as a custom ID, try as a regular ID
            this.logOperation('findTasks', { 
              message: `Failed to find task with custom ID "${taskId}", falling back to regular ID`,
              error: error.message
            });
            return await this.getTask(taskId);
          }
        }
        
        // Regular task ID
        return await this.getTask(taskId);
      }
      
      // Case 2: Explicit custom task ID lookup
      if (customTaskId) {
        let resolvedListId: string | undefined;
        if (listId) {
          resolvedListId = listId;
        } else if (listName) {
          const listInfo = await findListIDByName(this.workspaceService!, listName);
          if (listInfo) {
            resolvedListId = listInfo.id;
          }
        }
        
        return await this.getTaskByCustomId(customTaskId, resolvedListId);
      }
      
      // Case 3: Task name lookup (requires either list context or global lookup)
      if (taskName) {
        // Case 3a: Task name + list context - search in specific list
        if (listId || listName) {
          let resolvedListId: string;
          if (listId) {
            resolvedListId = listId;
          } else {
            const listInfo = await findListIDByName(this.workspaceService!, listName!);
            if (!listInfo) {
              throw new Error(`List "${listName}" not found`);
            }
            resolvedListId = listInfo.id;
          }
          
          const foundTask = this.findTaskInArray(await this.getTasks(resolvedListId), taskName, includeListContext);
          if (!foundTask) {
            throw new Error(`Task "${taskName}" not found in list`);
          }

          // Cache the task name to ID mapping with list context
          this.cacheTaskNameToId(taskName, foundTask.id, resolvedListId);
          
          // If includeFullDetails is true and we need context not already in the task,
          // get full details, otherwise return what we already have
          if (includeFullDetails && (!foundTask.list || !foundTask.list.name || !foundTask.status)) {
            return await this.getTask(foundTask.id);
          }
          
          return foundTask;
        }
        
        // Case 3b: Task name without list context - global lookup across workspace
        // Get lightweight task summaries for efficient first-pass filtering
        this.logOperation('findTasks', { 
          message: `Starting global task search for "${taskName}"`,
          includeFullDetails,
          useSmartDisambiguation,
          requireExactMatch
        });
        
        // Use statuses parameter to get both open and closed tasks
        // Include additional filters to ensure we get as many tasks as possible
        const response = await this.getTaskSummaries({
          include_closed: true,
          include_archived_lists: true,
          include_closed_lists: true,
          subtasks: true
        });
        
        if (!this.workspaceService) {
          throw new Error("Workspace service required for global task lookup");
        }
        
        // Create an index to efficiently look up list context information
        const hierarchy = await this.workspaceService.getWorkspaceHierarchy();
        const listContextMap = new Map<string, { 
          listId: string, 
          listName: string, 
          spaceId: string, 
          spaceName: string, 
          folderId?: string, 
          folderName?: string 
        }>();
        
        // Function to recursively build list context map
        function buildListContextMap(nodes: any[], spaceId?: string, spaceName?: string, folderId?: string, folderName?: string) {
          for (const node of nodes) {
            if (node.type === 'space') {
              // Process space children
              if (node.children) {
                buildListContextMap(node.children, node.id, node.name);
              }
            } else if (node.type === 'folder') {
              // Process folder children
              if (node.children) {
                buildListContextMap(node.children, spaceId, spaceName, node.id, node.name);
              }
            } else if (node.type === 'list') {
              // Add list context to map
              listContextMap.set(node.id, {
                listId: node.id,
                listName: node.name,
                spaceId: spaceId!,
                spaceName: spaceName!,
                folderId,
                folderName
              });
            }
          }
        }
        
        // Build the context map
        buildListContextMap(hierarchy.root.children);
        
        // Find tasks that match the provided name with scored match results
        const initialMatches: { 
          id: string, 
          task: any, 
          listContext: any,
          matchScore: number,
          matchReason: string
        }[] = [];
        
        // Process task summaries to find initial matches
        let taskCount = 0;
        let matchesFound = 0;
        
        // Add additional logging to debug task matching
        this.logOperation('findTasks', { 
          total_tasks_in_response: response.summaries.length,
          search_term: taskName,
          requireExactMatch
        });
        
        for (const taskSummary of response.summaries) {
          taskCount++;
          
          // Use isNameMatch for consistent matching behavior with scoring
          const matchResult = isNameMatch(taskSummary.name, taskName);
          const isMatch = matchResult.isMatch;
          
          // For debugging, log every 20th task or any task with a similar name
          if (taskCount % 20 === 0 || taskSummary.name.toLowerCase().includes(taskName.toLowerCase()) || 
              taskName.toLowerCase().includes(taskSummary.name.toLowerCase())) {
            this.logOperation('findTasks:matching', { 
              task_name: taskSummary.name,
              search_term: taskName,
              list_name: taskSummary.list?.name || 'Unknown list',
              is_match: isMatch,
              match_score: matchResult.score,
              match_reason: matchResult.reason || 'no-match'
            });
          }
          
          if (isMatch) {
            matchesFound++;
            // Get list context information
            const listContext = listContextMap.get(taskSummary.list.id);
            
            if (listContext) {
              // Store task summary and context with match score
              initialMatches.push({
                id: taskSummary.id,
                task: taskSummary,
                listContext,
                matchScore: matchResult.score,
                matchReason: matchResult.reason || 'unknown'
              });
            }
          }
        }
        
        this.logOperation('findTasks', { 
          globalSearch: true, 
          searchTerm: taskName,
          tasksSearched: taskCount,
          matchesFound: matchesFound,
          validMatchesWithContext: initialMatches.length
        });
        
        // Handle the no matches case
        if (initialMatches.length === 0) {
          throw new Error(`Task "${taskName}" not found in any list across your workspace. Please check the task name and try again.`);
        }
        
        // Sort matches by match score first (higher is better), then by update time
        initialMatches.sort((a, b) => {
          // First sort by match score (highest first)
          if (b.matchScore !== a.matchScore) {
            return b.matchScore - a.matchScore;
          }
          
          // Try to get the date_updated from the task
          const aDate = a.task.date_updated ? parseInt(a.task.date_updated, 10) : 0;
          const bDate = b.task.date_updated ? parseInt(b.task.date_updated, 10) : 0;
          
          // For equal scores, sort by most recently updated
          return bDate - aDate;
        });
        
        // Handle the single match case - we can return early if we don't need full details
        if (initialMatches.length === 1 && !useSmartDisambiguation && !includeFullDetails) {
          const match = initialMatches[0];
          
          if (includeListContext) {
            return {
              ...match.task,
              list: {
                id: match.listContext.listId,
                name: match.listContext.listName
              },
              folder: match.listContext.folderId ? {
                id: match.listContext.folderId,
                name: match.listContext.folderName
              } : undefined,
              space: {
                id: match.listContext.spaceId,
                name: match.listContext.spaceName
              }
            };
          }
          
          return match.task;
        }
        
        // Handle the exact match case - if there's an exact or very good match, prefer it over others
        // This is our key improvement to prefer exact matches over update time
        const bestMatchScore = initialMatches[0].matchScore;
        if (bestMatchScore >= 80) { // 80+ is an exact match or case-insensitive exact match
          // If there's a single best match with score 80+, use it directly
          const exactMatches = initialMatches.filter(m => m.matchScore >= 80);
          
          if (exactMatches.length === 1 && !allowMultipleMatches) {
            this.logOperation('findTasks', { 
              message: `Found single exact match with score ${exactMatches[0].matchScore}, prioritizing over other matches`,
              matchReason: exactMatches[0].matchReason
            });
            
            // If we don't need details, return early
            if (!includeFullDetails) {
              const match = exactMatches[0];
              if (includeListContext) {
                return {
                  ...match.task,
                  list: {
                    id: match.listContext.listId,
                    name: match.listContext.listName
                  },
                  folder: match.listContext.folderId ? {
                    id: match.listContext.folderId,
                    name: match.listContext.folderName
                  } : undefined,
                  space: {
                    id: match.listContext.spaceId,
                    name: match.listContext.spaceName
                  }
                };
              }
              return match.task;
            }
            
            // Otherwise, get the full details
            const fullTask = await this.getTask(exactMatches[0].id);
            
            if (includeListContext) {
              const match = exactMatches[0];
              // Enhance task with context information
              (fullTask as any).list = {
                ...fullTask.list,
                name: match.listContext.listName
              };
              
              if (match.listContext.folderId) {
                (fullTask as any).folder = {
                  id: match.listContext.folderId,
                  name: match.listContext.folderName
                };
              }
              
              (fullTask as any).space = {
                id: match.listContext.spaceId,
                name: match.listContext.spaceName
              };
            }
            
            return fullTask;
          }
        }
        
        // For multiple matches or when we need details, fetch full task info
        const fullMatches: ClickUpTask[] = [];
        const matchScoreMap = new Map<string, number>(); // To preserve match scores
        
        try {
          // Process in sequence for better reliability
          for (const match of initialMatches) {
            const fullTask = await this.getTask(match.id);
            matchScoreMap.set(fullTask.id, match.matchScore);
            
            if (includeListContext) {
              // Enhance task with context information
              (fullTask as any).list = {
                ...fullTask.list,
                name: match.listContext.listName
              };
              
              if (match.listContext.folderId) {
                (fullTask as any).folder = {
                  id: match.listContext.folderId,
                  name: match.listContext.folderName
                };
              }
              
              (fullTask as any).space = {
                id: match.listContext.spaceId,
                name: match.listContext.spaceName
              };
            }
            
            fullMatches.push(fullTask);
          }
          
          // Sort matches - first by match score, then by update time
          if (fullMatches.length > 1) {
            fullMatches.sort((a, b) => {
              // First sort by match score (highest first)
              const aScore = matchScoreMap.get(a.id) || 0;
              const bScore = matchScoreMap.get(b.id) || 0;
              
              if (aScore !== bScore) {
                return bScore - aScore;
              }
              
              // For equal scores, sort by update time
              const aDate = parseInt(a.date_updated || '0', 10);
              const bDate = parseInt(b.date_updated || '0', 10);
              return bDate - aDate; // Most recent first
            });
          }
        } catch (error) {
          this.logOperation('findTasks', { 
            error: error.message, 
            message: "Failed to get detailed task information" 
          });
          
          // If detailed fetch fails, use the summaries with context info
          // This fallback ensures we still return something useful
          if (allowMultipleMatches) {
            return initialMatches.map(match => ({
              ...match.task,
              list: {
                id: match.listContext.listId,
                name: match.listContext.listName
              },
              folder: match.listContext.folderId ? {
                id: match.listContext.folderId,
                name: match.listContext.folderName
              } : undefined,
              space: {
                id: match.listContext.spaceId,
                name: match.listContext.spaceName
              }
            }));
          } else {
            // For single result, return the first match (best match score)
            const match = initialMatches[0];
            return {
              ...match.task,
              list: {
                id: match.listContext.listId,
                name: match.listContext.listName
              },
              folder: match.listContext.folderId ? {
                id: match.listContext.folderId,
                name: match.listContext.folderName
              } : undefined,
              space: {
                id: match.listContext.spaceId,
                name: match.listContext.spaceName
              }
            };
          }
        }
        
        // After finding the task in global search, cache the mapping
        if (initialMatches.length === 1 || useSmartDisambiguation) {
          const bestMatch = fullMatches[0];
          this.cacheTaskNameToId(taskName, bestMatch.id, bestMatch.list?.id);
          return bestMatch;
        }
        
        // Return results based on options
        if (fullMatches.length === 1 || useSmartDisambiguation) {
          return fullMatches[0]; // Return best match (sorted by score then update time)
        } else if (allowMultipleMatches) {
          return fullMatches; // Return all matches
        } else {
          // Format error message for multiple matches
          const matchesInfo = fullMatches.map(task => {
            const listName = task.list?.name || "Unknown list";
            const folderName = (task as any).folder?.name;
            const spaceName = (task as any).space?.name || "Unknown space";
            
            const updateTime = task.date_updated 
              ? new Date(parseInt(task.date_updated, 10)).toLocaleString()
              : "Unknown date";
              
            const matchScore = matchScoreMap.get(task.id) || 0;
            const matchQuality = 
              matchScore >= 100 ? "Exact match" :
              matchScore >= 80 ? "Case-insensitive exact match" :
              matchScore >= 70 ? "Text match ignoring emojis" :
              matchScore >= 50 ? "Contains search term" :
              "Partial match";
              
            const location = `list "${listName}"${folderName ? ` (folder: "${folderName}")` : ''} (space: "${spaceName}")`;
            return `- "${task.name}" in ${location} - Updated ${updateTime} - Match quality: ${matchQuality} (${matchScore}/100)`;
          }).join('\n');
          
          throw new Error(`Multiple tasks found with name "${taskName}":\n${matchesInfo}\n\nPlease provide list context to disambiguate, use the exact task name with requireExactMatch=true, or set allowMultipleMatches to true.`);
        }
      }
      
      // No valid lookup parameters provided
      throw new Error("At least one of taskId, customTaskId, or taskName must be provided");
    } catch (error) {
      if (error.message?.includes('Task "') && error.message?.includes('not found')) {
        throw error;
      }
      
      if (error.message?.includes('Multiple tasks found')) {
        throw error;
      }
      
      // Unexpected errors
      throw this.handleError(error, `Error finding task: ${error.message}`);
    }
  }

  /**
   * Update a task by name within a specific list
   * @param listId The ID of the list containing the task
   * @param taskName The name of the task to update
   * @param updateData The data to update the task with
   * @returns The updated task
   */
  async updateTaskByName(listId: string, taskName: string, updateData: UpdateTaskData): Promise<ClickUpTask> {
    this.logOperation('updateTaskByName', { listId, taskName, ...updateData });
    
    try {
      const task = await this.findTaskByName(listId, taskName);
      if (!task) {
        throw new Error(`Task "${taskName}" not found in list ${listId}`);
      }
      
      return await this.updateTask(task.id, updateData);
    } catch (error) {
      throw this.handleError(error, `Failed to update task by name: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Global task search by name across all lists
   * This is a specialized method that uses getWorkspaceTasks to search all lists at once
   * which is more efficient than searching list by list
   * 
   * @param taskName The name to search for
   * @returns The best matching task or null if no match found
   */
  async findTaskByNameGlobally(taskName: string): Promise<ClickUpTask | null> {
    this.logOperation('findTaskByNameGlobally', { taskName });
    
    // Use a static cache for task data to avoid redundant API calls
    // This dramatically reduces API usage across multiple task lookups
    if (!this.constructor.hasOwnProperty('_taskCache')) {
      Object.defineProperty(this.constructor, '_taskCache', {
        value: {
          tasks: [],
          lastFetch: 0,
          cacheTTL: 60000, // 1 minute cache TTL
        },
        writable: true
      });
    }
    
    const cache = (this.constructor as any)._taskCache;
    const now = Date.now();
    
    try {
      // Use cached tasks if available and not expired
      let tasks: ClickUpTask[] = [];
      if (cache.tasks.length > 0 && (now - cache.lastFetch) < cache.cacheTTL) {
        this.logOperation('findTaskByNameGlobally', { 
          usedCache: true, 
          cacheAge: now - cache.lastFetch,
          taskCount: cache.tasks.length 
        });
        tasks = cache.tasks;
      } else {
        // Get tasks using a single efficient workspace-wide API call
        const response = await this.getWorkspaceTasks({
          include_closed: true,
          detail_level: 'detailed'
        });
        
        tasks = 'tasks' in response ? response.tasks : [];
        
        // Update cache
        cache.tasks = tasks;
        cache.lastFetch = now;
        
        this.logOperation('findTaskByNameGlobally', { 
          usedCache: false, 
          fetchedTaskCount: tasks.length
        });
      }
      
      // Map tasks to include match scores and updated time for sorting
      const taskMatches = tasks.map(task => {
        const matchResult = isNameMatch(task.name, taskName);
        return {
          task,
          matchResult,
          updatedAt: task.date_updated ? parseInt(task.date_updated, 10) : 0
        };
      }).filter(result => result.matchResult.isMatch);
      
      this.logOperation('findTaskByNameGlobally', { 
        taskCount: tasks.length,
        matchCount: taskMatches.length,
        taskName
      });
      
      if (taskMatches.length === 0) {
        return null;
      }
      
      // First try exact matches
      const exactMatches = taskMatches
        .filter(result => result.matchResult.exactMatch)
        .sort((a, b) => {
          // For exact matches with the same score, sort by most recently updated
          if (b.matchResult.score === a.matchResult.score) {
            return b.updatedAt - a.updatedAt;
          }
          return b.matchResult.score - a.matchResult.score;
        });
      
      // Get the best matches based on whether we have exact matches or need to fall back to fuzzy matches
      const bestMatches = exactMatches.length > 0 ? exactMatches : taskMatches.sort((a, b) => {
        // First sort by match score (highest first)
        if (b.matchResult.score !== a.matchResult.score) {
          return b.matchResult.score - a.matchResult.score;
        }
        // Then sort by most recently updated
        return b.updatedAt - a.updatedAt;
      });
      
      // Log the top matches for debugging
      const topMatches = bestMatches.slice(0, 3).map(match => ({
        taskName: match.task.name,
        score: match.matchResult.score,
        reason: match.matchResult.reason,
        updatedAt: match.updatedAt,
        list: match.task.list?.name || 'Unknown list'
      }));
      
      this.logOperation('findTaskByNameGlobally', { topMatches });
      
      // Return the best match
      return bestMatches[0].task;
    } catch (error) {
      this.logOperation('findTaskByNameGlobally', { error: error.message });
      
      // If there's an error (like rate limit), try to use cached data even if expired
      if (cache.tasks.length > 0) {
        this.logOperation('findTaskByNameGlobally', { 
          message: 'Using expired cache due to API error',
          cacheAge: now - cache.lastFetch
        });
        
        // Perform the same matching logic with cached data
        const taskMatches = cache.tasks
          .map(task => {
            const matchResult = isNameMatch(task.name, taskName);
            return {
              task,
              matchResult,
              updatedAt: task.date_updated ? parseInt(task.date_updated, 10) : 0
            };
          })
          .filter(result => result.matchResult.isMatch)
          .sort((a, b) => {
            if (b.matchResult.score !== a.matchResult.score) {
              return b.matchResult.score - a.matchResult.score;
            }
            return b.updatedAt - a.updatedAt;
          });
          
        if (taskMatches.length > 0) {
          return taskMatches[0].task;
        }
      }
      
      return null;
    }
  }
}
</file>

<file path="src/tools/tag.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Tag Tools
 * 
 * Provides tools for managing tags in ClickUp:
 * - Get space tags
 * - Create, update, delete space tags
 * - Add/remove tags to/from tasks
 */

import { ErrorCode, ServiceResponse } from '../services/clickup/base.js';
import { clickUpServices } from '../services/shared.js';
import { Logger } from '../logger.js';
import { sponsorService } from '../utils/sponsor-service.js';
import { ClickUpTag } from '../services/clickup/types.js';
import { processColorCommand } from '../utils/color-processor.js';
import { validateTaskIdentification } from './task/utilities.js';

// Create a logger specific to tag tools
const logger = new Logger('TagTools');

// Use shared services instance
const { task: taskService } = clickUpServices;

//=============================================================================
// TOOL DEFINITIONS
//=============================================================================

/**
 * Tool definition for getting space tags
 */
export const getSpaceTagsTool = {
  name: "get_space_tags",
  description: `Gets all tags in a ClickUp space. Use spaceId (preferred) or spaceName. Tags are defined at space level - check available tags before adding to tasks.`,
  inputSchema: {
    type: "object",
    properties: {
      spaceId: {
        type: "string",
        description: "ID of the space to get tags from. Use this instead of spaceName if you have the ID."
      },
      spaceName: {
        type: "string",
        description: "Name of the space to get tags from. Only use if you don't have spaceId."
      }
    }
  }
};

/**
 * Tool definition for creating a tag in a space
 */
export const createSpaceTagTool = {
  name: "create_space_tag",
  description: `Purpose: Create a new tag in a ClickUp space.

Valid Usage:
1. Provide spaceId (preferred if available)
2. Provide spaceName (will be resolved to a space ID)

Requirements:
- tagName: REQUIRED
- EITHER spaceId OR spaceName: REQUIRED

Notes:
- New tag will be available for all tasks in the space
- You can specify background and foreground colors in HEX format (e.g., #FF0000)
- You can also provide a color command (e.g., "blue tag") to automatically generate colors
- After creating a tag, you can add it to tasks using add_tag_to_task`,
  inputSchema: {
    type: "object",
    properties: {
      spaceId: {
        type: "string",
        description: "ID of the space to create tag in. Use this instead of spaceName if you have the ID."
      },
      spaceName: {
        type: "string",
        description: "Name of the space to create tag in. Only use if you don't have spaceId."
      },
      tagName: {
        type: "string",
        description: "Name of the tag to create."
      },
      tagBg: {
        type: "string",
        description: "Background color for the tag in HEX format (e.g., #FF0000). Defaults to #000000 (black)."
      },
      tagFg: {
        type: "string",
        description: "Foreground (text) color for the tag in HEX format (e.g., #FFFFFF). Defaults to #FFFFFF (white)."
      },
      colorCommand: {
        type: "string",
        description: "Natural language color command (e.g., 'blue tag', 'dark red background'). When provided, this will override tagBg and tagFg with automatically generated values."
      }
    },
    required: ["tagName"]
  }
};

/**
 * Tool definition for updating a tag in a space
 */
export const updateSpaceTagTool = {
  name: "update_space_tag",
  description: `Purpose: Update an existing tag in a ClickUp space.

Valid Usage:
1. Provide spaceId (preferred if available)
2. Provide spaceName (will be resolved to a space ID)

Requirements:
- tagName: REQUIRED
- EITHER spaceId OR spaceName: REQUIRED
- At least one of newTagName, tagBg, tagFg, or colorCommand must be provided

Notes:
- Changes to the tag will apply to all tasks in the space that use this tag
- You can provide a color command (e.g., "blue tag") to automatically generate colors
- You cannot partially update a tag - provide all properties you want to keep`,
  inputSchema: {
    type: "object",
    properties: {
      spaceId: {
        type: "string",
        description: "ID of the space containing the tag. Use this instead of spaceName if you have the ID."
      },
      spaceName: {
        type: "string",
        description: "Name of the space containing the tag. Only use if you don't have spaceId."
      },
      tagName: {
        type: "string",
        description: "Current name of the tag to update."
      },
      newTagName: {
        type: "string",
        description: "New name for the tag."
      },
      tagBg: {
        type: "string",
        description: "New background color for the tag in HEX format (e.g., #FF0000)."
      },
      tagFg: {
        type: "string",
        description: "New foreground (text) color for the tag in HEX format (e.g., #FFFFFF)."
      },
      colorCommand: {
        type: "string",
        description: "Natural language color command (e.g., 'blue tag', 'dark red background'). When provided, this will override tagBg and tagFg with automatically generated values."
      }
    },
    required: ["tagName"]
  }
};

/**
 * Tool definition for deleting a tag in a space
 */
export const deleteSpaceTagTool = {
  name: "delete_space_tag",
  description: `Purpose: Delete a tag from a ClickUp space.

Valid Usage:
1. Provide spaceId (preferred if available)
2. Provide spaceName (will be resolved to a space ID)

Requirements:
- tagName: REQUIRED
- EITHER spaceId OR spaceName: REQUIRED

Warning:
- This will remove the tag from all tasks in the space
- This action cannot be undone`,
  inputSchema: {
    type: "object",
    properties: {
      spaceId: {
        type: "string",
        description: "ID of the space containing the tag. Use this instead of spaceName if you have the ID."
      },
      spaceName: {
        type: "string",
        description: "Name of the space containing the tag. Only use if you don't have spaceId."
      },
      tagName: {
        type: "string",
        description: "Name of the tag to delete."
      }
    },
    required: ["tagName"]
  }
};

/**
 * Tool definition for adding a tag to a task
 */
export const addTagToTaskTool = {
  name: "add_tag_to_task",
  description: `Adds existing tag to task. Use taskId (preferred) or taskName + optional listName. Tag must exist in space (use get_space_tags to verify, create_space_tag if needed). WARNING: Will fail if tag doesn't exist.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to add tag to. Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      customTaskId: {
        type: "string",
        description: "Custom task ID (e.g., 'DEV-1234'). Only use if you want to explicitly force custom ID lookup. In most cases, use taskId which auto-detects ID format."
      },
      taskName: {
        type: "string",
        description: "Name of the task to add tag to. Will search across all lists unless listName is provided."
      },
      listName: {
        type: "string",
        description: "Optional: Name of the list containing the task. Use to disambiguate when multiple tasks have the same name."
      },
      tagName: {
        type: "string",
        description: "Name of the tag to add to the task. The tag must already exist in the space."
      }
    },
    required: ["tagName"]
  }
};

/**
 * Tool definition for removing a tag from a task
 */
export const removeTagFromTaskTool = {
  name: "remove_tag_from_task",
  description: `Removes tag from task. Use taskId (preferred) or taskName + optional listName. Only removes tag-task association, tag remains in space. For multiple tasks, provide listName to disambiguate.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to remove tag from. Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      customTaskId: {
        type: "string",
        description: "Custom task ID (e.g., 'DEV-1234'). Only use if you want to explicitly force custom ID lookup. In most cases, use taskId which auto-detects ID format."
      },
      taskName: {
        type: "string",
        description: "Name of the task to remove tag from. Will search across all lists unless listName is provided."
      },
      listName: {
        type: "string",
        description: "Optional: Name of the list containing the task. Use to disambiguate when multiple tasks have the same name."
      },
      tagName: {
        type: "string",
        description: "Name of the tag to remove from the task."
      }
    },
    required: ["tagName"]
  }
};

//=============================================================================
// HANDLER WRAPPER UTILITY
//=============================================================================

/**
 * Creates a wrapped handler function with standard error handling and response formatting
 */
function createHandlerWrapper<T>(
  handler: (params: any) => Promise<T>,
  formatResponse: (result: T) => any = (result) => result
) {
  return async (params: any) => {
    try {
      logger.debug('Handler called with params', { params });
      
      // Call the handler
      const result = await handler(params);
      
      // Format the result for response
      const formattedResult = formatResponse(result);
      
      // Use the sponsor service to create the formatted response
      return sponsorService.createResponse(formattedResult, true);
    } catch (error: any) {
      // Log the error
      logger.error('Error in handler', { error: error.message, code: error.code });
      
      // Format and return the error using sponsor service
      return sponsorService.createErrorResponse(error, params);
    }
  };
}

//=============================================================================
// TAG TOOL HANDLERS
//=============================================================================

/**
 * Wrapper for getSpaceTags handler
 */
export const handleGetSpaceTags = createHandlerWrapper(
  getSpaceTags,
  (tags: ClickUpTag[]) => ({
    tags: tags || [],
    count: Array.isArray(tags) ? tags.length : 0
  })
);

/**
 * Wrapper for createSpaceTag handler
 */
export const handleCreateSpaceTag = createHandlerWrapper(createSpaceTag);

/**
 * Wrapper for updateSpaceTag handler
 */
export const handleUpdateSpaceTag = createHandlerWrapper(updateSpaceTag);

/**
 * Wrapper for deleteSpaceTag handler
 */
export const handleDeleteSpaceTag = createHandlerWrapper(deleteSpaceTag, () => ({
  success: true,
  message: "Tag deleted successfully"
}));

/**
 * Wrapper for addTagToTask handler
 */
export const handleAddTagToTask = createHandlerWrapper(addTagToTask, (result) => {
  if (!result.success) {
    return {
      success: false,
      error: result.error
    };
  }
  return {
    success: true,
    message: "Tag added to task successfully"
  };
});

/**
 * Wrapper for removeTagFromTask handler
 */
export const handleRemoveTagFromTask = createHandlerWrapper(removeTagFromTask, () => ({
  success: true,
  message: "Tag removed from task successfully"
}));

//=============================================================================
// TOOL DEFINITIONS AND HANDLERS EXPORT
//=============================================================================

// Tool definitions with their handler mappings
export const tagTools = [
  { definition: getSpaceTagsTool, handler: handleGetSpaceTags },
  { definition: createSpaceTagTool, handler: handleCreateSpaceTag },
  { definition: updateSpaceTagTool, handler: handleUpdateSpaceTag },
  { definition: deleteSpaceTagTool, handler: handleDeleteSpaceTag },
  { definition: addTagToTaskTool, handler: handleAddTagToTask },
  { definition: removeTagFromTaskTool, handler: handleRemoveTagFromTask }
];

/**
 * Get all tags in a space
 * @param params - Space identifier (id or name)
 * @returns Tags in the space
 */
export async function getSpaceTags(params: {
  spaceId?: string;
  spaceName?: string;
}): Promise<ClickUpTag[]> {
  const { spaceId, spaceName } = params;
  
  if (!spaceId && !spaceName) {
    logger.error('getSpaceTags called without required parameters');
    throw new Error('Either spaceId or spaceName is required');
  }

  logger.info('Getting tags for space', { spaceId, spaceName });
  
  try {
    // If spaceName is provided, we need to resolve it to an ID
    let resolvedSpaceId = spaceId;
    if (!resolvedSpaceId && spaceName) {
      logger.debug(`Resolving space name: ${spaceName}`);
      
      const spaces = await clickUpServices.workspace.getSpaces();
      
      const space = spaces.find(s => 
        s.name.toLowerCase() === spaceName.toLowerCase()
      );
      
      if (!space) {
        logger.error(`Space not found: ${spaceName}`);
        throw new Error(`Space not found: ${spaceName}`);
      }
      
      resolvedSpaceId = space.id;
    }
    
    // Get tags from the space
    const tagsResponse = await clickUpServices.tag.getSpaceTags(resolvedSpaceId);
    
    if (!tagsResponse.success) {
      logger.error('Failed to get space tags', tagsResponse.error);
      throw new Error(tagsResponse.error?.message || 'Failed to get space tags');
    }
    
    logger.info(`Successfully retrieved ${tagsResponse.data?.length || 0} tags`);
    
    return tagsResponse.data || [];
  } catch (error) {
    logger.error('Error in getSpaceTags', error);
    throw error;
  }
}

/**
 * Create a new tag in a space
 * @param params - Space identifier and tag details
 * @returns Created tag
 */
export async function createSpaceTag(params: {
  spaceId?: string;
  spaceName?: string;
  tagName: string;
  tagBg?: string;
  tagFg?: string;
  colorCommand?: string;
}) {
  let { spaceId, spaceName, tagName, tagBg = '#000000', tagFg = '#ffffff', colorCommand } = params;
  
  // Process color command if provided
  if (colorCommand) {
    const colors = processColorCommand(colorCommand);
    if (colors) {
      tagBg = colors.background;
      tagFg = colors.foreground;
      logger.info(`Processed color command: "${colorCommand}" → BG: ${tagBg}, FG: ${tagFg}`);
    } else {
      logger.warn(`Could not process color command: "${colorCommand}". Using default colors.`);
    }
  }
  
  if (!tagName) {
    logger.error('createSpaceTag called without tagName');
    return {
      success: false,
      error: {
        message: 'tagName is required'
      }
    };
  }
  
  if (!spaceId && !spaceName) {
    logger.error('createSpaceTag called without space identifier');
    return {
      success: false,
      error: {
        message: 'Either spaceId or spaceName is required'
      }
    };
  }

  logger.info('Creating tag in space', { spaceId, spaceName, tagName, tagBg, tagFg });
  
  try {
    // If spaceName is provided, we need to resolve it to an ID
    let resolvedSpaceId = spaceId;
    if (!resolvedSpaceId && spaceName) {
      logger.debug(`Resolving space name: ${spaceName}`);
      
      const spaces = await clickUpServices.workspace.getSpaces();
      
      const space = spaces.find(s => 
        s.name.toLowerCase() === spaceName.toLowerCase()
      );
      
      if (!space) {
        logger.error(`Space not found: ${spaceName}`);
        return {
          success: false,
          error: {
            message: `Space not found: ${spaceName}`
          }
        };
      }
      
      resolvedSpaceId = space.id;
    }
    
    // Create tag in the space
    const tagResponse = await clickUpServices.tag.createSpaceTag(resolvedSpaceId, {
      tag_name: tagName,
      tag_bg: tagBg,
      tag_fg: tagFg
    });
    
    if (!tagResponse.success) {
      logger.error('Failed to create space tag', tagResponse.error);
      return {
        success: false,
        error: tagResponse.error || {
          message: 'Failed to create space tag'
        }
      };
    }
    
    logger.info(`Successfully created tag: ${tagName}`);
    
    return {
      success: true,
      data: tagResponse.data
    };
  } catch (error) {
    logger.error('Error in createSpaceTag', error);
    return {
      success: false,
      error: {
        message: error.message || 'Failed to create space tag',
        code: error.code,
        details: error.data
      }
    };
  }
}

/**
 * Update an existing tag in a space
 * @param params - Space identifier, tag name, and updated properties
 * @returns Updated tag
 */
export async function updateSpaceTag(params: {
  spaceId?: string;
  spaceName?: string;
  tagName: string;
  newTagName?: string;
  tagBg?: string;
  tagFg?: string;
  colorCommand?: string;
}) {
  const { spaceId, spaceName, tagName, newTagName, colorCommand } = params;
  let { tagBg, tagFg } = params;
  
  // Process color command if provided
  if (colorCommand) {
    const colors = processColorCommand(colorCommand);
    if (colors) {
      tagBg = colors.background;
      tagFg = colors.foreground;
      logger.info(`Processed color command: "${colorCommand}" → BG: ${tagBg}, FG: ${tagFg}`);
    } else {
      logger.warn(`Could not process color command: "${colorCommand}". Using default colors.`);
    }
  }
  
  if (!tagName) {
    logger.error('updateSpaceTag called without tagName');
    return {
      success: false,
      error: {
        message: 'tagName is required'
      }
    };
  }
  
  if (!spaceId && !spaceName) {
    logger.error('updateSpaceTag called without space identifier');
    return {
      success: false,
      error: {
        message: 'Either spaceId or spaceName is required'
      }
    };
  }
  
  // Make sure there's at least one property to update
  if (!newTagName && !tagBg && !tagFg && !colorCommand) {
    logger.error('updateSpaceTag called without properties to update');
    return {
      success: false,
      error: {
        message: 'At least one property (newTagName, tagBg, tagFg, or colorCommand) must be provided'
      }
    };
  }

  logger.info('Updating tag in space', { spaceId, spaceName, tagName, newTagName, tagBg, tagFg });
  
  try {
    // If spaceName is provided, we need to resolve it to an ID
    let resolvedSpaceId = spaceId;
    if (!resolvedSpaceId && spaceName) {
      logger.debug(`Resolving space name: ${spaceName}`);
      
      const spaces = await clickUpServices.workspace.getSpaces();
      
      const space = spaces.find(s => 
        s.name.toLowerCase() === spaceName.toLowerCase()
      );
      
      if (!space) {
        logger.error(`Space not found: ${spaceName}`);
        return {
          success: false,
          error: {
            message: `Space not found: ${spaceName}`
          }
        };
      }
      
      resolvedSpaceId = space.id;
    }
    
    // Prepare update data
    const updateData: {
      tag_name?: string;
      tag_bg?: string;
      tag_fg?: string;
    } = {};
    
    if (newTagName) updateData.tag_name = newTagName;
    if (tagBg) updateData.tag_bg = tagBg;
    if (tagFg) updateData.tag_fg = tagFg;
    
    // Update tag in the space
    const tagResponse = await clickUpServices.tag.updateSpaceTag(resolvedSpaceId, tagName, updateData);
    
    if (!tagResponse.success) {
      logger.error('Failed to update space tag', tagResponse.error);
      return {
        success: false,
        error: tagResponse.error || {
          message: 'Failed to update space tag'
        }
      };
    }
    
    logger.info(`Successfully updated tag: ${tagName}`);
    
    return {
      success: true,
      data: tagResponse.data
    };
  } catch (error) {
    logger.error('Error in updateSpaceTag', error);
    return {
      success: false,
      error: {
        message: error.message || 'Failed to update space tag',
        code: error.code,
        details: error.data
      }
    };
  }
}

/**
 * Delete a tag from a space
 * @param params - Space identifier and tag name
 * @returns Success status
 */
export async function deleteSpaceTag(params: {
  spaceId?: string;
  spaceName?: string;
  tagName: string;
}) {
  const { spaceId, spaceName, tagName } = params;
  
  if (!tagName) {
    logger.error('deleteSpaceTag called without tagName');
    return {
      success: false,
      error: {
        message: 'tagName is required'
      }
    };
  }
  
  if (!spaceId && !spaceName) {
    logger.error('deleteSpaceTag called without space identifier');
    return {
      success: false,
      error: {
        message: 'Either spaceId or spaceName is required'
      }
    };
  }

  logger.info('Deleting tag from space', { spaceId, spaceName, tagName });
  
  try {
    // If spaceName is provided, we need to resolve it to an ID
    let resolvedSpaceId = spaceId;
    if (!resolvedSpaceId && spaceName) {
      logger.debug(`Resolving space name: ${spaceName}`);
      
      const spaces = await clickUpServices.workspace.getSpaces();
      
      const space = spaces.find(s => 
        s.name.toLowerCase() === spaceName.toLowerCase()
      );
      
      if (!space) {
        logger.error(`Space not found: ${spaceName}`);
        return {
          success: false,
          error: {
            message: `Space not found: ${spaceName}`
          }
        };
      }
      
      resolvedSpaceId = space.id;
    }
    
    // Delete tag from the space
    const tagResponse = await clickUpServices.tag.deleteSpaceTag(resolvedSpaceId, tagName);
    
    if (!tagResponse.success) {
      logger.error('Failed to delete space tag', tagResponse.error);
      return {
        success: false,
        error: tagResponse.error || {
          message: 'Failed to delete space tag'
        }
      };
    }
    
    logger.info(`Successfully deleted tag: ${tagName}`);
    
    return {
      success: true
    };
  } catch (error) {
    logger.error('Error in deleteSpaceTag', error);
    return {
      success: false,
      error: {
        message: error.message || 'Failed to delete space tag',
        code: error.code,
        details: error.data
      }
    };
  }
}

/**
 * Simple task ID resolver
 */
async function resolveTaskId(params: {
  taskId?: string;
  customTaskId?: string;
  taskName?: string;
  listName?: string;
}): Promise<{ success: boolean; taskId?: string; error?: any }> {
  const { taskId, customTaskId, taskName, listName } = params;
  
  try {
    // First validate task identification with global lookup enabled
    const validationResult = validateTaskIdentification(
      { taskId, customTaskId, taskName, listName },
      { useGlobalLookup: true }
    );

    if (!validationResult.isValid) {
      return {
        success: false,
        error: { message: validationResult.errorMessage }
      };
    }

    const result = await taskService.findTasks({
      taskId,
      customTaskId,
      taskName,
      listName,
      allowMultipleMatches: false,
      useSmartDisambiguation: true,
      includeFullDetails: false
    });

    if (!result || Array.isArray(result)) {
      return {
        success: false,
        error: { message: 'Task not found with the provided identification' }
      };
    }

    return { success: true, taskId: result.id };
  } catch (error) {
    return {
      success: false,
      error: {
        message: error.message || 'Failed to resolve task ID',
        code: error.code,
        details: error.data
      }
    };
  }
}

/**
 * Add a tag to a task
 * @param params - Task identifier and tag name
 * @returns Success status
 */
export async function addTagToTask(params: {
  taskId?: string;
  customTaskId?: string;
  taskName?: string;
  listName?: string;
  tagName: string;
}) {
  const { taskId, customTaskId, taskName, listName, tagName } = params;
  
  if (!tagName) {
    logger.error('addTagToTask called without tagName');
    return {
      success: false,
      error: {
        message: 'tagName is required'
      }
    };
  }
  
  if (!taskId && !customTaskId && !taskName) {
    logger.error('addTagToTask called without task identifier');
    return {
      success: false,
      error: {
        message: 'Either taskId, customTaskId, or taskName is required'
      }
    };
  }

  logger.info('Adding tag to task', { taskId, customTaskId, taskName, listName, tagName });
  
  try {
    // Resolve the task ID
    const taskIdResult = await resolveTaskId({ taskId, customTaskId, taskName, listName });
    
    if (!taskIdResult.success) {
      return {
        success: false,
        error: taskIdResult.error
      };
    }
    
    // Add tag to the task
    const result = await clickUpServices.tag.addTagToTask(taskIdResult.taskId, tagName);
    
    if (!result.success) {
      logger.error('Failed to add tag to task', result.error);
      
      // Provide more specific error messages based on error code
      if (result.error?.code === 'TAG_NOT_FOUND') {
        return {
          success: false,
          error: {
            message: `The tag "${tagName}" does not exist in the space. Please create it first using create_space_tag.`
          }
        };
      } else if (result.error?.code === 'SPACE_NOT_FOUND') {
        return {
          success: false,
          error: {
            message: 'Could not determine which space the task belongs to.'
          }
        };
      } else if (result.error?.code === 'TAG_VERIFICATION_FAILED') {
        return {
          success: false,
          error: {
            message: 'The tag addition could not be verified. Please check if the tag was added manually.'
          }
        };
      }
      
      return {
        success: false,
        error: result.error || {
          message: 'Failed to add tag to task'
        }
      };
    }
    
    logger.info(`Successfully added tag "${tagName}" to task ${taskIdResult.taskId}`);
    
    return {
      success: true
    };
  } catch (error) {
    logger.error('Error in addTagToTask', error);
    return {
      success: false,
      error: {
        message: error.message || 'Failed to add tag to task',
        code: error.code,
        details: error.data
      }
    };
  }
}

/**
 * Remove a tag from a task
 * @param params - Task identifier and tag name
 * @returns Success status
 */
export async function removeTagFromTask(params: {
  taskId?: string;
  customTaskId?: string;
  taskName?: string;
  listName?: string;
  tagName: string;
}) {
  const { taskId, customTaskId, taskName, listName, tagName } = params;
  
  if (!tagName) {
    logger.error('removeTagFromTask called without tagName');
    return {
      success: false,
      error: {
        message: 'tagName is required'
      }
    };
  }
  
  if (!taskId && !customTaskId && !taskName) {
    logger.error('removeTagFromTask called without task identifier');
    return {
      success: false,
      error: {
        message: 'Either taskId, customTaskId, or taskName is required'
      }
    };
  }

  logger.info('Removing tag from task', { taskId, customTaskId, taskName, listName, tagName });
  
  try {
    // Resolve the task ID
    const taskIdResult = await resolveTaskId({ taskId, customTaskId, taskName, listName });
    
    if (!taskIdResult.success) {
      return {
        success: false,
        error: taskIdResult.error
      };
    }
    
    // Remove tag from the task
    const result = await clickUpServices.tag.removeTagFromTask(taskIdResult.taskId, tagName);
    
    if (!result.success) {
      logger.error('Failed to remove tag from task', result.error);
      return {
        success: false,
        error: result.error || {
          message: 'Failed to remove tag from task'
        }
      };
    }
    
    logger.info(`Successfully removed tag "${tagName}" from task ${taskIdResult.taskId}`);
    
    return {
      success: true
    };
  } catch (error) {
    logger.error('Error in removeTagFromTask', error);
    return {
      success: false,
      error: {
        message: error.message || 'Failed to remove tag from task',
        code: error.code,
        details: error.data
      }
    };
  }
}
</file>

<file path="src/config.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * Configuration handling for ClickUp API credentials and application settings
 *
 * The required environment variables (CLICKUP_API_KEY and CLICKUP_TEAM_ID) are passed 
 * securely to this file when running the hosted server at smithery.ai. Optionally, 
 * they can be parsed via command line arguments when running the server locally.
 * 
 * The document support is optional and can be passed via command line arguments.
 * The default value is 'false' (string), which means document support will be disabled if
 * no parameter is passed. Pass it as 'true' (string) to enable it.
 */

// Parse any command line environment arguments
const args = process.argv.slice(2);
const envArgs: { [key: string]: string } = {};
for (let i = 0; i < args.length; i++) {
  if (args[i] === '--env' && i + 1 < args.length) {
    const [key, value] = args[i + 1].split('=');
    if (key === 'CLICKUP_API_KEY') envArgs.clickupApiKey = value;
    if (key === 'CLICKUP_TEAM_ID') envArgs.clickupTeamId = value;
    if (key === 'DOCUMENT_SUPPORT') envArgs.documentSupport = value;
    if (key === 'DOCUMENT_MODEL') envArgs.documentSupport = value; // Backward compatibility
    if (key === 'DOCUMENT_MODULE') envArgs.documentSupport = value; // Backward compatibility
    if (key === 'LOG_LEVEL') envArgs.logLevel = value;
    if (key === 'DISABLED_TOOLS') envArgs.disabledTools = value;
    if (key === 'DISABLED_COMMANDS') envArgs.disabledTools = value; // Backward compatibility
    i++;
  }
}

// Log levels enum
export enum LogLevel {
  TRACE = 0,
  DEBUG = 1,
  INFO = 2,
  WARN = 3,
  ERROR = 4,
}

// Parse LOG_LEVEL string to LogLevel enum
export const parseLogLevel = (levelStr: string | undefined): LogLevel => {
  if (!levelStr) return LogLevel.ERROR; // Default to ERROR if not specified
  
  switch (levelStr.toUpperCase()) {
    case 'TRACE': return LogLevel.TRACE;
    case 'DEBUG': return LogLevel.DEBUG;
    case 'INFO': return LogLevel.INFO;
    case 'WARN': return LogLevel.WARN;
    case 'ERROR': return LogLevel.ERROR;
    default:
      // Don't use console.error as it interferes with JSON-RPC communication
      return LogLevel.ERROR;
  }
};

// Define required configuration interface
interface Config {
  clickupApiKey: string;
  clickupTeamId: string;
  enableSponsorMessage: boolean;
  documentSupport: string;
  logLevel: LogLevel;
  disabledTools: string[];
}

// Load configuration from command line args or environment variables
const configuration: Config = {
  clickupApiKey: envArgs.clickupApiKey || process.env.CLICKUP_API_KEY || '',
  clickupTeamId: envArgs.clickupTeamId || process.env.CLICKUP_TEAM_ID || '',
  enableSponsorMessage: process.env.ENABLE_SPONSOR_MESSAGE !== 'false',
  documentSupport: envArgs.documentSupport || process.env.DOCUMENT_SUPPORT || process.env.DOCUMENT_MODULE || process.env.DOCUMENT_MODEL || 'false',
  logLevel: parseLogLevel(envArgs.logLevel || process.env.LOG_LEVEL),
  disabledTools: (
    (envArgs.disabledTools || process.env.DISABLED_TOOLS || process.env.DISABLED_COMMANDS)?.split(',').map(cmd => cmd.trim()).filter(cmd => cmd !== '') || []
  ),
};

// Don't log to console as it interferes with JSON-RPC communication

// Validate only the required variables are present
const requiredVars = ['clickupApiKey', 'clickupTeamId'];
const missingEnvVars = requiredVars
  .filter(key => !configuration[key as keyof Config])
  .map(key => key);

if (missingEnvVars.length > 0) {
  throw new Error(
    `Missing required environment variables: ${missingEnvVars.join(', ')}`
  );
}

export default configuration;
</file>

<file path="src/tools/task/attachments.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Task Attachment Tool
 * 
 * This module implements a tool for attaching files to ClickUp tasks
 * with automatic method selection based on file source and size.
 */

import * as fs from 'fs';
import { promisify } from 'util';
import { createReadStream } from 'fs';
import { Stream } from 'stream';
import { IncomingMessage, request as httpRequest } from 'http';
import { request as httpsRequest } from 'https';
import { 
  ClickUpTask, 
  ClickUpTaskAttachment 
} from '../../services/clickup/types.js';
import { clickUpServices } from '../../services/shared.js';
import { 
  ChunkSession, 
  TaskAttachmentResponse, 
  ChunkedUploadInitResponse, 
  ChunkedUploadProgressResponse 
} from './attachments.types.js';
import { validateTaskIdentification } from './utilities.js';
import { sponsorService } from '../../utils/sponsor-service.js';
import { Logger } from '../../logger.js';

// Use shared services instance
const { task: taskService } = clickUpServices;

// Create a logger instance for attachments
const logger = new Logger('TaskAttachments');

// Session storage for chunked uploads (in-memory for demonstration)
const chunkSessions = new Map<string, ChunkSession>();

// Clean up expired sessions periodically
setInterval(() => {
  const now = Date.now();
  const expired = 24 * 60 * 60 * 1000; // 24 hours
  
  for (const [token, session] of chunkSessions.entries()) {
    if (now - session.timestamp > expired) {
      chunkSessions.delete(token);
      logger.debug(`Cleaned up expired upload session: ${token}`);
    }
  }
}, 3600 * 1000); // Check every hour

/**
 * Single unified tool for attaching files to ClickUp tasks
 */
export const attachTaskFileTool = {
  name: "attach_task_file",
  description: `Attaches file to task. Use taskId (preferred) or taskName + optional listName. File sources: 1) base64 + filename (≤10MB), 2) URL (http/https), 3) local path (absolute), 4) chunked for large files. WARNING: taskName without listName may match multiple tasks.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to attach the file to. Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of the task to attach the file to. The tool will search for tasks with this name across all lists unless listName is specified."
      },
      listName: {
        type: "string",
        description: "Optional: Name of list containing the task. Providing this narrows the search to a specific list, improving performance and reducing ambiguity."
      },
      file_name: {
        type: "string",
        description: "Name of the file to be attached (include the extension). Required when using file_data."
      },
      file_data: {
        type: "string",
        description: "Base64-encoded content of the file (without the data URL prefix)."
      },
      file_url: {
        type: "string",
        description: "DUAL PURPOSE PARAMETER: Either (1) a web URL starting with http/https to download a file from, OR (2) an absolute local file path starting with / or drive letter. DO NOT use relative paths."
      },
      auth_header: {
        type: "string",
        description: "Optional authorization header to use when downloading from a web URL (ignored for local files)."
      },
      // Advanced parameters for chunked uploads - usually not needed as chunking is automatic
      chunk_index: {
        type: "number",
        description: "Optional: For advanced usage with large file chunking. The 0-based index of this chunk."
      },
      chunk_session: {
        type: "string",
        description: "Optional: For advanced usage with large file chunking. Session identifier from a previous chunk upload."
      },
      chunk_total: {
        type: "number",
        description: "Optional: For advanced usage with large file chunking. Total number of chunks expected."
      },
      chunk_is_last: {
        type: "boolean",
        description: "Optional: For advanced usage with large file chunking. Whether this is the final chunk."
      }
    }
  }
};

/**
 * Handler function for the attachTaskFileTool
 */
async function attachTaskFileHandler(params: any): Promise<any> {
  // Extract common parameters
  const { taskId, taskName, listName, customTaskId, file_name, file_data, file_url, auth_header,
    chunk_total, chunk_size, chunk_index, session_id } = params;
  
  // Validate task identification
  const validationResult = validateTaskIdentification(
    { taskId, taskName, listName, customTaskId },
    { useGlobalLookup: true }
  );
  
  if (!validationResult.isValid) {
    throw new Error(validationResult.errorMessage);
  }
  
  // Validate file source - either file_data or file_url must be provided
  if (!file_data && !file_url && !session_id) {
    throw new Error("Either file_data, file_url, or session_id must be provided");
  }
  
  // Resolve task ID
  const result = await taskService.findTasks({
    taskId,
    taskName,
    listName,
    allowMultipleMatches: false,
    useSmartDisambiguation: true,
    includeFullDetails: false
  });

  if (!result || Array.isArray(result)) {
    throw new Error("Task not found");
  }

  const resolvedTaskId = result.id;
  
  try {
    // CASE 1: Chunked upload continuation
    if (session_id) {
      return await handleChunkUpload(resolvedTaskId, session_id, chunk_index, file_data, chunk_total === chunk_index + 1);
    }
    
    // CASE 2: URL-based upload or local file path
    if (file_url) {
      // Check if it's a local file path
      logger.debug(`Checking if path is local: ${file_url}`);
      if (file_url.startsWith('/') || /^[A-Za-z]:\\/.test(file_url)) {
        logger.debug(`Detected as local path, proceeding to handle: ${file_url}`);
        return await handleLocalFileUpload(resolvedTaskId, file_url, file_name);
      } else if (file_url.startsWith('http://') || file_url.startsWith('https://')) {
        logger.debug(`Detected as URL, proceeding with URL upload: ${file_url}`);
        return await handleUrlUpload(resolvedTaskId, file_url, file_name, auth_header);
      } else {
        throw new Error(`Invalid file_url format: "${file_url}". The file_url parameter must be either an absolute file path (starting with / or drive letter) or a web URL (starting with http:// or https://)`);
      }
    }
    
    // CASE 3: Base64 upload (with automatic chunking for large files)
    if (file_data) {
      if (!file_name) {
        throw new Error("file_name is required when using file_data");
      }
      
      // Check if we need to use chunking (file > 10MB)
      const fileBuffer = Buffer.from(file_data, 'base64');
      const fileSize = fileBuffer.length;
      
      if (fileSize > 10 * 1024 * 1024) {
        // For large files, start chunked upload process
        return await startChunkedUpload(resolvedTaskId, file_name, fileBuffer);
      } else {
        // For small files, upload directly
        return await handleDirectUpload(resolvedTaskId, file_name, fileBuffer);
      }
    }
    
    throw new Error("Invalid parameters: Unable to determine upload method");
  } catch (error) {
    logger.error(`Error attaching file to task:`, error);
    throw error;
  }
}

/**
 * Handle direct upload for small files
 */
async function handleDirectUpload(taskId: string, fileName: string, fileBuffer: Buffer): Promise<TaskAttachmentResponse> {
  try {
    // Call service method
    const result = await taskService.uploadTaskAttachment(taskId, fileBuffer, fileName);
    
    return {
      success: true,
      message: `File "${fileName}" successfully attached to task ${taskId}`,
      attachment: result
    };
  } catch (error) {
    throw new Error(`Failed to upload file: ${error.message}`);
  }
}

/**
 * Handle URL-based upload
 */
async function handleUrlUpload(taskId: string, fileUrl: string, fileName: string | undefined, authHeader: string | undefined): Promise<TaskAttachmentResponse> {
  try {
    // Extract filename from URL if not provided
    const extractedFileName = fileName || new URL(fileUrl).pathname.split('/').pop() || 'downloaded-file';
    
    // Call service method
    const result = await taskService.uploadTaskAttachmentFromUrl(taskId, fileUrl, extractedFileName, authHeader);
    
    return {
      success: true,
      message: `File from "${fileUrl}" successfully attached to task ${taskId}`,
      attachment: result
    };
  } catch (error) {
    if (error.message === 'Invalid URL') {
      throw new Error(`Failed to upload file from URL: Invalid URL format. The file_url parameter must be a valid web URL starting with http:// or https://`);
    }
    throw new Error(`Failed to upload file from URL: ${error.message}`);
  }
}

/**
 * Start a chunked upload process for large files
 */
async function startChunkedUpload(taskId: string, fileName: string, fileBuffer: Buffer): Promise<ChunkedUploadInitResponse> {
  // Generate a session token
  const sessionToken = `chunk_session_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  
  // Store the file in chunks (for demonstration - in production would store chunk info only)
  // Split the file into chunks for storage
  const chunkSize = 5 * 1024 * 1024; // 5MB chunks
  const chunksMap = new Map<number, Buffer>();
  
  for (let i = 0; i < fileBuffer.length; i += chunkSize) {
    const chunk = fileBuffer.slice(i, i + chunkSize);
    chunksMap.set(Math.floor(i / chunkSize), chunk);
  }
  
  // Create a new session
  chunkSessions.set(sessionToken, {
    taskId,
    fileName,
    fileSize: fileBuffer.length,
    chunks: chunksMap,
    timestamp: Date.now()
  });
  
  // Return initial chunk
  return {
    success: true,
    message: `Large file detected. Chunked upload initialized for "${fileName}" (${fileBuffer.length} bytes)`,
    chunk_session: sessionToken,
    chunks_total: chunksMap.size,
    chunk_uploaded: 1,
    attachment: null,
    details: {
      taskId,
      fileName,
      fileSize: fileBuffer.length,
      chunkCount: chunksMap.size,
      progress: Math.round((1 / chunksMap.size) * 100)
    }
  };
}

/**
 * Handle chunk upload as part of a multi-chunk process
 */
async function handleChunkUpload(
  taskId: string,
  sessionToken: string,
  chunkIndex: number | undefined,
  chunkData: string | undefined,
  isLastChunk: boolean | undefined
): Promise<TaskAttachmentResponse | ChunkedUploadProgressResponse> {
  // Verify session exists
  const session = chunkSessions.get(sessionToken);
  if (!session) {
    throw new Error("Upload session not found or expired");
  }
  
  // If this is the last chunk or all chunks are uploaded, finalize the upload
  if (isLastChunk || (session.chunks.size === 1 && chunkIndex === undefined)) {
    // Combine all chunks
    const fileData = Buffer.allocUnsafe(session.fileSize);
    let offset = 0;
    
    // Sort chunks by index
    const sortedChunks = Array.from(session.chunks.entries())
      .sort((a, b) => a[0] - b[0]);
    
    for (const entry of sortedChunks) {
      const [index, chunk] = entry;
      chunk.copy(fileData, offset);
      offset += chunk.length;
    }
    
    try {
      // Call service method
      const result = await taskService.uploadTaskAttachment(session.taskId, fileData, session.fileName);
      
      // Clean up the session
      chunkSessions.delete(sessionToken);
      
      return {
        success: true,
        message: `File "${session.fileName}" successfully attached to task ${session.taskId}`,
        attachment: result
      };
    } catch (error) {
      throw new Error(`Failed to upload file: ${error.message}`);
    }
  }
  
  // Otherwise handle the current chunk
  if (chunkIndex === undefined || chunkData === undefined) {
    throw new Error("chunk_index and chunk_data are required for chunk uploads");
  }
  
  // Store the chunk
  // (In a real implementation, we'd append to a temp file or storage)
  session.chunks.delete(chunkIndex); // Remove the chunk if it exists
  session.chunks.set(chunkIndex, Buffer.from(chunkData, 'base64'));
  
  return {
    success: true,
    message: `Chunk ${chunkIndex + 1}/${session.chunks.size} received`,
    chunk_session: sessionToken,
    chunks_remaining: session.chunks.size - chunkIndex - 1,
    details: {
      taskId: session.taskId,
      fileName: session.fileName,
      chunksReceived: chunkIndex + 1,
      progress: Math.round(((chunkIndex + 1) / session.chunks.size) * 100)
    }
  };
}

/**
 * Handle local file path upload
 */
async function handleLocalFileUpload(taskId: string, filePath: string, fileName: string | undefined): Promise<TaskAttachmentResponse> {
  try {
    // Import fs and path modules
    const fs = await import('fs');
    const path = await import('path');
    
    logger.debug(`Processing absolute file path: ${filePath}`);
    
    // Normalize the path to prevent directory traversal attacks
    const normalizedPath = path.normalize(filePath);
    
    // Check if file exists
    if (!fs.existsSync(normalizedPath)) {
      throw new Error(`Local file not found: ${normalizedPath}`);
    }
    
    // Validate file stats
    const stats = fs.statSync(normalizedPath);
    if (!stats.isFile()) {
      throw new Error(`Path is not a file: ${normalizedPath}`);
    }
    
    // Get file name if not provided
    const extractedFileName = fileName || path.basename(normalizedPath);
    
    // Read file
    const fileBuffer = fs.readFileSync(normalizedPath);
    const fileSize = fileBuffer.length;
    
    logger.debug(`Successfully read file: ${extractedFileName} (${fileSize} bytes)`);
    
    // Choose upload method based on file size
    if (fileSize > 10 * 1024 * 1024) {
      // For large files, start chunked upload process
      return await startChunkedUpload(taskId, extractedFileName, fileBuffer);
    } else {
      // For small files, upload directly
      return await handleDirectUpload(taskId, extractedFileName, fileBuffer);
    }
  } catch (error) {
    if (error.message.includes('ENOENT')) {
      throw new Error(`Failed to upload local file: Local file not found: ${filePath}. Make sure the file exists and the path is absolute.`);
    } else if (error.message.includes('EACCES')) {
      throw new Error(`Failed to upload local file: Permission denied accessing: ${filePath}. Check file permissions.`);
    }
    throw new Error(`Failed to upload local file: ${error.message}`);
  }
}

/**
 * Creates a wrapped handler function with standard error handling and response formatting
 */
function createHandlerWrapper<T>(
  handler: (params: any) => Promise<T>,
  formatResponse: (result: T) => any = (result) => result
) {
  return async (parameters: any) => {
    try {
      const result = await handler(parameters);
      return sponsorService.createResponse(formatResponse(result), true);
    } catch (error) {
      return sponsorService.createErrorResponse(error, parameters);
    }
  };
}

export const handleAttachTaskFile = createHandlerWrapper(attachTaskFileHandler);
</file>

<file path="src/tools/task/utilities.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Task Utilities
 * 
 * This module provides utility functions for task-related operations including
 * data formatting, validation, and resolution of IDs from names.
 */

import { 
  ClickUpTask
} from '../../services/clickup/types.js';
import { BatchProcessingOptions } from '../../utils/concurrency-utils.js';
import { formatDueDate } from '../utils.js';
import { clickUpServices } from '../../services/shared.js';
import { findListIDByName } from '../../tools/list.js';
import { WorkspaceService } from '../../services/clickup/workspace.js';
import { TaskPriority } from '../../services/clickup/types.js';

// Use shared services instance for ID resolution
const { workspace: workspaceService, task: taskService } = clickUpServices;

//=============================================================================
// DATA FORMATTING UTILITIES
//=============================================================================

/**
 * Formats task data for response
 */
export function formatTaskData(task: ClickUpTask, additional: any = {}) {
  return {
    id: task.id,
    custom_id: task.custom_id,
    name: task.name,
    text_content: task.text_content,
    description: task.description,
    url: task.url,
    status: task.status?.status || "Unknown",
    status_color: task.status?.color,
    orderindex: task.orderindex,
    date_created: task.date_created,
    date_updated: task.date_updated,
    date_closed: task.date_closed,
    creator: task.creator,
    assignees: task.assignees,
    watchers: task.watchers,
    checklists: task.checklists,
    tags: task.tags,
    parent: task.parent,
    priority: task.priority,
    due_date: task.due_date ? formatDueDate(Number(task.due_date)) : undefined,
    start_date: task.start_date ? formatDueDate(Number(task.start_date)) : undefined,
    time_estimate: task.time_estimate,
    time_spent: task.time_spent,
    custom_fields: task.custom_fields,
    dependencies: task.dependencies,
    linked_tasks: task.linked_tasks,
    team_id: task.team_id,
    list: {
      id: task.list.id,
      name: task.list.name,
      access: task.list.access
    },
    folder: task.folder ? {
      id: task.folder.id,
      name: task.folder.name,
      hidden: task.folder.hidden,
      access: task.folder.access
    } : null,
    space: {
      id: task.space.id,
      name: task.space.name
    },
    ...additional
  };
}

//=============================================================================
// VALIDATION UTILITIES
//=============================================================================

/**
 * Task identification parameters
 */
export interface TaskIdentificationParams {
  taskId?: string;
  taskName?: string;
  listName?: string;
  customTaskId?: string;
}

/**
 * Task validation result
 */
export interface TaskValidationResult {
  isValid: boolean;
  errorMessage?: string;
}

/**
 * Options for task identification validation
 */
export interface TaskIdentificationValidationOptions {
  requireTaskId?: boolean;
  useGlobalLookup?: boolean;
}

/**
 * Validates task identification parameters
 * 
 * @param params - Task identification parameters
 * @param options - Validation options
 * @returns Validation result with error message if any
 */
export function validateTaskIdentification(
  params: TaskIdentificationParams,
  options: TaskIdentificationValidationOptions = {}
): TaskValidationResult {
  const { 
    taskId, 
    taskName, 
    customTaskId,
    listName
  } = params;
  
  const { 
    requireTaskId = false,
    useGlobalLookup = true
  } = options;

  // If taskId is required, it must be provided
  if (requireTaskId && !taskId) {
    return {
      isValid: false,
      errorMessage: 'Task ID is required for this operation'
    };
  }

  // At least one identification method must be provided
  if (!taskId && !taskName && !customTaskId) {
    return {
      isValid: false,
      errorMessage: 'Either taskId, taskName, or customTaskId must be provided to identify the task'
    };
  }

  // When using taskName without global lookup, listName is required
  if (taskName && !taskId && !customTaskId && !useGlobalLookup && !listName) {
    return {
      isValid: false,
      errorMessage: 'When identifying a task by name, you must also provide the listName parameter'
    };
  }

  return { isValid: true };
}

/**
 * Validates list identification parameters
 * Ensures either listId or listName is provided
 */
export function validateListIdentification(listId?: string, listName?: string): void {
  if (!listId && !listName) {
    throw new Error("Either listId or listName must be provided");
  }
}

/**
 * Validates task update data
 * Ensures at least one update field is provided
 */
export function validateTaskUpdateData(updateData: any): void {
  // Validate custom_fields if provided
  if (updateData.custom_fields) {
    if (!Array.isArray(updateData.custom_fields)) {
      throw new Error("custom_fields must be an array");
    }
    
    for (const field of updateData.custom_fields) {
      if (!field.id || field.value === undefined) {
        throw new Error("Each custom field must have both id and value properties");
      }
    }
  }
  
  // Ensure there's at least one field to update
  if (Object.keys(updateData).length === 0) {
    throw new Error("At least one field to update must be provided");
  }
}

/**
 * Validate bulk task array and task identification
 * @param tasks Array of tasks to validate
 * @param operation The bulk operation type ('create', 'update', 'move', 'delete')
 */
export function validateBulkTasks(tasks: any[], operation: 'create' | 'update' | 'move' | 'delete' = 'update') {
  if (!Array.isArray(tasks) || tasks.length === 0) {
    throw new Error("tasks must be a non-empty array");
  }

  tasks.forEach((task, index) => {
    if (!task || typeof task !== 'object') {
      throw new Error(`Task at index ${index} must be an object`);
    }

    // Skip task identification validation for create operations
    if (operation === 'create') {
      return;
    }

    // For bulk operations, require listName when using taskName
    if (task.taskName && !task.listName) {
      throw new Error(`Task at index ${index} using taskName must also provide listName`);
    }

    // At least one identifier is required for non-create operations
    if (!task.taskId && !task.taskName && !task.customTaskId) {
      throw new Error(`Task at index ${index} must provide either taskId, taskName + listName, or customTaskId`);
    }
  });
}

/**
 * Parse options for bulk operations
 */
export function parseBulkOptions(rawOptions: any): BatchProcessingOptions | undefined {
  if (typeof rawOptions === 'string') {
    try {
      return JSON.parse(rawOptions);
    } catch (error) {
      return undefined;
    }
  }
  return rawOptions;
}

//=============================================================================
// ID DETECTION UTILITIES
//=============================================================================

/**
 * Determines if an ID is a custom ID based on its format
 * Custom IDs typically have an uppercase prefix followed by a hyphen and number (e.g., DEV-1234)
 * Regular task IDs are always 9 characters long
 * 
 * @param id The task ID to check
 * @returns True if the ID appears to be a custom ID
 */
export function isCustomTaskId(id: string): boolean {
  if (!id) return false;
  
  // Regular task IDs are exactly 9 characters
  if (id.length === 9) {
    return false;
  }
  
  // Custom IDs have an uppercase prefix followed by a hyphen and numbers
  const customIdPattern = /^[A-Z]+-\d+$/;
  return customIdPattern.test(id);
}

/**
 * Resolves a list ID from either direct ID or name
 * Handles validation and throws appropriate errors
 */
export async function resolveListIdWithValidation(listId?: string, listName?: string): Promise<string> {
  // Validate parameters
  validateListIdentification(listId, listName);
  
  // If listId is provided, use it directly
  if (listId) return listId;
  
  // At this point we know we have listName (validation ensures this)
  const listInfo = await findListIDByName(workspaceService, listName!);
  
  if (!listInfo) {
    throw new Error(`List "${listName}" not found`);
  }
  
  return listInfo.id;
}

//=============================================================================
// PATH EXTRACTION HELPER FUNCTIONS
//=============================================================================

/**
 * Extract path from node to root
 */
export function extractPath(node: any): string {
  if (!node) return '';
  if (!node.parent) return node.name;
  return `${extractPath(node.parent)} > ${node.name}`;
}

/**
 * Extract path from root to a specific node
 */
export function extractTreePath(root: any, targetId: string): any[] {
  if (!root) return [];
  
  // If this node is the target, return it in an array
  if (root.id === targetId) {
    return [root];
  }
  
  // Check children if they exist
  if (root.children) {
    for (const child of root.children) {
      const path = extractTreePath(child, targetId);
      if (path.length > 0) {
        return [root, ...path];
      }
    }
  }
  
  // Not found in this branch
  return [];
}

/**
 * Get task ID from various identification methods
 */
export async function getTaskId(
  taskId?: string,
  taskName?: string,
  listName?: string,
  customTaskId?: string,
  requireId = false
): Promise<string> {
  // Validate task identification
  const validationResult = validateTaskIdentification(
    { taskId, taskName, listName, customTaskId },
    { requireTaskId: requireId, useGlobalLookup: true }
  );
  
  if (!validationResult.isValid) {
    throw new Error(validationResult.errorMessage);
  }

  try {
    const result = await taskService.findTasks({
      taskId,
      customTaskId,
      taskName,
      listName,
      allowMultipleMatches: false,
      useSmartDisambiguation: true,
      includeFullDetails: false
    });

    if (!result || Array.isArray(result)) {
      throw new Error(`Task not found with the provided identification`);
    }

    return result.id;
  } catch (error) {
    if (error.message.includes('Multiple tasks found')) {
      throw new Error(`Multiple tasks found with name "${taskName}". Please provide list name to disambiguate.`);
    }
    throw error;
  }
}
</file>

<file path="src/tools/task/bulk-operations.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Bulk Task Operations
 * 
 * This module defines tools for bulk task operations including creating,
 * updating, moving, and deleting multiple tasks at once.
 */

import { TaskPriority } from '../../services/clickup/types.js';
import { clickUpServices } from '../../services/shared.js';
import { BulkService } from '../../services/clickup/bulk.js';
import { parseDueDate } from '../utils.js';
import { 
  validateBulkTasks, 
  parseBulkOptions,
  validateTaskIdentification,
  validateListIdentification,
  validateTaskUpdateData,
  resolveListIdWithValidation
} from './utilities.js';
import { getTaskId } from './handlers.js';
import { BatchProcessingOptions } from '../../utils/concurrency-utils.js';

// Initialize services
const { task: taskService } = clickUpServices;
const bulkService = new BulkService(taskService);

//=============================================================================
// COMMON SCHEMA DEFINITIONS
//=============================================================================

// Common schema definitions
const bulkOptionsSchema = {
  oneOf: [
    {
      type: "object",
      description: "Optional processing settings",
      properties: {
        batchSize: {
          type: "number", 
          description: "Tasks per batch (default: 10)"
        },
        concurrency: {
          type: "number",
          description: "Parallel operations (default: 3)"
        },
        continueOnError: {
          type: "boolean",
          description: "Continue if some tasks fail"
        },
        retryCount: {
          type: "number",
          description: "Retry attempts for failures"
        }
      }
    },
    {
      type: "string",
      description: "JSON string representing options. Will be parsed automatically."
    }
  ],
  description: "Processing options (or JSON string representing options)"
};

const taskIdentifierSchema = {
  taskId: {
    type: "string",
    description: "Task ID (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
  },
  taskName: {
    type: "string", 
    description: "Task name. Requires listName when used."
  },
  listName: {
    type: "string",
    description: "REQUIRED with taskName: List containing the task."
  },
  customTaskId: {
    type: "string",
    description: "Custom task ID (e.g., 'DEV-1234'). Only use if you want to explicitly force custom ID lookup. In most cases, use taskId which auto-detects ID format."
  }
};

//=============================================================================
// BULK TASK OPERATION TOOLS
//=============================================================================

/**
 * Tool definition for creating multiple tasks at once
 */
export const createBulkTasksTool = {
  name: "create_bulk_tasks",
  description: `Creates multiple tasks in one list. Use listId (preferred) or listName + array of tasks (each needs name). Configure batch size/concurrency via options. Tasks can have custom fields as {id, value} array.`,
  inputSchema: {
    type: "object",
    properties: {
      tasks: {
        type: "array",
        description: "Array of tasks to create. Each task must have at least a name.",
        items: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Task name with emoji prefix"
            },
            description: {
              type: "string",
              description: "Plain text description"
            },
            markdown_description: {
              type: "string",
              description: "Markdown description (overrides plain text)"
            },
            status: {
              type: "string",
              description: "Task status (uses list default if omitted)"
            },
            priority: {
              type: "number",
              description: "Priority 1-4 (1=urgent, 4=low)"
            },
            dueDate: {
              type: "string",
              description: "Due date. Supports Unix timestamps (in milliseconds) and natural language expressions like '1 hour from now', 'tomorrow', 'next week', etc."
            },
            tags: {
              type: "array",
              items: {
                type: "string"
              },
              description: "Optional array of tag names to assign to the task. The tags must already exist in the space."
            },
            custom_fields: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "ID of the custom field"
                  },
                  value: {
                    description: "Value for the custom field. Type depends on the field type."
                  }
                },
                required: ["id", "value"]
              },
              description: "Optional array of custom field values to set on the task."
            }
          },
          required: ["name"]
        }
      },
      listId: {
        type: "string",
        description: "ID of list for new tasks (preferred). Use this instead of listName if you have it."
      },
      listName: {
        type: "string",
        description: "Name of list for new tasks. Only use if you don't have listId."
      },
      options: bulkOptionsSchema
    },
    required: ["tasks"]
  }
};

/**
 * Tool definition for updating multiple tasks
 */
export const updateBulkTasksTool = {
  name: "update_bulk_tasks",
  description: `Updates multiple tasks efficiently. For each task: use taskId (preferred) or taskName + listName. At least one update field per task. Configure batch size/concurrency via options. WARNING: taskName without listName will fail.`,
  inputSchema: {
    type: "object",
    properties: {
      tasks: {
        type: "array",
        description: "Array of tasks to update",
        items: {
          type: "object",
          properties: {
            taskId: {
              type: "string",
              description: "Task ID (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
            },
            taskName: {
              type: "string",
              description: "Task name. Requires listName when used."
            },
            listName: {
              type: "string",
              description: "REQUIRED with taskName: List containing the task."
            },
            customTaskId: {
              type: "string",
              description: "Custom task ID (e.g., 'DEV-1234'). Only use if you want to explicitly force custom ID lookup. In most cases, use taskId which auto-detects ID format."
            },
            name: {
              type: "string",
              description: "New name with emoji prefix"
            },
            description: {
              type: "string",
              description: "New plain text description"
            },
            markdown_description: {
              type: "string",
              description: "New markdown description"
            },
            status: {
              type: "string",
              description: "New status"
            },
            priority: {
              type: "number",
              nullable: true,
              enum: [1, 2, 3, 4, null],
              description: "New priority (1-4 or null)"
            },
            dueDate: {
              type: "string",
              description: "New due date. Supports Unix timestamps (in milliseconds) and natural language expressions like '1 hour from now', 'tomorrow', etc."
            },
            custom_fields: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: {
                    type: "string",
                    description: "ID of the custom field"
                  },
                  value: {
                    description: "Value for the custom field. Type depends on the field type."
                  }
                },
                required: ["id", "value"]
              },
              description: "Optional array of custom field values to set on the task."
            }
          }
        }
      },
      options: bulkOptionsSchema
    },
    required: ["tasks"]
  }
};

/**
 * Tool definition for moving multiple tasks
 */
export const moveBulkTasksTool = {
  name: "move_bulk_tasks",
  description: `Moves multiple tasks to one list. For each task: use taskId (preferred) or taskName + listName. Target list: use targetListId/Name. Configure batch size/concurrency via options. WARNING: Task statuses may reset, taskName needs listName.`,
  inputSchema: {
    type: "object",
    properties: {
      tasks: {
        type: "array",
        description: "Array of tasks to move",
        items: {
          type: "object",
          properties: {
            taskId: {
              type: "string",
              description: "Task ID (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
            },
            taskName: {
              type: "string",
              description: "Task name. Requires listName when used."
            },
            listName: {
              type: "string",
              description: "REQUIRED with taskName: List containing the task."
            },
            customTaskId: {
              type: "string",
              description: "Custom task ID (e.g., 'DEV-1234'). Only use if you want to explicitly force custom ID lookup. In most cases, use taskId which auto-detects ID format."
            }
          }
        }
      },
      targetListId: {
        type: "string",
        description: "ID of destination list (preferred). Use instead of targetListName if available."
      },
      targetListName: {
        type: "string",
        description: "Name of destination list. Only use if you don't have targetListId."
      },
      options: bulkOptionsSchema
    },
    required: ["tasks"]
  }
};

/**
 * Tool definition for deleting multiple tasks
 */
export const deleteBulkTasksTool = {
  name: "delete_bulk_tasks",
  description: `PERMANENTLY deletes multiple tasks. For each task: use taskId (preferred/safest) or taskName + listName. Configure batch size/concurrency via options. WARNING: Cannot be undone, taskName without listName is dangerous.`,
  inputSchema: {
    type: "object",
    properties: {
      tasks: {
        type: "array",
        description: "Array of tasks to delete",
        items: {
          type: "object",
          properties: {
            taskId: {
              type: "string",
              description: "Task ID (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
            },
            taskName: {
              type: "string",
              description: "Task name. Requires listName when used."
            },
            listName: {
              type: "string",
              description: "REQUIRED with taskName: List containing the task."
            },
            customTaskId: {
              type: "string",
              description: "Custom task ID (e.g., 'DEV-1234'). Only use if you want to explicitly force custom ID lookup. In most cases, use taskId which auto-detects ID format."
            }
          }
        }
      },
      options: bulkOptionsSchema
    },
    required: ["tasks"]
  }
};
</file>

<file path="src/services/clickup/task/task-core.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp Task Service - Core Module
 * 
 * Handles core operations related to tasks in ClickUp, including:
 * - Base service initialization
 * - Core utility methods
 * - Basic CRUD operations
 */

import { BaseClickUpService, ErrorCode, ClickUpServiceError, ServiceResponse } from '../base.js';
import { 
  ClickUpTask, 
  CreateTaskData, 
  UpdateTaskData, 
  TaskFilters, 
  TasksResponse,
  TaskPriority
} from '../types.js';
import { ListService } from '../list.js';
import { WorkspaceService } from '../workspace.js';

/**
 * Core TaskService class providing basic task operations
 */
export class TaskServiceCore extends BaseClickUpService {
  protected listService: ListService;
  protected workspaceService: WorkspaceService | null = null;
  
  // Cache for validated tasks and lists
  private validationCache = {
    tasks: new Map<string, {
      validatedAt: number;
      task: ClickUpTask;
    }>(),
    lists: new Map<string, {
      validatedAt: number;
      valid: boolean;
    }>()
  };

  // Cache for task name to ID mapping
  private nameToIdCache = new Map<string, {
    taskId: string;
    validatedAt: number;
    listId?: string; // Optional list context for disambiguation
  }>();
  
  // Cache TTL in milliseconds (5 minutes)
  private readonly CACHE_TTL = 5 * 60 * 1000;

  constructor(
    apiKey: string, 
    teamId: string, 
    baseUrl?: string,
    workspaceService?: WorkspaceService
  ) {
    super(apiKey, teamId, baseUrl);
    
    if (workspaceService) {
      this.workspaceService = workspaceService;
      this.logOperation('constructor', { usingSharedWorkspaceService: true });
    }
    
    // Initialize list service for list lookups
    this.listService = new ListService(apiKey, teamId, baseUrl, this.workspaceService);
    
    this.logOperation('constructor', { initialized: true });
  }

  /**
   * Helper method to handle errors consistently
   * @param error The error that occurred
   * @param message Optional custom error message
   * @returns A ClickUpServiceError
   */
  protected handleError(error: any, message?: string): ClickUpServiceError {
    if (error instanceof ClickUpServiceError) {
      return error;
    }
    
    return new ClickUpServiceError(
      message || `Task service error: ${error.message}`,
      ErrorCode.UNKNOWN,
      error
    );
  }

  /**
   * Build URL parameters from task filters
   * @param filters Task filters to convert to URL parameters
   * @returns URLSearchParams object
   */
  protected buildTaskFilterParams(filters: TaskFilters): URLSearchParams {
    const params = new URLSearchParams();
    
    // Add all filters to the query parameters
    if (filters.include_closed) params.append('include_closed', String(filters.include_closed));
    if (filters.subtasks) params.append('subtasks', String(filters.subtasks));
    if (filters.page) params.append('page', String(filters.page));
    if (filters.order_by) params.append('order_by', filters.order_by);
    if (filters.reverse) params.append('reverse', String(filters.reverse));
    
    // Array parameters
    if (filters.statuses && filters.statuses.length > 0) {
      filters.statuses.forEach(status => params.append('statuses[]', status));
    }
    if (filters.assignees && filters.assignees.length > 0) {
      filters.assignees.forEach(assignee => params.append('assignees[]', assignee));
    }
    
    // Team tasks endpoint specific parameters
    if (filters.tags && filters.tags.length > 0) {
      filters.tags.forEach(tag => params.append('tags[]', tag));
    }
    if (filters.list_ids && filters.list_ids.length > 0) {
      filters.list_ids.forEach(id => params.append('list_ids[]', id));
    }
    if (filters.folder_ids && filters.folder_ids.length > 0) {
      filters.folder_ids.forEach(id => params.append('folder_ids[]', id));
    }
    if (filters.space_ids && filters.space_ids.length > 0) {
      filters.space_ids.forEach(id => params.append('space_ids[]', id));
    }
    if (filters.archived !== undefined) params.append('archived', String(filters.archived));
    if (filters.include_closed_lists !== undefined) params.append('include_closed_lists', String(filters.include_closed_lists));
    if (filters.include_archived_lists !== undefined) params.append('include_archived_lists', String(filters.include_archived_lists));
    if (filters.include_compact_time_entries !== undefined) params.append('include_compact_time_entries', String(filters.include_compact_time_entries));
    
    // Date filters
    if (filters.due_date_gt) params.append('due_date_gt', String(filters.due_date_gt));
    if (filters.due_date_lt) params.append('due_date_lt', String(filters.due_date_lt));
    if (filters.date_created_gt) params.append('date_created_gt', String(filters.date_created_gt));
    if (filters.date_created_lt) params.append('date_created_lt', String(filters.date_created_lt));
    if (filters.date_updated_gt) params.append('date_updated_gt', String(filters.date_updated_gt));
    if (filters.date_updated_lt) params.append('date_updated_lt', String(filters.date_updated_lt));
    
    // Handle custom fields if present
    if (filters.custom_fields) {
      Object.entries(filters.custom_fields).forEach(([key, value]) => {
        params.append(`custom_fields[${key}]`, String(value));
      });
    }
    
    return params;
  }
  
  /**
   * Extract priority value from a task
   * @param task The task to extract priority from
   * @returns TaskPriority or null
   */
  protected extractPriorityValue(task: ClickUpTask): TaskPriority | null {
    if (!task.priority || !task.priority.id) {
      return null;
    }
    
    const priorityValue = parseInt(task.priority.id);
    // Ensure it's in the valid range 1-4
    if (isNaN(priorityValue) || priorityValue < 1 || priorityValue > 4) {
      return null;
    }
    
    return priorityValue as TaskPriority;
  }
  
  /**
   * Extract task data for creation/duplication
   * @param task The source task
   * @param nameOverride Optional override for the task name
   * @returns CreateTaskData object
   */
  protected extractTaskData(task: ClickUpTask, nameOverride?: string): CreateTaskData {
    return {
      name: nameOverride || task.name,
      description: task.description || '',
      status: task.status?.status,
      priority: this.extractPriorityValue(task),
      due_date: task.due_date ? Number(task.due_date) : undefined,
      assignees: task.assignees?.map(a => a.id) || []
    };
  }

  /**
   * Create a new task in the specified list
   * @param listId The ID of the list to create the task in
   * @param taskData The data for the new task
   * @returns The created task
   */
  async createTask(listId: string, taskData: CreateTaskData): Promise<ClickUpTask> {
    this.logOperation('createTask', { listId, ...taskData });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.post<ClickUpTask | string>(
          `/list/${listId}/task`,
          taskData
        );
        
        // Handle both JSON and text responses
        const data = response.data;
        if (typeof data === 'string') {
          // If we got a text response, try to extract task ID from common patterns
          const idMatch = data.match(/task.*?(\w{9})/i);
          if (idMatch) {
            // If we found an ID, fetch the full task details
            return await this.getTask(idMatch[1]);
          }
          throw new ClickUpServiceError(
            'Received unexpected text response from API',
            ErrorCode.UNKNOWN,
            data
          );
        }
        
        return data;
      });
    } catch (error) {
      throw this.handleError(error, 'Failed to create task');
    }
  }

  /**
   * Get a task by its ID
   * @param taskId The ID of the task to retrieve
   * @returns The task
   */
  async getTask(taskId: string): Promise<ClickUpTask> {
    this.logOperation('getTask', { taskId });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.get<ClickUpTask>(`/task/${taskId}`);
        
        // Handle both JSON and text responses
        const data = response.data;
        if (typeof data === 'string') {
          throw new ClickUpServiceError(
            'Received unexpected text response from API',
            ErrorCode.UNKNOWN,
            data
          );
        }
        
        return data;
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get task ${taskId}`);
    }
  }

  /**
   * Get all tasks in a list
   * @param listId The ID of the list to get tasks from
   * @param filters Optional filters to apply
   * @returns Array of tasks
   */
  async getTasks(listId: string, filters: TaskFilters = {}): Promise<ClickUpTask[]> {
    this.logOperation('getTasks', { listId, filters });
    
    try {
      return await this.makeRequest(async () => {
        const params = this.buildTaskFilterParams(filters);
        const response = await this.client.get<TasksResponse>(
          `/list/${listId}/task`,
          { params }
        );
        
        // Handle both JSON and text responses
        const data = response.data;
        if (typeof data === 'string') {
          throw new ClickUpServiceError(
            'Received unexpected text response from API',
            ErrorCode.UNKNOWN,
            data
          );
        }
        
        return Array.isArray(data) ? data : data.tasks || [];
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get tasks for list ${listId}`);
    }
  }

  /**
   * Get subtasks of a specific task
   * @param taskId The ID of the parent task
   * @returns Array of subtask details
   */
  async getSubtasks(taskId: string): Promise<ClickUpTask[]> {
    this.logOperation('getSubtasks', { taskId });
    
    try {
      return await this.makeRequest(async () => {
        const response = await this.client.get<ClickUpTask>(
          `/task/${taskId}`
        );
        
        // Return subtasks if present, otherwise empty array
        return response.data.subtasks || [];
      });
    } catch (error) {
      throw this.handleError(error, `Failed to get subtasks for task ${taskId}`);
    }
  }

  /**
   * Get a task by its custom ID
   * @param customTaskId The custom ID of the task (e.g., "ABC-123")
   * @param listId Optional list ID to limit the search (Note: ClickUp API might not filter by list_id when using custom_task_id)
   * @returns The task details
   */
  async getTaskByCustomId(customTaskId: string, listId?: string): Promise<ClickUpTask> {
    // Log the operation, including listId even if the API might ignore it for this specific lookup type
    this.logOperation('getTaskByCustomId', { customTaskId, listId });

    try {
      return await this.makeRequest(async () => {
        // Use the standard task endpoint with the custom task ID
        const url = `/task/${encodeURIComponent(customTaskId)}`;

        // Add required query parameters for custom ID lookup
        const params = new URLSearchParams({
          custom_task_ids: 'true',
          team_id: this.teamId // team_id is required when custom_task_ids is true
        });

        // Note: The ClickUp API documentation for GET /task/{task_id} doesn't explicitly mention
        // filtering by list_id when custom_task_ids=true. This parameter might be ignored.
        if (listId) {
          this.logger.warn('listId provided to getTaskByCustomId, but the ClickUp API endpoint might not support it directly for custom ID lookups.', { customTaskId, listId });
          // If ClickUp API were to support it, you would add it like this:
          // params.append('list_id', listId);
        }

        const response = await this.client.get<ClickUpTask>(url, { params });

        // Handle potential non-JSON responses (though less likely with GET)
        const data = response.data;
        if (typeof data === 'string') {
          throw new ClickUpServiceError(
            'Received unexpected text response from API when fetching by custom ID',
            ErrorCode.UNKNOWN,
            data
          );
        }

        return data;
      });
    } catch (error) {
      // Provide more specific error context if possible
      if (error instanceof ClickUpServiceError && error.code === ErrorCode.NOT_FOUND) {
        throw new ClickUpServiceError(
          `Task with custom ID ${customTaskId} not found or not accessible for team ${this.teamId}.`,
          ErrorCode.NOT_FOUND,
          error.data
        );
      }
      throw this.handleError(error, `Failed to get task with custom ID ${customTaskId}`);
    }
  }

  /**
   * Update an existing task
   * @param taskId The ID of the task to update
   * @param updateData The data to update
   * @returns The updated task
   */
  async updateTask(taskId: string, updateData: UpdateTaskData): Promise<ClickUpTask> {
    this.logOperation('updateTask', { taskId, ...updateData });
    
    try {
      // Extract custom fields from updateData
      const { custom_fields, ...standardFields } = updateData;
      
      // First update the standard fields
      const updatedTask = await this.makeRequest(async () => {
        const response = await this.client.put<ClickUpTask | string>(
          `/task/${taskId}`,
          standardFields
        );
        
        // Handle both JSON and text responses
        const data = response.data;
        if (typeof data === 'string') {
          // If we got a text response, try to extract task ID from common patterns
          const idMatch = data.match(/task.*?(\w{9})/i);
          if (idMatch) {
            // If we found an ID, fetch the full task details
            return await this.getTask(idMatch[1]);
          }
          throw new ClickUpServiceError(
            'Received unexpected text response from API',
            ErrorCode.UNKNOWN,
            data
          );
        }
        
        return data;
      });
      
      // Then update custom fields if provided
      if (custom_fields && Array.isArray(custom_fields) && custom_fields.length > 0) {
        // Use the setCustomFieldValues method from the inherited class
        // This will be available in TaskServiceCustomFields which extends this class
        await (this as any).setCustomFieldValues(taskId, custom_fields);
        
        // Fetch the task again to get the updated version with custom fields
        return await this.getTask(taskId);
      }
      
      return updatedTask;
    } catch (error) {
      throw this.handleError(error, `Failed to update task ${taskId}`);
    }
  }

  /**
   * Delete a task
   * @param taskId The ID of the task to delete
   * @returns A ServiceResponse indicating success
   */
  async deleteTask(taskId: string): Promise<ServiceResponse<void>> {
    this.logOperation('deleteTask', { taskId });
    
    try {
      await this.makeRequest(async () => {
        await this.client.delete(`/task/${taskId}`);
      });
      
      return {
        success: true,
        data: undefined,
        error: undefined
      };
    } catch (error) {
      throw this.handleError(error, `Failed to delete task ${taskId}`);
    }
  }

  /**
   * Move a task to another list
   * @param taskId The ID of the task to move
   * @param destinationListId The ID of the list to move the task to
   * @returns The updated task
   */
  async moveTask(taskId: string, destinationListId: string): Promise<ClickUpTask> {
    const startTime = Date.now();
    this.logOperation('moveTask', { taskId, destinationListId, operation: 'start' });
    
    try {
      // First, get task and validate destination list
      const [sourceTask, _] = await Promise.all([
        this.validateTaskExists(taskId),
        this.validateListExists(destinationListId)
      ]);

      // Extract task data for creating the new task
      const taskData = this.extractTaskData(sourceTask);
      
      // Create the task in the new list
      const newTask = await this.createTask(destinationListId, taskData);
      
      // Delete the original task
      await this.deleteTask(taskId);
      
      // Update the cache
      this.validationCache.tasks.delete(taskId);
      this.validationCache.tasks.set(newTask.id, {
        validatedAt: Date.now(),
        task: newTask
      });

      const totalTime = Date.now() - startTime;
      this.logOperation('moveTask', { 
        taskId, 
        destinationListId, 
        operation: 'complete',
        timing: { totalTime },
        newTaskId: newTask.id
      });

      return newTask;
    } catch (error) {
      // Log failure
      this.logOperation('moveTask', { 
        taskId, 
        destinationListId, 
        operation: 'failed',
        error: error instanceof Error ? error.message : String(error),
        timing: { totalTime: Date.now() - startTime }
      });
      throw this.handleError(error, 'Failed to move task');
    }
  }

  /**
   * Duplicate a task, optionally to a different list
   * @param taskId The ID of the task to duplicate
   * @param listId Optional ID of list to create duplicate in (defaults to same list)
   * @returns The duplicated task
   */
  async duplicateTask(taskId: string, listId?: string): Promise<ClickUpTask> {
    this.logOperation('duplicateTask', { taskId, listId });
    
    try {
      // Get source task and validate destination list if provided
      const [sourceTask, _] = await Promise.all([
        this.validateTaskExists(taskId),
        listId ? this.validateListExists(listId) : Promise.resolve()
      ]);

      // Create duplicate in specified list or original list
      const targetListId = listId || sourceTask.list.id;
      const taskData = this.extractTaskData(sourceTask);
      
      return await this.createTask(targetListId, taskData);
    } catch (error) {
      throw this.handleError(error, `Failed to duplicate task ${taskId}`);
    }
  }

  /**
   * Validate a task exists and cache the result
   * @param taskId The ID of the task to validate
   * @returns The validated task
   */
  protected async validateTaskExists(taskId: string): Promise<ClickUpTask> {
    // Check cache first
    const cached = this.validationCache.tasks.get(taskId);
    if (cached && Date.now() - cached.validatedAt < this.CACHE_TTL) {
      this.logger.debug('Using cached task validation', { taskId });
      return cached.task;
    }

    // Not in cache or expired, fetch task
    const task = await this.getTask(taskId);
    
    // Cache the validation result
    this.validationCache.tasks.set(taskId, {
      validatedAt: Date.now(),
      task
    });

    return task;
  }

  /**
   * Validate that multiple tasks exist
   * @param taskIds Array of task IDs to validate
   * @returns Map of task IDs to task objects
   */
  public async validateTasksExist(taskIds: string[]): Promise<Map<string, ClickUpTask>> {
    const results = new Map<string, ClickUpTask>();
    const toFetch: string[] = [];

    // Check cache first
    for (const taskId of taskIds) {
      const cached = this.validationCache.tasks.get(taskId);
      if (cached && Date.now() - cached.validatedAt < this.CACHE_TTL) {
        results.set(taskId, cached.task);
      } else {
        toFetch.push(taskId);
      }
    }

    if (toFetch.length > 0) {
      // Fetch uncached tasks in parallel batches
      const batchSize = 5;
      for (let i = 0; i < toFetch.length; i += batchSize) {
        const batch = toFetch.slice(i, i + batchSize);
        const tasks = await Promise.all(
          batch.map(id => this.getTask(id))
        );

        // Cache and store results
        tasks.forEach((task, index) => {
          const taskId = batch[index];
          this.validationCache.tasks.set(taskId, {
            validatedAt: Date.now(),
            task
          });
          results.set(taskId, task);
        });
      }
    }

    return results;
  }

  /**
   * Validate a list exists and cache the result
   * @param listId The ID of the list to validate
   */
  async validateListExists(listId: string): Promise<void> {
    // Check cache first
    const cached = this.validationCache.lists.get(listId);
    if (cached && Date.now() - cached.validatedAt < this.CACHE_TTL) {
      this.logger.debug('Using cached list validation', { listId });
      if (!cached.valid) {
        throw new ClickUpServiceError(
          `List ${listId} does not exist`,
          ErrorCode.NOT_FOUND
        );
      }
      return;
    }

    try {
      await this.listService.getList(listId);
      
      // Cache the successful validation
      this.validationCache.lists.set(listId, {
        validatedAt: Date.now(),
        valid: true
      });
    } catch (error) {
      // Cache the failed validation
      this.validationCache.lists.set(listId, {
        validatedAt: Date.now(),
        valid: false
      });
      throw error;
    }
  }

  /**
   * Try to get a task ID from the name cache
   * @param taskName The name of the task
   * @param listId Optional list ID for context
   * @returns The cached task ID if found and not expired, otherwise null
   */
  protected getCachedTaskId(taskName: string, listId?: string): string | null {
    const cached = this.nameToIdCache.get(taskName);
    if (cached && Date.now() - cached.validatedAt < this.CACHE_TTL) {
      // If listId is provided, ensure it matches the cached context
      if (!listId || cached.listId === listId) {
        this.logger.debug('Using cached task ID for name', { taskName, cachedId: cached.taskId });
        return cached.taskId;
      }
    }
    return null;
  }

  /**
   * Cache a task name to ID mapping
   * @param taskName The name of the task
   * @param taskId The ID of the task
   * @param listId Optional list ID for context
   */
  protected cacheTaskNameToId(taskName: string, taskId: string, listId?: string): void {
    this.nameToIdCache.set(taskName, {
      taskId,
      validatedAt: Date.now(),
      listId
    });
    this.logger.debug('Cached task name to ID mapping', { taskName, taskId, listId });
  }
}
</file>

<file path="release-notes.md">
# v0.7.2 Release Notes (2025-04-25)

## 🛠️ Bug Fixes

- Fixed time estimate support in task updates:
  - Removed redundant field-specific validation check in task update operations
  - Simplified validation to check only for the presence of update fields
  - Fixed "At least one field to update must be provided" error when using time_estimate
  - Added time string parsing for converting formats like "2h 30m" to minutes
  - Improved tool description for clear guidance on supported formats
  - Ensures compatibility with all fields defined in the UpdateTaskData type

## 📦 Dependencies

- No dependency changes in this release

## 🙏 Thank You

Special thanks to our contributors who reported and helped fix this issue:

- [@m-roberts](https://github.com/m-roberts) - Reporting and suggesting fix for the time estimate update issue

Your feedback helps make ClickUp MCP Server better for everyone!
</file>

<file path="src/tools/task/single-operations.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Single Task Operations
 * 
 * This module defines tools for single task operations including creating,
 * updating, moving, duplicating, and deleting tasks, as well as retrieving
 * task details and comments.
 */

import { 
  ClickUpComment,
  ClickUpTask, 
  CreateTaskData,
  TaskPriority, 
  UpdateTaskData
} from '../../services/clickup/types.js';
import { parseDueDate } from '../utils.js';
import { clickUpServices } from '../../services/shared.js';
import { 
  formatTaskData,
  resolveListIdWithValidation,
  validateTaskUpdateData,
  validateTaskIdentification,
  validateListIdentification
} from './utilities.js';

// Use shared services instance
const { task: taskService } = clickUpServices;

//=============================================================================
// COMMON VALIDATION UTILITIES
//=============================================================================

// Common validation functions
const validateTaskName = (name: string) => {
  if (!name || typeof name !== 'string') {
    throw new Error("A task name is required");
  }

  const trimmedName = name.trim();
  if (trimmedName.length === 0) {
    throw new Error("Task name cannot be empty or only whitespace");
  }
  return trimmedName;
};

const validatePriority = (priority?: number) => {
  if (priority !== undefined && (typeof priority !== 'number' || priority < 1 || priority > 4)) {
    throw new Error("Priority must be a number between 1 and 4");
  }
};

const validateDueDate = (dueDate?: string) => {
  if (dueDate && typeof dueDate !== 'string') {
    throw new Error("Due date must be a string in timestamp format or natural language");
  }
};

// Common error handler
const handleOperationError = (operation: string, error: any) => {
  console.error(`Error ${operation}:`, error);
  throw error;
};

//=============================================================================
// SINGLE TASK OPERATION TOOLS
//=============================================================================

/**
 * Tool definition for creating a single task
 */
export const createTaskTool = {
  name: "create_task",
  description: `Creates a single task in a ClickUp list. Use listId (preferred) or listName. Required: name + list info. For multiple tasks use create_bulk_tasks. Can create subtasks via parent param. Supports custom fields as array of {id, value}.`,
  inputSchema: {
    type: "object",
    properties: {
      name: {
        type: "string",
        description: "REQUIRED: Name of the task. Put a relevant emoji followed by a blank space before the name."
      },
      listId: {
        type: "string",
        description: "REQUIRED (unless listName provided): ID of the list to create the task in. If you have this ID from a previous response, use it directly rather than looking up by name."
      },
      listName: {
        type: "string",
        description: "REQUIRED (unless listId provided): Name of the list to create the task in - will automatically find the list by name."
      },
      description: {
        type: "string",
        description: "Optional plain text description for the task"
      },
      markdown_description: {
        type: "string",
        description: "Optional markdown formatted description for the task. If provided, this takes precedence over description"
      },
      status: {
        type: "string",
        description: "Optional: Override the default ClickUp status. In most cases, you should omit this to use ClickUp defaults"
      },
      priority: {
        type: "number",
        description: "Optional priority of the task (1-4), where 1 is urgent/highest priority and 4 is lowest priority. Only set this when explicitly requested."
      },
      dueDate: {
        type: "string",
        description: "Optional due date. Supports Unix timestamps (ms) or natural language like '1 hour from now', 'tomorrow', 'next week', etc."
      },
      startDate: {
        type: "string",
        description: "Optional start date. Supports Unix timestamps (ms) or natural language like 'now', 'start of today', etc."
      },
      parent: {
        type: "string",
        description: "Optional ID of the parent task. When specified, this task will be created as a subtask of the specified parent task."
      },
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        description: "Optional array of tag names to assign to the task. The tags must already exist in the space."
      },
      custom_fields: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID of the custom field"
            },
            value: {
              description: "Value for the custom field. Type depends on the field type."
            }
          },
          required: ["id", "value"]
        },
        description: "Optional array of custom field values to set on the task. Each object must have an 'id' and 'value' property."
      },
      check_required_custom_fields: {
        type: "boolean",
        description: "Optional flag to check if all required custom fields are set before saving the task."
      }
    }
  }
};

/**
 * Tool definition for updating a task
 */
export const updateTaskTool = {
  name: "update_task",
  description: `Updates task properties. Use taskId (preferred) or taskName + optional listName. At least one update field required. Custom fields supported as array of {id, value}. WARNING: Using taskName without listName may match multiple tasks.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of task to update (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of task to update. The tool will search for tasks with this name across all lists unless listName is specified."
      },
      listName: {
        type: "string",
        description: "Optional: Name of list containing the task. Providing this narrows the search to a specific list, improving performance and reducing ambiguity."
      },
      name: {
        type: "string",
        description: "New name for the task. Include emoji prefix if appropriate."
      },
      description: {
        type: "string",
        description: "New plain text description. Will be ignored if markdown_description is provided."
      },
      markdown_description: {
        type: "string",
        description: "New markdown description. Takes precedence over plain text description."
      },
      status: {
        type: "string",
        description: "New status. Must be valid for the task's current list."
      },
      priority: {
        type: "number",
        nullable: true,
        enum: [1, 2, 3, 4, null],
        description: "New priority: 1 (urgent) to 4 (low). Set null to clear priority."
      },
      dueDate: {
        type: "string",
        description: "New due date. Supports both Unix timestamps (in milliseconds) and natural language expressions like '1 hour from now', 'tomorrow', 'next week', or '3 days from now'."
      },
      startDate: {
        type: "string",
        description: "New start date. Supports both Unix timestamps (in milliseconds) and natural language expressions."
      },
      time_estimate: {
        type: "string",
        description: "Time estimate for the task. For best compatibility with the ClickUp API, use a numeric value in minutes (e.g., '150' for 2h 30m)"
      },
      custom_fields: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID of the custom field"
            },
            value: {
              description: "Value for the custom field. Type depends on the field type."
            }
          },
          required: ["id", "value"]
        },
        description: "Optional array of custom field values to set on the task. Each object must have an 'id' and 'value' property."
      }
    }
  }
};

/**
 * Tool definition for moving a task
 */
export const moveTaskTool = {
  name: "move_task",
  description: `Moves task to different list. Use taskId + (listId/listName) preferred, or taskName + sourceListName + (listId/listName). WARNING: Task statuses may reset if destination list has different status options.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of the task to move (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of the task to move. When using this, you MUST also provide sourceListName."
      },
      sourceListName: {
        type: "string",
        description: "REQUIRED with taskName: Current list containing the task."
      },
      listId: {
        type: "string",
        description: "ID of destination list (preferred). Use this instead of listName if you have it."
      },
      listName: {
        type: "string",
        description: "Name of destination list. Only use if you don't have listId."
      }
    },
    required: []
  }
};

/**
 * Tool definition for duplicating a task
 */
export const duplicateTaskTool = {
  name: "duplicate_task",
  description: `Creates copy of task in same/different list. Use taskId + optional (listId/listName), or taskName + sourceListName + optional (listId/listName). Preserves original properties. Default: same list as original.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of task to duplicate (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of task to duplicate. When using this, you MUST provide sourceListName."
      },
      sourceListName: {
        type: "string",
        description: "REQUIRED with taskName: List containing the original task."
      },
      listId: {
        type: "string",
        description: "ID of list for the duplicate (optional). Defaults to same list as original."
      },
      listName: {
        type: "string",
        description: "Name of list for the duplicate. Only use if you don't have listId."
      }
    },
    required: []
  }
};

/**
 * Tool definition for retrieving task details
 */
export const getTaskTool = {
  name: "get_task",
  description: `Gets task details by taskId (works with regular/custom IDs) or taskName. For taskName search, provide listName for faster lookup. Set subtasks=true to include all subtask details.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of task to retrieve (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234'). The system automatically detects the ID format."
      },
      taskName: {
        type: "string",
        description: "Name of task to retrieve. Can be used alone for a global search, or with listName for faster lookup."
      },
      listName: {
        type: "string",
        description: "Name of list containing the task. Optional but recommended when using taskName."
      },
      customTaskId: {
        type: "string",
        description: "Custom task ID (e.g., 'DEV-1234'). Only use this if you want to explicitly force custom ID lookup. In most cases, you can just use taskId which auto-detects ID format."
      },
      subtasks: {
        type: "boolean",
        description: "Whether to include subtasks in the response. Set to true to retrieve full details of all subtasks."
      }
    }
  }
};

/**
 * Tool definition for retrieving tasks from a list
 */
export const getTasksTool = {
  name: "get_tasks",
  description: `Purpose: Retrieve tasks from a list with optional filtering.

Valid Usage:
1. Use listId (preferred)
2. Use listName

Requirements:
- EITHER listId OR listName is REQUIRED

Notes:
- Use filters (archived, statuses, etc.) to narrow down results
- Pagination available through page parameter
- Sorting available through order_by and reverse parameters`,
  inputSchema: {
    type: "object",
    properties: {
      listId: {
        type: "string",
        description: "ID of list to get tasks from (preferred). Use this instead of listName if you have it."
      },
      listName: {
        type: "string",
        description: "Name of list to get tasks from. Only use if you don't have listId."
      },
      subtasks: {
        type: "boolean",
        description: "Include subtasks"
      },
      statuses: {
        type: "array",
        items: { type: "string" },
        description: "Filter by status names (e.g. ['To Do', 'In Progress'])"
      },
      archived: {
        type: "boolean",
        description: "Include archived tasks"
      },
      page: {
        type: "number",
        description: "Page number for pagination (starts at 0)"
      },
      order_by: {
        type: "string",
        description: "Sort field: due_date, created, updated"
      },
      reverse: {
        type: "boolean",
        description: "Reverse sort order (descending)"
      }
    },
    required: []
  }
};

/**
 * Tool definition for retrieving task comments
 */
export const getTaskCommentsTool = {
  name: "get_task_comments",
  description: `Gets task comments. Use taskId (preferred) or taskName + optional listName. Use start/startId params for pagination. Task names may not be unique across lists.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of task to retrieve comments for (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of task to retrieve comments for. Warning: Task names may not be unique."
      },
      listName: {
        type: "string",
        description: "Name of list containing the task. Helps find the right task when using taskName."
      },
      start: {
        type: "number",
        description: "Timestamp (in milliseconds) to start retrieving comments from. Used for pagination."
      },
      startId: {
        type: "string",
        description: "Comment ID to start from. Used together with start for pagination."
      }
    }
  }
};

/**
 * Tool definition for creating a comment on a task
 */
export const createTaskCommentTool = {
  name: "create_task_comment",
  description: `Creates task comment. Use taskId (preferred) or taskName + listName. Required: commentText. Optional: notifyAll to notify assignees, assignee to assign comment.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of task to comment on (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of task to comment on. When using this parameter, you MUST also provide listName."
      },
      listName: {
        type: "string",
        description: "Name of list containing the task. REQUIRED when using taskName."
      },
      commentText: {
        type: "string",
        description: "REQUIRED: Text content of the comment to create."
      },
      notifyAll: {
        type: "boolean",
        description: "Whether to notify all assignees. Default is false."
      },
      assignee: {
        type: "number",
        description: "Optional user ID to assign the comment to."
      }
    },
    required: ["commentText"]
  }
};

/**
 * Tool definition for deleting a task
 */
export const deleteTaskTool = {
  name: "delete_task",
  description: `PERMANENTLY deletes task. Use taskId (preferred/safest) or taskName + optional listName. WARNING: Cannot be undone. Using taskName without listName may match multiple tasks.`,
  inputSchema: {
    type: "object",
    properties: {
      taskId: {
        type: "string",
        description: "ID of task to delete (preferred). Works with both regular task IDs (9 characters) and custom IDs with uppercase prefixes (like 'DEV-1234')."
      },
      taskName: {
        type: "string",
        description: "Name of task to delete. The tool will search for tasks with this name across all lists unless listName is specified."
      },
      listName: {
        type: "string",
        description: "Optional: Name of list containing the task. Providing this narrows the search to a specific list, improving performance and reducing ambiguity."
      }
    }
  }
};
</file>

<file path="src/tools/task/handlers.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * ClickUp MCP Task Operation Handlers
 * 
 * This module implements the handlers for task operations, both for single task
 * and bulk operations. These handlers are used by the tool definitions.
 */

import { ClickUpComment, ClickUpTask, TaskPriority, UpdateTaskData, TaskFilters, toTaskPriority, CreateTaskData } from '../../services/clickup/types.js';
import { clickUpServices } from '../../services/shared.js';
import { BulkService } from '../../services/clickup/bulk.js';
import { BatchResult } from '../../utils/concurrency-utils.js';
import { parseDueDate } from '../utils.js';
import { 
  validateTaskIdentification, 
  validateListIdentification,
  validateTaskUpdateData,
  validateBulkTasks,
  parseBulkOptions,
  resolveListIdWithValidation,
  formatTaskData
} from './utilities.js';
import { TaskService } from '../../services/clickup/task/task-service.js';
import { ExtendedTaskFilters } from '../../services/clickup/types.js';
import { findListIDByName } from '../list.js';
import { workspaceService } from '../../services/shared.js';
import { isNameMatch } from '../../utils/resolver-utils.js';
import { Logger } from '../../logger.js';

// Use shared services instance
const { task: taskService, list: listService } = clickUpServices;

// Create a bulk service instance that uses the task service
const bulkService = new BulkService(taskService);

// Create a logger instance for task handlers
const logger = new Logger('TaskHandlers');

// Token limit constant for workspace tasks
const WORKSPACE_TASKS_TOKEN_LIMIT = 50000;

// Cache for task context between sequential operations
const taskContextCache = new Map<string, { id: string, timestamp: number }>();
const TASK_CONTEXT_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Store task context for sequential operations
 */
function storeTaskContext(taskName: string, taskId: string) {
  taskContextCache.set(taskName, {
    id: taskId,
    timestamp: Date.now()
  });
}

/**
 * Get cached task context if valid
 */
function getCachedTaskContext(taskName: string): string | null {
  const context = taskContextCache.get(taskName);
  if (!context) return null;
  
  if (Date.now() - context.timestamp > TASK_CONTEXT_TTL) {
    taskContextCache.delete(taskName);
    return null;
  }
  
  return context.id;
}

//=============================================================================
// SHARED UTILITY FUNCTIONS
//=============================================================================

/**
 * Parse time estimate string into minutes
 * Supports formats like "2h 30m", "150m", "2.5h"
 */
function parseTimeEstimate(timeEstimate: string | number): number {
  // If it's already a number, return it directly
  if (typeof timeEstimate === 'number') {
    return timeEstimate;
  }
  
  if (!timeEstimate || typeof timeEstimate !== 'string') return 0;
  
  // If it's just a number as string, parse it
  if (/^\d+$/.test(timeEstimate)) {
    return parseInt(timeEstimate, 10);
  }
  
  let totalMinutes = 0;
  
  // Extract hours
  const hoursMatch = timeEstimate.match(/(\d+\.?\d*)h/);
  if (hoursMatch) {
    totalMinutes += parseFloat(hoursMatch[1]) * 60;
  }
  
  // Extract minutes
  const minutesMatch = timeEstimate.match(/(\d+)m/);
  if (minutesMatch) {
    totalMinutes += parseInt(minutesMatch[1], 10);
  }
  
  return Math.round(totalMinutes); // Return minutes
}

/**
 * Build task update data from parameters
 */
function buildUpdateData(params: any): UpdateTaskData {
  const updateData: UpdateTaskData = {};
  
  if (params.name !== undefined) updateData.name = params.name;
  if (params.description !== undefined) updateData.description = params.description;
  if (params.markdown_description !== undefined) updateData.markdown_description = params.markdown_description;
  if (params.status !== undefined) updateData.status = params.status;
  
  // Skip toTaskPriority conversion since we're handling priority in the main handler
  if (params.priority !== undefined) updateData.priority = params.priority;
  
  if (params.dueDate !== undefined) {
    updateData.due_date = parseDueDate(params.dueDate);
    updateData.due_date_time = true;
  }
  
  if (params.startDate !== undefined) {
    updateData.start_date = parseDueDate(params.startDate);
    updateData.start_date_time = true;
  }
  
  // Handle time estimate if provided - convert from string to minutes
  if (params.time_estimate !== undefined) {
    // Log the time estimate for debugging
    console.log(`Original time_estimate: ${params.time_estimate}, typeof: ${typeof params.time_estimate}`);
    
    // Parse and convert to number in minutes
    const minutes = parseTimeEstimate(params.time_estimate);
    
    console.log(`Converted time_estimate: ${minutes}`);
    updateData.time_estimate = minutes;
  }
  
  // Handle custom fields if provided
  if (params.custom_fields !== undefined) {
    updateData.custom_fields = params.custom_fields;
  }
  
  return updateData;
}

/**
 * Core function to find a task by ID or name
 * This consolidates all task lookup logic in one place for consistency
 */
async function findTask(params: {
  taskId?: string,
  taskName?: string,
  listName?: string,
  customTaskId?: string,
  requireId?: boolean,
  includeSubtasks?: boolean
}) {
  const { taskId, taskName, listName, customTaskId, requireId = false, includeSubtasks = false } = params;

  // Validate that we have enough information to identify a task
  const validationResult = validateTaskIdentification(
    { taskId, taskName, listName, customTaskId },
    { requireTaskId: requireId, useGlobalLookup: true }
  );
  
  if (!validationResult.isValid) {
    throw new Error(validationResult.errorMessage);
  }
  
  try {
    // Direct path for taskId - most efficient
    if (taskId) {
      const task = await taskService.getTask(taskId);
      
      // Add subtasks if requested
      if (includeSubtasks) {
        const subtasks = await taskService.getSubtasks(task.id);
        return { task, subtasks };
      }
      
      return { task };
    }
    
    // Direct path for customTaskId - also efficient
    if (customTaskId) {
      const task = await taskService.getTaskByCustomId(customTaskId);
      
      // Add subtasks if requested
      if (includeSubtasks) {
        const subtasks = await taskService.getSubtasks(task.id);
        return { task, subtasks };
      }
      
      return { task };
    }
    
    // Special optimized path for taskName + listName combination
    if (taskName && listName) {
      const listId = await resolveListIdWithValidation(null, listName);
      
      // Get all tasks in the list
      const allTasks = await taskService.getTasks(listId);
      
      // Find the task that matches the name
      const matchingTask = findTaskByName(allTasks, taskName);
      
      if (!matchingTask) {
        throw new Error(`Task "${taskName}" not found in list "${listName}"`);
      }
      
      // Add subtasks if requested
      if (includeSubtasks) {
        const subtasks = await taskService.getSubtasks(matchingTask.id);
        return { task: matchingTask, subtasks };
      }
      
      return { task: matchingTask };
    }
    
    // Fallback to searching all lists for taskName-only case
    if (taskName) {
      logger.debug(`Searching all lists for task: "${taskName}"`);
      
      // Get workspace hierarchy which contains all lists
      const hierarchy = await workspaceService.getWorkspaceHierarchy();
      
      // Extract all list IDs from the hierarchy
      const listIds: string[] = [];
      const extractListIds = (node: any) => {
        if (node.type === 'list') {
          listIds.push(node.id);
        }
        if (node.children) {
          node.children.forEach(extractListIds);
        }
      };
      
      // Start from the root's children
      hierarchy.root.children.forEach(extractListIds);
      
      // Search through each list
      const searchPromises = listIds.map(async (listId) => {
        try {
          const tasks = await taskService.getTasks(listId);
          const matchingTask = findTaskByName(tasks, taskName);
          if (matchingTask) {
            logger.debug(`Found task "${matchingTask.name}" (ID: ${matchingTask.id}) in list with ID "${listId}"`);
            return matchingTask;
          }
          return null;
        } catch (error) {
          logger.warn(`Error searching list ${listId}: ${error.message}`);
          return null;
        }
      });
      
      // Wait for all searches to complete
      const results = await Promise.all(searchPromises);
      
      // Filter out null results and sort by match quality and recency
      const matchingTasks = results
        .filter(task => task !== null)
        .sort((a, b) => {
          const aMatch = isNameMatch(a.name, taskName);
          const bMatch = isNameMatch(b.name, taskName);
          
          // First sort by match quality
          if (bMatch.score !== aMatch.score) {
            return bMatch.score - aMatch.score;
          }
          
          // Then sort by recency
          return parseInt(b.date_updated) - parseInt(a.date_updated);
        });
      
      if (matchingTasks.length === 0) {
        throw new Error(`Task "${taskName}" not found in any list across your workspace. Please check the task name and try again.`);
      }
      
      const bestMatch = matchingTasks[0];
      
      // Add subtasks if requested
      if (includeSubtasks) {
        const subtasks = await taskService.getSubtasks(bestMatch.id);
        return { task: bestMatch, subtasks };
      }
      
      return { task: bestMatch };
    }
    
    // We shouldn't reach here if validation is working correctly
    throw new Error("No valid task identification provided");
    
  } catch (error) {
    // Enhance error message for non-existent tasks
    if (taskName && error.message.includes('not found')) {
      throw new Error(`Task "${taskName}" not found. Please check the task name and try again.`);
    }
    
    // Pass along other formatted errors
    throw error;
  }
}

/**
 * Helper function to find a task by name in an array of tasks
 */
function findTaskByName(tasks, name) {
  if (!tasks || !Array.isArray(tasks) || !name) return null;
  
  const normalizedSearchName = name.toLowerCase().trim();
  
  // Get match scores for all tasks
  const taskMatchScores = tasks.map(task => {
    const matchResult = isNameMatch(task.name, name);
    return {
      task,
      matchResult,
      // Parse the date_updated field as a number for sorting
      updatedAt: task.date_updated ? parseInt(task.date_updated, 10) : 0
    };
  }).filter(result => result.matchResult.isMatch);
  
  if (taskMatchScores.length === 0) {
    return null;
  }
  
  // First, try to find exact matches
  const exactMatches = taskMatchScores
    .filter(result => result.matchResult.exactMatch)
    .sort((a, b) => {
      // For exact matches with the same score, sort by most recently updated
      if (b.matchResult.score === a.matchResult.score) {
        return b.updatedAt - a.updatedAt;
      }
      return b.matchResult.score - a.matchResult.score;
    });
  
  // Get the best matches based on whether we have exact matches or need to fall back to fuzzy matches
  const bestMatches = exactMatches.length > 0 ? exactMatches : taskMatchScores.sort((a, b) => {
    // First sort by match score (highest first)
    if (b.matchResult.score !== a.matchResult.score) {
      return b.matchResult.score - a.matchResult.score;
    }
    // Then sort by most recently updated
    return b.updatedAt - a.updatedAt;
  });
  
  // Get the best match
  return bestMatches[0].task;
}

/**
 * Handler for getting a task - uses the consolidated findTask function
 */
export async function getTaskHandler(params) {
  try {
    const result = await findTask({
      taskId: params.taskId,
      taskName: params.taskName,
      listName: params.listName,
      customTaskId: params.customTaskId,
      includeSubtasks: params.subtasks
    });
    
    if (result.subtasks) {
      return { ...result.task, subtasks: result.subtasks };
    }
    
    return result.task;
  } catch (error) {
    throw error;
  }
}

/**
 * Get task ID from various identifiers - uses the consolidated findTask function
 */
export async function getTaskId(taskId?: string, taskName?: string, listName?: string, customTaskId?: string, requireId?: boolean, includeSubtasks?: boolean): Promise<string> {
  // Check task context cache first if we have a task name
  if (taskName && !taskId && !customTaskId) {
    const cachedId = getCachedTaskContext(taskName);
    if (cachedId) {
      return cachedId;
    }
  }

  const result = await findTask({
    taskId,
    taskName,
    listName,
    customTaskId,
    requireId,
    includeSubtasks
  });
  
  // Store task context for future operations
  if (taskName && result.task.id) {
    storeTaskContext(taskName, result.task.id);
  }
  
  return result.task.id;
}

/**
 * Process a list identification validation, returning the list ID
 */
async function getListId(listId?: string, listName?: string): Promise<string> {
  validateListIdentification(listId, listName);
  return await resolveListIdWithValidation(listId, listName);
}

/**
 * Extract and build task filters from parameters
 */
function buildTaskFilters(params: any): TaskFilters {
  const { subtasks, statuses, page, order_by, reverse } = params;
  const filters: TaskFilters = {};
  
  if (subtasks !== undefined) filters.subtasks = subtasks;
  if (statuses !== undefined) filters.statuses = statuses;
  if (page !== undefined) filters.page = page;
  if (order_by !== undefined) filters.order_by = order_by;
  if (reverse !== undefined) filters.reverse = reverse;
  
  return filters;
}

/**
 * Map tasks for bulk operations, resolving task IDs
 * Uses smart disambiguation for tasks without list context
 */
async function mapTaskIds(tasks: any[]): Promise<string[]> {
  return Promise.all(tasks.map(async (task) => {
    const validationResult = validateTaskIdentification(
      { taskId: task.taskId, taskName: task.taskName, listName: task.listName, customTaskId: task.customTaskId },
      { useGlobalLookup: true }
    );
    
    if (!validationResult.isValid) {
      throw new Error(validationResult.errorMessage);
    }
    
    return await getTaskId(task.taskId, task.taskName, task.listName, task.customTaskId);
  }));
}

//=============================================================================
// SINGLE TASK OPERATIONS
//=============================================================================

/**
 * Handler for creating a task
 */
export async function createTaskHandler(params) {
  const { 
    name, 
    description, 
    markdown_description, 
    status, 
    dueDate, 
    startDate, 
    parent, 
    tags,
    custom_fields,
    check_required_custom_fields
  } = params;
  
  if (!name) throw new Error("Task name is required");
  
  // Use our helper function to validate and convert priority
  const priority = toTaskPriority(params.priority);

  const listId = await getListId(params.listId, params.listName);
  
  const taskData: CreateTaskData = {
    name,
    description,
    markdown_description,
    status,
    priority,
    parent,
    tags,
    custom_fields,
    check_required_custom_fields
  };
  
  // Add due date if specified
  if (dueDate) {
    taskData.due_date = parseDueDate(dueDate);
    taskData.due_date_time = true;
  }
  
  // Add start date if specified
  if (startDate) {
    taskData.start_date = parseDueDate(startDate);
    taskData.start_date_time = true;
  }
  
  return await taskService.createTask(listId, taskData);
}

export interface UpdateTaskParams extends UpdateTaskData {
  taskId?: string;
  taskName?: string;
  listName?: string;
  customTaskId?: string;
}

/**
 * Handler for updating a task
 */
export async function updateTaskHandler(
  taskService: TaskService,
  params: UpdateTaskParams
): Promise<ClickUpTask> {
  const { taskId, taskName, listName, customTaskId, ...updateData } = params;
  
  // Validate task identification with global lookup enabled
  const validationResult = validateTaskIdentification(params, { useGlobalLookup: true });
  if (!validationResult.isValid) {
    throw new Error(validationResult.errorMessage);
  }

  // Validate update data
  validateTaskUpdateData(updateData);

  try {
    // Get the task ID using global lookup
    const id = await getTaskId(taskId, taskName, listName, customTaskId);
    return await taskService.updateTask(id, updateData);
  } catch (error) {
    throw new Error(`Failed to update task: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Handler for moving a task
 */
export async function moveTaskHandler(params) {
  const taskId = await getTaskId(params.taskId, params.taskName, undefined, params.customTaskId, false);
  const listId = await getListId(params.listId, params.listName);
  return await taskService.moveTask(taskId, listId);
}

/**
 * Handler for duplicating a task
 */
export async function duplicateTaskHandler(params) {
  const taskId = await getTaskId(params.taskId, params.taskName, undefined, params.customTaskId, false);
  let listId;
  
  if (params.listId || params.listName) {
    listId = await getListId(params.listId, params.listName);
  }
  
  return await taskService.duplicateTask(taskId, listId);
}

/**
 * Handler for getting tasks
 */
export async function getTasksHandler(params) {
  const listId = await getListId(params.listId, params.listName);
  return await taskService.getTasks(listId, buildTaskFilters(params));
}

/**
 * Handler for getting task comments
 */
export async function getTaskCommentsHandler(params) {
  const taskId = await getTaskId(params.taskId, params.taskName, params.listName);
  const { start, startId } = params;
  return await taskService.getTaskComments(taskId, start, startId);
}

/**
 * Handler for creating a task comment
 */
export async function createTaskCommentHandler(params) {
  // Validate required parameters
  if (!params.commentText) {
    throw new Error('Comment text is required');
  }
  
  try {
    // Resolve the task ID
    const taskId = await getTaskId(params.taskId, params.taskName, params.listName);
    
    // Extract other parameters with defaults
    const {
      commentText,
      notifyAll = false,
      assignee = null
    } = params;
    
    // Create the comment
    return await taskService.createTaskComment(taskId, commentText, notifyAll, assignee);
  } catch (error) {
    // If this is a task lookup error, provide more helpful message
    if (error.message?.includes('not found') || error.message?.includes('identify task')) {
      if (params.taskName) {
        throw new Error(`Could not find task "${params.taskName}" in list "${params.listName}"`);
      } else {
        throw new Error(`Task with ID "${params.taskId}" not found`);
      }
    }
    
    // Otherwise, rethrow the original error
    throw error;
  }
}

/**
 * Estimate tokens for a task response
 * This is a simplified estimation - adjust based on actual token counting needs
 */
function estimateTaskResponseTokens(task: ClickUpTask): number {
  // Base estimation for task structure
  let tokenCount = 0;
  
  // Core fields
  tokenCount += (task.name?.length || 0) / 4; // Approximate tokens for name
  tokenCount += (task.description?.length || 0) / 4; // Approximate tokens for description
  tokenCount += (task.text_content?.length || 0) / 4; // Use text_content instead of markdown_description
  
  // Status and other metadata
  tokenCount += 5; // Basic metadata fields
  
  // Custom fields
  if (task.custom_fields) {
    tokenCount += Object.keys(task.custom_fields).length * 10; // Rough estimate per custom field
  }
  
  // Add overhead for JSON structure
  tokenCount *= 1.1;
  
  return Math.ceil(tokenCount);
}

/**
 * Check if response would exceed token limit
 */
function wouldExceedTokenLimit(response: any): boolean {
  if (!response.tasks?.length) return false;
  
  // Calculate total estimated tokens
  const totalTokens = response.tasks.reduce((sum: number, task: ClickUpTask) => 
    sum + estimateTaskResponseTokens(task), 0
  );
  
  // Add overhead for response structure
  const estimatedTotal = totalTokens * 1.1;
  
  return estimatedTotal > WORKSPACE_TASKS_TOKEN_LIMIT;
}

/**
 * Handler for getting workspace tasks with filtering
 */
export async function getWorkspaceTasksHandler(
  taskService: TaskService,
  params: Record<string, any>
): Promise<Record<string, any>> {
  try {
    // Require at least one filter parameter
    const hasFilter = [
      'tags',
      'list_ids',
      'folder_ids', 
      'space_ids',
      'statuses',
      'assignees',
      'date_created_gt',
      'date_created_lt',
      'date_updated_gt',
      'date_updated_lt',
      'due_date_gt',
      'due_date_lt'
    ].some(key => params[key] !== undefined);

    if (!hasFilter) {
      throw new Error('At least one filter parameter is required (tags, list_ids, folder_ids, space_ids, statuses, assignees, or date filters)');
    }

    // For workspace tasks, we'll continue to use the direct getWorkspaceTasks method
    // since it supports specific workspace-wide filters that aren't part of the unified findTasks
    const filters: ExtendedTaskFilters = {
      tags: params.tags,
      list_ids: params.list_ids,
      folder_ids: params.folder_ids,
      space_ids: params.space_ids,
      statuses: params.statuses,
      include_closed: params.include_closed,
      include_archived_lists: params.include_archived_lists,
      include_closed_lists: params.include_closed_lists,
      archived: params.archived,
      order_by: params.order_by,
      reverse: params.reverse,
      due_date_gt: params.due_date_gt,
      due_date_lt: params.due_date_lt,
      date_created_gt: params.date_created_gt,
      date_created_lt: params.date_created_lt,
      date_updated_gt: params.date_updated_gt,
      date_updated_lt: params.date_updated_lt,
      assignees: params.assignees,
      page: params.page,
      detail_level: params.detail_level || 'detailed'
    };

    // Get tasks with adaptive response format support
    const response = await taskService.getWorkspaceTasks(filters);

    // Check token limit at handler level
    if (params.detail_level !== 'summary' && wouldExceedTokenLimit(response)) {
      logger.info('Response would exceed token limit, fetching summary format instead');
      
      // Refetch with summary format
      const summaryResponse = await taskService.getWorkspaceTasks({
        ...filters,
        detail_level: 'summary'
      });
      
      return summaryResponse;
    }

    // Return the response without adding the redundant _note field
    return response;
  } catch (error) {
    throw new Error(`Failed to get workspace tasks: ${error.message}`);
  }
}

//=============================================================================
// BULK TASK OPERATIONS
//=============================================================================

/**
 * Handler for creating multiple tasks
 */
export async function createBulkTasksHandler(params: any) {
  const { tasks, listId, listName, options } = params;

  // Validate tasks array
  validateBulkTasks(tasks, 'create');

  // Validate and resolve list ID
  const targetListId = await resolveListIdWithValidation(listId, listName);

  // Format tasks for creation
  const formattedTasks: CreateTaskData[] = tasks.map(task => {
    const taskData: CreateTaskData = {
      name: task.name,
      description: task.description,
      markdown_description: task.markdown_description,
      status: task.status,
      priority: toTaskPriority(task.priority),
      tags: task.tags,
      custom_fields: task.custom_fields
    };

    // Add due date if specified
    if (task.dueDate) {
      taskData.due_date = parseDueDate(task.dueDate);
      taskData.due_date_time = true;
    }

    // Add start date if specified
    if (task.startDate) {
      taskData.start_date = parseDueDate(task.startDate);
      taskData.start_date_time = true;
    }

    return taskData;
  });

  // Parse bulk options
  const bulkOptions = parseBulkOptions(options);

  // Create tasks - pass arguments in correct order: listId, tasks, options
  return await bulkService.createTasks(targetListId, formattedTasks, bulkOptions);
}

/**
 * Handler for updating multiple tasks
 */
export async function updateBulkTasksHandler(params: any) {
  const { tasks, options } = params;

  // Validate tasks array
  validateBulkTasks(tasks, 'update');

  // Parse bulk options
  const bulkOptions = parseBulkOptions(options);

  // Update tasks
  return await bulkService.updateTasks(tasks, bulkOptions);
}

/**
 * Handler for moving multiple tasks
 */
export async function moveBulkTasksHandler(params: any) {
  const { tasks, targetListId, targetListName, options } = params;

  // Validate tasks array
  validateBulkTasks(tasks, 'move');

  // Validate and resolve target list ID
  const resolvedTargetListId = await resolveListIdWithValidation(targetListId, targetListName);

  // Parse bulk options
  const bulkOptions = parseBulkOptions(options);

  // Move tasks
  return await bulkService.moveTasks(tasks, resolvedTargetListId, bulkOptions);
}

/**
 * Handler for deleting multiple tasks
 */
export async function deleteBulkTasksHandler(params: any) {
  const { tasks, options } = params;

  // Validate tasks array
  validateBulkTasks(tasks, 'delete');

  // Parse bulk options
  const bulkOptions = parseBulkOptions(options);

  // Delete tasks
  return await bulkService.deleteTasks(tasks, bulkOptions);
}

/**
 * Handler for deleting a task
 */
export async function deleteTaskHandler(params) {
  const taskId = await getTaskId(params.taskId, params.taskName, params.listName);
  await taskService.deleteTask(taskId);
  return true;
}
</file>

<file path="package.json">
{
  "name": "@taazkareem/clickup-mcp-server",
  "version": "0.7.2",
  "description": "ClickUp MCP Server - Integrate ClickUp tasks with AI through Model Context Protocol",
  "type": "module",
  "main": "build/index.js",
  "bin": {
    "clickup-mcp-server": "build/index.js"
  },
  "files": [
    "build",
    "README.md",
    "LICENSE",
    "Dockerfile",
    "smithery.yaml"
  ],
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "start": "node build/index.js",
    "dev": "tsc -w",
    "prepare": "npm run build"
  },
  "keywords": [
    "clickup",
    "mcp",
    "ai",
    "tasks",
    "project-management",
    "model-context-protocol",
    "clickup-server",
    "clickup-mcp-server",
    "task-management",
    "productivity",
    "automation",
    "workflow",
    "team-collaboration",
    "artificial-intelligence",
    "project-tracking",
    "task-tracking",
    "project-planning",
    "clickup-integration",
    "clickup-api",
    "clickup-automation",
    "task-organization",
    "project-organization"
  ],
  "author": "Talib Kareem",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/taazkareem/clickup-mcp-server.git"
  },
  "bugs": {
    "url": "https://github.com/taazkareem/clickup-mcp-server/issues"
  },
  "homepage": "https://github.com/taazkareem/clickup-mcp-server#readme",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.6.0",
    "axios": "^1.6.7",
    "dotenv": "^16.4.1"
  },
  "devDependencies": {
    "@types/node": "^20.11.16",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=18.0.0 <23.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}
</file>

<file path="changelog.md">
# Changelog

## v0.7.2 (2025-04-25)

### 🛠️ Bug Fixes

- Fixed time estimate support in task updates:
  - Removed redundant field-specific validation check in task update operations
  - Simplified validation to check only for the presence of update fields
  - Fixed "At least one field to update must be provided" error when using time_estimate
  - Added time string parsing for converting formats like "2h 30m" to minutes
  - Improved tool description for clear guidance on supported formats
  - Ensures compatibility with all fields defined in the UpdateTaskData type

### 🔗 References

- #45: [Bug: Time estimates not allowed when updating tasks](https://github.com/taazkareem/clickup-mcp-server/issues/45)

## v0.7.1 (2025-04-24)

### 🚀 New Features & Improvements

- Added Documents Module with comprehensive document management:
  - Document listing and search across workspace
  - Document creation with customizable visibility
  - Document page management (create, list, get, update)
  - Optional module activation via `DOCUMENT_SUPPORT=true` environment variable
  - Support for both API V2 and V3 endpoints
- Added comprehensive Time Tracking functionality:
  - View time entries for tasks with filtering options
  - Start/stop time tracking on tasks
  - Add manual time entries with flexible duration formats
  - Delete time entries
  - View currently running timer with elapsed time information
  - Track billable and non-billable time
- Added command disabling capability:
  - New `DISABLED_TOOLS` environment variable
  - Disable specific commands via comma-separated list
  - Support for both environment variable and command line argument
  - Improved security through selective command access
  - Clear error messages for disabled command attempts

### 🛠️ Bug Fixes & Improvements

- Fixed custom task ID lookup in `getTaskByCustomId` method:
  - Corrected API endpoint from `/task/custom_task_ids` to `/task/{id}` with proper parameters
  - Added required `custom_task_ids=true` and `team_id` parameters for proper authentication
  - Fixed "Authorization failed" error when retrieving tasks by custom ID
  - Improved error handling and logging for custom ID operations
- Fixed JSON schema type definitions in task tools for improved compatibility with third-party parsers:
  - Updated schema to use single string type with nullable property instead of array types
  - Ensures compatibility with Go-based parsers like windsurf that have strict type requirements
  - Affected tools: `update_task`, `update_bulk_tasks`
- Enhanced custom field handling in task updates:
  - Fixed issue with custom field updates not being properly applied
  - Improved validation and processing of custom field values
  - Ensures consistent behavior across all task update operations

### 🔄 Repository Updates

- Updated documentation with new document module features
- Added configuration guide for disabled commands
- Enhanced API reference with document management examples
- Added documentation for time tracking tools
- Improved API reference accuracy for task update operations

### 🔗 References

- #37: [Fix authorization issue with custom task IDs](https://github.com/taazkareem/clickup-mcp-server/issues/37)
- #36: [Fix types for windsurf compatibility](https://github.com/taazkareem/clickup-mcp-server/pull/36)
- #38: [Add time tracking functionality](https://github.com/taazkareem/clickup-mcp-server/pull/38)
- #39: [Add command disabling capability](https://github.com/taazkareem/clickup-mcp-server/pull/39)
- #40: [Fix custom field updates](https://github.com/taazkareem/clickup-mcp-server/pull/40)
- #41: [Add document module](https://github.com/taazkareem/clickup-mcp-server/pull/41)

## v0.6.9 (2025-04-03)

### 🚀 New Features & Improvements

- Enhanced token limit protection for workspace tasks:
  - Added handler-level token limit validation (50,000 tokens)
  - Implemented smart response format switching
  - Automatic fallback to summary format for large responses
  - Improved token estimation for task responses
  - Added logging for format switching events
  - Double-layer protection at both service and handler levels

### 🔄 Repository Updates

- Updated task handler implementation with token limit checks
- Added token estimation utilities for task responses

## v0.6.6 (2025-04-03)

### 🐛 Bug Fixes

- Fixed task caching issue causing rate limits:
  - Task IDs from name lookups weren't being shared between sequential operations
  - Each tool operation was performing redundant global task searches
  - Added task name-to-ID mapping in cache to prevent duplicate lookups
  - Improved caching efficiency for sequential operations on same task

## v0.6.5 (2025-03-28)

- Added start date support for tasks:
  - Set task start dates with natural language expressions (e.g., "now", "tomorrow at 9am")
  - Support for both creation and updates via `startDate` parameter
  - Proper time handling with `start_date_time` flag
- Added Global Task Lookup feature:
  - Find tasks by name across the entire workspace without specifying a list
  - Smart disambiguation when multiple tasks share the same name
  - Context-aware results showing list, folder, and space for each match
  - Default selection of most recently updated task when multiple matches exist
  - Backward compatible with list-specific lookups
  - Applied to all task operations: get_task, update_task, delete_task, etc.
  - Improved error messages with actionable information for disambiguation

### 🚀 Performance Optimizations

- Implemented parallel request optimization for task operations:
  - Parallel validation of tasks and lists in move operations
  - Concurrent processing of task and list data
- Added task validation caching:
  - 5-minute TTL cache for task and list validations
  - Reduced redundant API calls in bulk operations
  - Optimized cache updates after successful operations
- Enhanced workspace hierarchy fetching:
  - Implemented batched space processing (3 spaces at a time)
  - Added batched folder processing (5 folders at a time)
  - Improved rate limit compliance with controlled concurrency
  - Added detailed performance logging and metrics

## v0.6.2 (2025-03-27)

### 🛠️ Bug Fixes

- Fixed binary execution issue by adding proper shebang line to the main executable

### 🚀 New Features & Improvements

- Added tag support with tools for:
  - Managing tags at the space level (get, create, update, delete)
  - Adding/removing tags from tasks
  - Support for tags when creating and updating tasks
- Enhanced bulk task creation with tags support
- Added natural language color processing for tags:
  - Create tags with color names (e.g., "blue", "red", "yellow")
  - Support for color variations (e.g., "dark blue", "light green")
  - Automatic generation of contrasting foreground colors
  - Color commands in both tag creation and updates
- Added `get_workspace_tasks` tool for retrieving filtered workspace tasks by various criteria:
  - Requires at least one filter parameter (tags, list_ids, space_ids, etc.)
  - Supports filtering by tags, due dates, status, and more
  - Includes pagination and sorting options
  - Implements Adaptive Response Format with two detail levels:
    - `summary`: Lightweight response with essential task information
    - `detailed`: Complete task information with all fields (default)
  - Automatic format selection based on response size (50,000 token threshold)
  - Optimized for handling large datasets efficiently

### 🔄 Repository Updates

- Updated documentation to reflect new tool requirements and capabilities
- Improved API reference with detailed examples and response formats

## v0.6.0 (2025-03-26)

### 🚀 New Features & Improvements

- Added subtasks support with multi-level nesting capability
- Implemented parent parameter for creating subtasks
- Made logging level configurable via environment variable or command line
- Fixed custom task ID handling across all operations
- Default log level now set to ERROR for improved compatibility

### 📦 Dependencies

- No dependency changes in this release

### 🔄 Repository Updates

- Updated documentation for subtasks feature
- Improved API reference with subtasks examples
- Added Security Policy and Code of Conduct

### 🔗 References

- #18: [See pull request](https://github.com/taazkareem/clickup-mcp-server/pull/18)
- #20: [See pull request](https://github.com/taazkareem/clickup-mcp-server/pull/20)

## v0.5.1 (2025-03-23)

### 🚀 New Features & Improvements

- Added support for Custom IDs across all tools
- New tools:
  - `attach_task_file`: Attach files to tasks using local paths, URLs, or base64 data
  - `create_task_comment`: Add comments to tasks
  - `get_task_comments`: Retrieve comments from tasks
- Enhanced date parsing with support for "X minutes from now" expressions
- Improved task name matching with greater flexibility:
  - Case-insensitive matching
  - Partial name matching
  - Matching without emojis
- Fixed error response formatting in task comment retrieval
- Improved workspace hierarchy display to correctly show lists directly in spaces

### 📦 Dependencies

- Updated dependencies to use semantic versioning
- Upgraded:
  - @modelcontextprotocol/sdk: 0.6.0 → 0.6.1
  - axios: 1.6.7 → 1.8.4
  - dotenv: 16.4.1 → 16.4.7

### 🔄 Repository Updates

- Added automated changelog generation
- Updated documentation and README
- Added funding options through GitHub Sponsors and Buy Me A Coffee

## v0.5.0 (2025-03-22)

### 🚀 Initial Release

- First public version of ClickUp MCP Server
- Core functionality for task, list, and folder management
- Basic workspace hierarchy navigation
- NPM and Smithery deployment options

### 🔄 Repository Updates

- Initial README and documentation
- Added GitHub workflow for publishing
- Created Funding options through GitHub Sponsors and Buy Me a Coffee

### 🔗 References

- #12: [See pull request](https://github.com/taazkareem/clickup-mcp-server/pull/12)
</file>

<file path="src/server.ts">
/**
 * SPDX-FileCopyrightText: © 2025 Talib Kareem <taazkareem@icloud.com>
 * SPDX-License-Identifier: MIT
 *
 * MCP Server for ClickUp integration
 */
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
  ListResourcesRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { createClickUpServices } from "./services/clickup/index.js";
import config from "./config.js";
import { workspaceHierarchyTool, handleGetWorkspaceHierarchy } from "./tools/workspace.js";
import {
  createTaskTool,
  updateTaskTool,
  moveTaskTool,
  duplicateTaskTool,
  getTaskTool,
  deleteTaskTool,
  getTaskCommentsTool,
  createTaskCommentTool,
  createBulkTasksTool,
  updateBulkTasksTool,
  moveBulkTasksTool,
  deleteBulkTasksTool,
  attachTaskFileTool,
  getWorkspaceTasksTool,
  getTaskTimeEntriesTool,
  startTimeTrackingTool,
  stopTimeTrackingTool,
  addTimeEntryTool,
  deleteTimeEntryTool,
  getCurrentTimeEntryTool,
  handleCreateTask,
  handleUpdateTask,
  handleMoveTask,
  handleDuplicateTask,
  handleGetTasks,
  handleDeleteTask,
  handleGetTaskComments,
  handleCreateTaskComment,
  handleCreateBulkTasks,
  handleUpdateBulkTasks,
  handleMoveBulkTasks,
  handleDeleteBulkTasks,
  handleGetTask,
  handleAttachTaskFile,
  handleGetWorkspaceTasks,
  handleGetTaskTimeEntries,
  handleStartTimeTracking,
  handleStopTimeTracking,
  handleAddTimeEntry,
  handleDeleteTimeEntry,
  handleGetCurrentTimeEntry
} from "./tools/task/index.js";
import {
  createListTool, handleCreateList,
  createListInFolderTool, handleCreateListInFolder,
  getListTool, handleGetList,
  updateListTool, handleUpdateList,
  deleteListTool, handleDeleteList
} from "./tools/list.js";
import {
  createFolderTool, handleCreateFolder,
  getFolderTool, handleGetFolder,
  updateFolderTool, handleUpdateFolder,
  deleteFolderTool, handleDeleteFolder
} from "./tools/folder.js";
import {
  getSpaceTagsTool, handleGetSpaceTags,
  addTagToTaskTool, handleAddTagToTask,
  removeTagFromTaskTool, handleRemoveTagFromTask
} from "./tools/tag.js";
import {
  createDocumentTool, handleCreateDocument,
  getDocumentTool, handleGetDocument,
  listDocumentsTool, handleListDocuments,
  listDocumentPagesTool, handleListDocumentPages,
  getDocumentPagesTool, handleGetDocumentPages,
  createDocumentPageTool, handleCreateDocumentPage,
  updateDocumentPageTool, handleUpdateDocumentPage
} from "./tools/documents.js";
import { Logger } from "./logger.js";
import { clickUpServices } from "./services/shared.js";

// Create a logger instance for server
const logger = new Logger('Server');

// Use existing services from shared module instead of creating new ones
const { workspace } = clickUpServices;

export const server = new Server(
  {
    name: "clickup-mcp-server",
    version: "0.7.2",
  },
  {
    capabilities: {
      tools: {},
      prompts: {},
      resources: {},
    },
  }
);

const documentModule = () => {
  if (config.documentSupport === 'true') {
    return [
      createDocumentTool,
      getDocumentTool,
      listDocumentsTool,
      listDocumentPagesTool,
      getDocumentPagesTool,
      createDocumentPageTool,
      updateDocumentPageTool,
    ]
  } else {
    return []
  }
}

/**
 * Configure the server routes and handlers
 */
export function configureServer() {
  logger.info("Registering server request handlers");
  
  // Register ListTools handler
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    logger.debug("Received ListTools request");
    return {
      tools: [
        workspaceHierarchyTool,
        createTaskTool,
        getTaskTool,
        updateTaskTool,
        moveTaskTool,
        duplicateTaskTool,
        deleteTaskTool,
        getTaskCommentsTool,
        createTaskCommentTool,
        attachTaskFileTool,
        createBulkTasksTool,
        updateBulkTasksTool,
        moveBulkTasksTool,
        deleteBulkTasksTool,
        getWorkspaceTasksTool,
        getTaskTimeEntriesTool,
        startTimeTrackingTool,
        stopTimeTrackingTool,
        addTimeEntryTool,
        deleteTimeEntryTool,
        getCurrentTimeEntryTool,
        createListTool,
        createListInFolderTool,
        getListTool,
        updateListTool,
        deleteListTool,
        createFolderTool,
        getFolderTool,
        updateFolderTool,
        deleteFolderTool,
        getSpaceTagsTool,
        addTagToTaskTool,
        removeTagFromTaskTool,
        ...documentModule()
      ].filter(tool => !config.disabledTools.includes(tool.name))
    };
  });

  // Add handler for resources/list
  server.setRequestHandler(ListResourcesRequestSchema, async (req) => {
    logger.debug("Received ListResources request");
    return { resources: [] };
  });

  // Register CallTool handler with proper logging
  logger.info("Registering tool handlers", {
    toolCount: 40,
    categories: ["workspace", "task", "time-tracking", "list", "folder", "tag", "document"]
  });
  
  server.setRequestHandler(CallToolRequestSchema, async (req) => {
    const { name, arguments: params } = req.params;
    
    // Improved logging with more context
    logger.info(`Received CallTool request for tool: ${name}`, { 
      params 
    });
    
    // Check if the tool is disabled
    if (config.disabledTools.includes(name)) {
      logger.warn(`Tool execution blocked: Tool '${name}' is disabled.`);
      throw {
        code: -32601,
        message: `Tool '${name}' is disabled.`
      };
    }
    
    try {
      // Handle tool calls by routing to the appropriate handler
      switch (name) {
        case "get_workspace_hierarchy":
          return handleGetWorkspaceHierarchy();
        case "create_task":
          return handleCreateTask(params);
        case "update_task":
          return handleUpdateTask(params);
        case "move_task":
          return handleMoveTask(params);
        case "duplicate_task":
          return handleDuplicateTask(params);
        case "get_task":
          return handleGetTask(params);
        case "delete_task":
          return handleDeleteTask(params);
        case "get_task_comments":
          return handleGetTaskComments(params);
        case "create_task_comment":
          return handleCreateTaskComment(params);
        case "attach_task_file":
          return handleAttachTaskFile(params);
        case "create_bulk_tasks":
          return handleCreateBulkTasks(params);
        case "update_bulk_tasks":
          return handleUpdateBulkTasks(params);
        case "move_bulk_tasks":
          return handleMoveBulkTasks(params);
        case "delete_bulk_tasks":
          return handleDeleteBulkTasks(params);
        case "get_workspace_tasks":
          return handleGetWorkspaceTasks(params);
        case "create_list":
          return handleCreateList(params);
        case "create_list_in_folder":
          return handleCreateListInFolder(params);
        case "get_list":
          return handleGetList(params);
        case "update_list":
          return handleUpdateList(params);
        case "delete_list":
          return handleDeleteList(params);
        case "create_folder":
          return handleCreateFolder(params);
        case "get_folder":
          return handleGetFolder(params);
        case "update_folder":
          return handleUpdateFolder(params);
        case "delete_folder":
          return handleDeleteFolder(params);
        case "get_space_tags":
          return handleGetSpaceTags(params);
        case "add_tag_to_task":
          return handleAddTagToTask(params);
        case "remove_tag_from_task":
          return handleRemoveTagFromTask(params);
        case "get_task_time_entries":
          return handleGetTaskTimeEntries(params);
        case "start_time_tracking":
          return handleStartTimeTracking(params);
        case "stop_time_tracking":
          return handleStopTimeTracking(params);
        case "add_time_entry":
          return handleAddTimeEntry(params);
        case "delete_time_entry":
          return handleDeleteTimeEntry(params);
        case "get_current_time_entry":
          return handleGetCurrentTimeEntry(params);
        case "create_document":
          return handleCreateDocument(params);
        case "get_document":
          return handleGetDocument(params);
        case "list_documents":
          return handleListDocuments(params);
        case "list_document_pages":
          return handleListDocumentPages(params);
        case "get_document_pages":
          return handleGetDocumentPages(params);
        case "create_document_page":
          return handleCreateDocumentPage(params);
        case "update_document_page":
          return handleUpdateDocumentPage(params);
        default:
          logger.error(`Unknown tool requested: ${name}`);
          const error = new Error(`Unknown tool: ${name}`);
          error.name = "UnknownToolError";
          throw error;
      }
    } catch (err) {
      logger.error(`Error executing tool: ${name}`, err);
      
      // Transform error to a more descriptive JSON-RPC error
      if (err.name === "UnknownToolError") {
        throw {
          code: -32601,
          message: `Method not found: ${name}`
        };
      } else if (err.name === "ValidationError") {
        throw {
          code: -32602,
          message: `Invalid params for tool ${name}: ${err.message}`
        };
      } else {
        // Generic server error
        throw {
          code: -32000,
          message: `Error executing tool ${name}: ${err.message}`
        };
      }
    }
  });

  server.setRequestHandler(ListPromptsRequestSchema, async () => {
    logger.info("Received ListPrompts request");
    return { prompts: [] };
  });

  server.setRequestHandler(GetPromptRequestSchema, async () => {
    logger.error("Received GetPrompt request, but prompts are not supported");
    throw new Error("Prompt not found");
  });

  return server;
}

/**
 * Export the clickup service for use in tool handlers
 */
export { workspace };
</file>

<file path="README.md">
<img src="assets/images/clickup_mcp_server_social_image.png" alt="ClickUp MCP Server" width="100%">

![Total Supporters](https://img.shields.io/badge/🏆%20Total%20Supporters-4-gold)
[![GitHub Stars](https://img.shields.io/github/stars/TaazKareem/clickup-mcp-server?style=flat&logo=github)](https://github.com/TaazKareem/clickup-mcp-server/stargazers)
[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-brightgreen.svg)](https://github.com/TaazKareem/clickup-mcp-server/graphs/commit-activity)

A Model Context Protocol (MCP) server for integrating ClickUp tasks with AI applications. This server allows AI agents to interact with ClickUp tasks, spaces, lists, and folders through a standardized protocol.

> 🚀 **Status Update:** v0.7.2 now available with complete Time Tracking support and Document Management features.

## Setup

1. Get your credentials:
   - ClickUp API key from [ClickUp Settings](https://app.clickup.com/settings/apps)
   - Team ID from your ClickUp workspace URL
2. Choose either hosted installation (sends webhooks) or NPX installation (downloads to local path and installs dependencies)
3. Use natural language to manage your workspace!

## Smithery Installation (Quick Start)

[![smithery badge](https://smithery.ai/badge/@taazkareem/clickup-mcp-server)](https://smithery.ai/server/@TaazKareem/clickup-mcp-server)

The server is hosted on [Smithery](https://smithery.ai/server/@taazkareem/clickup-mcp-server). There, you can preview the available tools or copy the commands to run on your specific client app.

## NPX Installation

[![NPM Version](https://img.shields.io/npm/v/@taazkareem/clickup-mcp-server.svg?style=flat&logo=npm)](https://www.npmjs.com/package/@taazkareem/clickup-mcp-server)
[![Dependency Status](https://img.shields.io/badge/dependencies-up%20to%20date-brightgreen)](https://github.com/TaazKareem/clickup-mcp-server/blob/main/package.json)
[![NPM Downloads](https://img.shields.io/npm/dm/@taazkareem/clickup-mcp-server.svg?style=flat&logo=npm)](https://npmcharts.com/compare/@taazkareem/clickup-mcp-server?minimal=true)

Add this entry to your client's MCP settings JSON file:

```json
{
  "mcpServers": {
    "ClickUp": {
      "command": "npx",
      "args": [
        "-y",
        "@taazkareem/clickup-mcp-server@latest"
      ],
      "env": {
        "CLICKUP_API_KEY": "your-api-key",
        "CLICKUP_TEAM_ID": "your-team-id",
        "DOCUMENT_SUPPORT": "true"
      }
    }
  }
}
```

Or use this npx command:

`npx -y @taazkareem/clickup-mcp-server@latest --env CLICKUP_API_KEY=your-api-key --env CLICKUP_TEAM_ID=your-team-id`

**Obs: if you don't pass "DOCUMENT_SUPPORT": "true", the default is false and document support will not be active.**

Additionally, you can use the `DISABLED_TOOLS` environment variable or `--env DISABLED_TOOLS` argument to disable specific tools. Provide a comma-separated list of tool names to disable (e.g., `create_task,delete_task`).

Please disable tools you don't need if you are having issues with the number of tools or any context limitations

## Features

| 📝 Task Management                                                                                                                                                                                                                                                   | 🏷️ Tag Management                                                                                                                                                                                                                                                        |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| • Create, update, and delete tasks<br>• Move and duplicate tasks anywhere<br>• Support for single and bulk operations<br>• Set start/due dates with natural language<br>• Create and manage subtasks<br>• Add comments and attachments | • Create, update, and delete space tags<br>• Add and remove tags from tasks<br>• Use natural language color commands<br>• Automatic contrasting foreground colors<br>• View all space tags<br>• Tag-based task organization across workspace |
| ⏱️ **Time Tracking**                                                                                                                                                                                                                                          | 🌳 **Workspace Organization**                                                                                                                                                                                                                                         |
| • View time entries for tasks<br>• Start/stop time tracking on tasks<br>• Add manual time entries<br>• Delete time entries<br>• View currently running timer<br>• Track billable and non-billable time                                 | • Navigate spaces, folders, and lists<br>• Create and manage folders<br>• Organize lists within spaces<br>• Create lists in folders<br>• View workspace hierarchy<br>• Efficient path navigation                                             |
| 📄 **Document Management**                                                                                                                                                                                                                                      | ⚡ **Integration Features**                                                                                                                                                                                                                                           |
| • Document Listing through all workspace<br>• Document Page listing<br>• Document Page Details<br>• Document Creation<br>• Document page update (append & prepend)                                                                       | • Global name or ID-based lookups<br>• Case-insensitive matching<br>• Markdown formatting support<br>• Built-in rate limiting<br>• Error handling and validation<br>• Comprehensive API coverage                                             |

## Available Tools

| Tool                                                               | Description                     | Required Parameters                                                                                                          |
| ------------------------------------------------------------------ | ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| [get_workspace_hierarchy](docs/api-reference.md#workspace-navigation) | Get workspace structure         | None                                                                                                                         |
| [create_task](docs/api-reference.md#task-management)                  | Create a task                   | `name`, (`listId`/`listName`)                                                                                          |
| [create_bulk_tasks](docs/api-reference.md#task-management)            | Create multiple tasks           | `tasks[]`                                                                                                                  |
| [update_task](docs/api-reference.md#task-management)                  | Modify task                     | `taskId`/`taskName`                                                                                                      |
| [update_bulk_tasks](docs/api-reference.md#task-management)            | Update multiple tasks           | `tasks[]` with IDs or names                                                                                                |
| [get_tasks](docs/api-reference.md#task-management)                    | Get tasks from list             | `listId`/`listName`                                                                                                      |
| [get_task](docs/api-reference.md#task-management)                     | Get single task details         | `taskId`/`taskName` (with smart disambiguation)                                                                          |
| [get_workspace_tasks](docs/api-reference.md#task-management)          | Get tasks with filtering        | At least one filter (tags, list_ids, space_ids, etc.)                                                                        |
| [get_task_comments](docs/api-reference.md#task-management)            | Get comments on a task          | `taskId`/`taskName`                                                                                                      |
| [create_task_comment](docs/api-reference.md#task-management)          | Add a comment to a task         | `commentText`, (`taskId`/(`taskName`+`listName`))                                                                    |
| [attach_task_file](docs/api-reference.md#task-management)             | Attach file to a task           | `taskId`/`taskName`, (`file_data` or `file_url`)                                                                     |
| [delete_task](docs/api-reference.md#task-management)                  | Remove task                     | `taskId`/`taskName`                                                                                                      |
| [delete_bulk_tasks](docs/api-reference.md#task-management)            | Remove multiple tasks           | `tasks[]` with IDs or names                                                                                                |
| [move_task](docs/api-reference.md#task-management)                    | Move task                       | `taskId`/`taskName`, `listId`/`listName`                                                                             |
| [move_bulk_tasks](docs/api-reference.md#task-management)              | Move multiple tasks             | `tasks[]` with IDs or names, target list                                                                                   |
| [duplicate_task](docs/api-reference.md#task-management)               | Copy task                       | `taskId`/`taskName`, `listId`/`listName`                                                                             |
| [create_list](docs/api-reference.md#list-management)                  | Create list in space            | `name`, `spaceId`/`spaceName`                                                                                          |
| [create_folder](docs/api-reference.md#folder-management)              | Create folder                   | `name`, `spaceId`/`spaceName`                                                                                          |
| [create_list_in_folder](docs/api-reference.md#list-management)        | Create list in folder           | `name`, `folderId`/`folderName`                                                                                        |
| [get_folder](docs/api-reference.md#folder-management)                 | Get folder details              | `folderId`/`folderName`                                                                                                  |
| [update_folder](docs/api-reference.md#folder-management)              | Update folder properties        | `folderId`/`folderName`                                                                                                  |
| [delete_folder](docs/api-reference.md#folder-management)              | Delete folder                   | `folderId`/`folderName`                                                                                                  |
| [get_list](docs/api-reference.md#list-management)                     | Get list details                | `listId`/`listName`                                                                                                      |
| [update_list](docs/api-reference.md#list-management)                  | Update list properties          | `listId`/`listName`                                                                                                      |
| [delete_list](docs/api-reference.md#list-management)                  | Delete list                     | `listId`/`listName`                                                                                                      |
| [get_space_tags](docs/api-reference.md#tag-management)                | Get space tags                  | `spaceId`/`spaceName`                                                                                                    |
| [create_space_tag](docs/api-reference.md#tag-management)              | Create tag                      | `tagName`, `spaceId`/`spaceName`                                                                                       |
| [update_space_tag](docs/api-reference.md#tag-management)              | Update tag                      | `tagName`, `spaceId`/`spaceName`                                                                                       |
| [delete_space_tag](docs/api-reference.md#tag-management)              | Delete tag                      | `tagName`, `spaceId`/`spaceName`                                                                                       |
| [add_tag_to_task](docs/api-reference.md#tag-management)               | Add tag to task                 | `tagName`, `taskId`/(`taskName`+`listName`)                                                                          |
| [remove_tag_from_task](docs/api-reference.md#tag-management)          | Remove tag from task            | `tagName`, `taskId`/(`taskName`+`listName`)                                                                          |
| [get_task_time_entries](docs/api-reference.md#time-tracking)          | Get time entries for a task     | `taskId`/`taskName`                                                                                                      |
| [start_time_tracking](docs/api-reference.md#time-tracking)            | Start time tracking on a task   | `taskId`/`taskName`                                                                                                      |
| [stop_time_tracking](docs/api-reference.md#time-tracking)             | Stop current time tracking      | None                                                                                                                         |
| [add_time_entry](docs/api-reference.md#time-tracking)                 | Add manual time entry to a task | `taskId`/`taskName`, `start`, `duration`                                                                             |
| [delete_time_entry](docs/api-reference.md#time-tracking)              | Delete a time entry             | `timeEntryId`                                                                                                              |
| [get_current_time_entry](docs/api-reference.md#time-tracking)         | Get currently running timer     | None                                                                                                                         |
| [create_document](docs/api-reference.md#document-management)          | Create a document               | `workspaceId`, `name`, `parentId`/`parentType`, `visibility`, `create_pages`                                     |
| [get_document](docs/api-reference.md#document-management)             | Get a document                  | `workspaceId`/`documentId`                                                                                               |
| [list_documents](docs/api-reference.md#document-management)           | List documents                  | `workspaceId`, `documentId`/`creator`/`deleted`/`archived`/`parent_id`/`parent_type`/`limit`/`next_cursor` |
| [list_document_pages](docs/api-reference.md#document-management)      | List document pages             | `documentId`/`documentName`                                                                                              |
| [get_document_pages](docs/api-reference.md#document-management)       | Get document pages              | `documentId`/`documentName`, `pageIds`                                                                                 |
| [create_document_pages](docs/api-reference.md#document-management)    | Create a document page          | `workspaceId`/`documentId`, `parent_page_id`/`name`/`sub_title`,`content`/`content_format`                     |
| [update_document_page](docs/api-reference.md#document-management)     | Update a document page          | `workspaceId`/`documentId`, `name`/`sub_title`,`content`/`content_edit_mode`/`content_format`                  |

See [full documentation](docs/api-reference.md) for optional parameters and advanced usage.

## Prompts

Not yet implemented and not supported by all client apps. Request a feature for a Prompt implementation that would be most beneficial for your workflow (without it being too specific). Examples:

| Prompt                                             | Purpose                   | Features                                  |
| -------------------------------------------------- | ------------------------- | ----------------------------------------- |
| [summarize_tasks](docs/api-reference.md#prompts)      | Task overview             | Status summary, priorities, relationships |
| [analyze_priorities](docs/api-reference.md#prompts)   | Priority optimization     | Distribution analysis, sequencing         |
| [generate_description](docs/api-reference.md#prompts) | Task description creation | Objectives, criteria, dependencies        |

## Error Handling

The server provides clear error messages for:

- Missing required parameters
- Invalid IDs or names
- Items not found
- Permission issues
- API errors
- Rate limiting

The `LOG_LEVEL` environment variable can be specified to control the verbosity of server logs. Valid values are `trace`, `debug`, `info`, `warn`, and `error` (default).
This can be also be specified on the command line as, e.g. `--env LOG_LEVEL=info`.

## Support the Developer

When using this server, you may occasionally see a small sponsor message with a link to this repository included in tool responses. I hope you can support the project!
If you find this project useful, please consider supporting:

[![Sponsor TaazKareem](https://img.shields.io/badge/Sponsor-TaazKareem-orange?logo=github)](https://github.com/sponsors/TaazKareem)

<a href="https://buymeacoffee.com/taazkareem">
  <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" width="200" alt="Buy Me A Coffee">
</a>

## Acknowledgements

Special thanks to [ClickUp](https://clickup.com) for their excellent API and services that make this integration possible.

## Contributing

Contributions are welcome! Please read our [Contributing Guide](CONTRIBUTING.md) for details.

## License

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Disclaimer

This software makes use of third-party APIs and may reference trademarks
or brands owned by third parties. The use of such APIs or references does not imply
any affiliation with or endorsement by the respective companies. All trademarks and
brand names are the property of their respective owners. This project is an independent
work and is not officially associated with or sponsored by any third-party company mentioned.
</file>

</files>
